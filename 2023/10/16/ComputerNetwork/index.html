<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>计网 |  breeze</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-ComputerNetwork"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计网
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/16/ComputerNetwork/" class="article-date">
  <time datetime="2023-10-15T16:00:00.000Z" itemprop="datePublished">2023-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%98%9F%E6%B5%B7/">星海</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">39 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <span id="more"></span>
<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">计算机网络体系结构</a><a name="context.1"> </a><ul>
<li><a href="#section.2">OSI七层模型</a><a name="context.2"> </a></li>
<li><a href="#section.3">TCP&#x2F;IP 五层参考模型</a><a name="context.3"> </a></li>
<li><a href="#section.4">对比两种网络模型</a><a name="context.4"> </a></li>
<li><a href="#section.5">数据如何在各层传输</a><a name="context.5"> </a></li>
</ul>
</li>
<li><a href="#section.6">应用层</a><a name="context.6"> </a><ul>
<li><a href="#section.7">万维网和域名系统</a><a name="context.7"> </a><ul>
<li><a href="#section.8">网络资源</a><a name="context.8"> </a></li>
<li><a href="#section.9">应用程序体系架构</a><a name="context.9"> </a></li>
<li><a href="#section.10"><code>web</code>的结构组件</a><a name="context.10"> </a></li>
<li><a href="#section.11">dns域名系统</a><a name="context.11"> </a><ul>
<li><a href="#section.12">dns的作用</a><a name="context.12"> </a></li>
<li><a href="#section.13">dns服务器的结构</a><a name="context.13"> </a></li>
<li><a href="#section.14">dns的原理</a><a name="context.14"> </a></li>
<li><a href="#section.15">dns数据传输</a><a name="context.15"> </a></li>
<li><a href="#section.16">dns域名服务器名称概念</a><a name="context.16"> </a></li>
</ul>
</li>
<li><a href="#section.17">网页解析全过程</a><a name="context.17"> </a></li>
</ul>
</li>
<li><a href="#section.18">http</a><a name="context.18"> </a><ul>
<li><a href="#section.19">http报文结构</a><a name="context.19"> </a></li>
<li><a href="#section.20">http请求方法</a><a name="context.20"> </a><ul>
<li><a href="#section.21">get 和 post 的差别</a><a name="context.21"> </a></li>
<li><a href="#section.22">http状态码</a><a name="context.22"> </a></li>
<li><a href="#section.23">http 首部</a><a name="context.23"> </a></li>
</ul>
</li>
<li><a href="#section.24">具体应用</a><a name="context.24"> </a><ul>
<li><a href="#section.25">连接管理</a><a name="context.25"> </a></li>
<li><a href="#section.26">无状态协议和cookie</a><a name="context.26"> </a></li>
</ul>
</li>
<li><a href="#section.27">http和https</a><a name="context.27"> </a><ul>
<li><a href="#section.28">http 使用过程中存在安全性问题</a><a name="context.28"> </a></li>
<li><a href="#section.29">HTTP 与 HTTPS 有哪些区别？</a><a name="context.29"> </a></li>
<li><a href="#section.30">HTTPS 解决了 HTTP 的哪些问题？</a><a name="context.30"> </a></li>
</ul>
</li>
<li><a href="#section.31">websocket</a><a name="context.31"> </a></li>
</ul>
</li>
<li><a href="#section.32">网络编程 socket</a><a name="context.32"> </a><ul>
<li><a href="#section.33">套接字</a><a name="context.33"> </a></li>
</ul>
</li>
<li><a href="#section.34">其他</a><a name="context.34"> </a><ul>
<li><a href="#section.35">内容分发网 CDN</a><a name="context.35"> </a></li>
<li><a href="#section.36">抓包软件原理</a><a name="context.36"> </a></li>
<li><a href="#section.37">常用协议及其端口</a><a name="context.37"> </a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#section.38">传输层</a><a name="context.38"> </a></li>
<li><a href="#section.39">三次握手</a><a name="context.39"> </a></li>
<li><a href="#section.40">四次挥手</a><a name="context.40"> </a></li>
</ul>
<hr>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构 "></a><a href="#context.1">计算机网络体系结构</a><a name="section.1"> </a></h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型 "></a><a href="#context.2">OSI七层模型</a><a name="section.2"> </a></h3><p>OSI (Open System Interconnection Reference Model) 模型是国际标准化组织 ISO（International Organization for Standardization) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。</p>
<p><mark><strong>应用层：</strong></mark>  <b><font color='blue' size=3 face="">通过应用程序间的交互来完成特定的网络应用</font></b><br><strong><mark>表示层：</mark></strong> 解释交换数据的含义。 <b><font color='blue' size=3 face="">该层提供的服务主要包括数据压缩，数据加密以及数据描述。</font></b><br><strong><mark>会话层：</mark></strong>  <b><font color='blue' size=3 face="">负责建立、管理和终止表示层实体之间的通信会话。</font></b> 该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。<br><strong><mark>传输层：</mark></strong>  <b><font color='blue' size=3 face="">负责因特网中两台主机的进程提供通信服务。</font></b><br><strong><mark>网络层：</mark></strong>  <b><font color='blue' size=3 face="">选择合适的网间路由和交换节点，确保数据按时成功传送。</font></b><br><strong><mark>数据链路层(链路层)：</mark></strong>  <b><font color='blue' size=3 face="">数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</font></b><br><mark><strong>物理层：</strong></mark>  <b><font color='blue' size=3 face="">实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</font></b> 该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>通信协议举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用层</strong></td>
<td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、等等</td>
</tr>
<tr>
<td><strong>表示层</strong></td>
<td>XDR、ASN.1、SMB、AFP、NCP、等等</td>
</tr>
<tr>
<td><strong>会话层</strong></td>
<td>ASAP、SSH、RPC、NetBIOS、ASP、Winsock、BSD Sockets、等等</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL、等等</td>
</tr>
<tr>
<td><strong>数据链路层</strong></td>
<td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP、等等</td>
</tr>
<tr>
<td><strong>物理层</strong></td>
<td>例如铜缆、网线、光缆、无线电等等</td>
</tr>
</tbody></table>
<h3 id="TCP-IP-五层参考模型"><a href="#TCP-IP-五层参考模型" class="headerlink" title="TCP&#x2F;IP 五层参考模型 "></a><a href="#context.3">TCP&#x2F;IP 五层参考模型</a><a name="section.3"> </a></h3><p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括 <b><font color='blue' size=3 face="">应用层</font></b> 、 <b><font color='blue' size=3 face="">传输层</font></b> 、 <b><font color='blue' size=3 face="">网络层</font></b> 、 <b><font color='blue' size=3 face="">数据链路层</font></b> 和 <b><font color='blue' size=3 face="">物理层</font></b> 。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。 <b><font color='SEAGREEN' size=3 face="">五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</font></b> </p>
<p><mark><strong>应用层 ：</strong></mark> 为特定应用程序提供数据传输服务。<br><mark><strong>传输层 ：</strong></mark> 为进程提供通用数据传输服务。<br><mark><strong>网络层 ：</strong></mark> 为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。<br><mark><strong>数据链路层 ：</strong></mark> 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。<br><mark><strong>物理层 ：</strong></mark> 负责比特流在传输介质上的传播。</p>
<h3 id="对比两种网络模型"><a href="#对比两种网络模型" class="headerlink" title="对比两种网络模型 "></a><a href="#context.4">对比两种网络模型</a><a name="section.4"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161542763.png" alt="image-202310161541706"></p>
<h3 id="数据如何在各层传输"><a href="#数据如何在各层传输" class="headerlink" title="数据如何在各层传输 "></a><a href="#context.5">数据如何在各层传输</a><a name="section.5"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161542285.png" alt="image-20231016154251181"><br>假设一个主机上的一个应用向另一个主机的一个应用发送数据。</p>
<p>在发送主机端，一个应用层报文被传送到传输层。在最简单的情况下，传输层收取到报文并附上附加信息，该首部将被接收端的传输层使用。<br>应用层报文和传输层首部信息一道构成了传输层报文段。附加的信息可能包括：允许接收端传输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。<br>传输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报文。<br>该数据报文接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧。<br>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。而在接收主机端，整个过程正好反过来。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层 "></a><a href="#context.6">应用层</a><a name="section.6"> </a></h2><p>网络应用是计算机网络存在的理由，而网络应用都是处于应用层的，所以应用层是计算机网络中最重要的部分之一。</p>
<p><mark><strong>高频面试题</strong></mark></p>
<ol>
<li>uri 和 url 的区别 ？</li>
<li>dns 是啥工作原理，主要解析过程是啥？</li>
<li>用户输入网址到显示对应页面的全过程是啥？</li>
<li>http 头部包含哪些信息？</li>
<li>http 方法了解哪些？</li>
<li>http 状态码了解哪些？</li>
<li>get 和 post 的区别？</li>
<li>https 和 https 的区别？</li>
<li>https 的加密方式？</li>
<li>http 是不保存状态的协议,如何保存用户状态？</li>
<li>http 不同版本的区别？</li>
</ol>
<h3 id="万维网和域名系统"><a href="#万维网和域名系统" class="headerlink" title="万维网和域名系统 "></a><a href="#context.7">万维网和域名系统</a><a name="section.7"> </a></h3><p>万维网 <code>(WWW，World Wide Web)</code>，通常称为 <code>Web</code>，是一种信息系统，使文档和其他 <code>Web</code>资源能够通过 <code>Internet</code> 访问。</p>
<h4 id="网络资源"><a href="#网络资源" class="headerlink" title="网络资源 "></a><a href="#context.8">网络资源</a><a name="section.8"> </a></h4><p>网络上的资源必须有一个唯一的表示，才可以在网络上被访问。</p>
<ul>
<li>uri (uniform resource identifier) 统一资源标识符。</li>
<li>url (uniform resource location) 统一资源定位符，统指绝对路径。</li>
<li>urn (uniform resource name) 统一资源名。</li>
</ul>
<p>三者之间关系为， <code>url</code> 和 <code>urn</code> 分别是 <code>URI</code> 的子集 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161558665.png" alt="image-20231016155805571"></p>
<p>其中 URN 还处于实验阶段，未大范围进行使用，目前使用最多的是 url。</p>
<p>url 由三部分组成：</p>
<ol>
<li><b><font color='blue' size=3 face="">方案</font></b> ，一般是访问资源使用的协议类型，比如http:&#x2F;&#x2F;、https:&#x2F;&#x2F;。</li>
<li><b><font color='blue' size=3 face="">服务器的 web 地址</font></b> ，可以为域名或者 ip 地址 + 端口号，比如 localhost:8080 或者 127.0.0.1:8080。不添加默认为 80 ，这是访问域名不用加端口号的原因 。</li>
<li><b><font color='blue' size=3 face="">web 服务器上的某个资源</font></b> ，比如 <code>leetbook/read/networks-interview-highlights</code>。<br><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161949728.png" alt="image-20231016194907636"></li>
</ol>
<blockquote>
<p> 注意： url是否以&#x2F;结尾，意义是不同的，用户无感知的原因是因为服务器自动处理了这种差异。</p>
</blockquote>
<h4 id="应用程序体系架构"><a href="#应用程序体系架构" class="headerlink" title="应用程序体系架构 "></a><a href="#context.9">应用程序体系架构</a><a name="section.9"> </a></h4><p>应用程序体系体系架构主要分为两种。</p>
<ul>
<li><b><font color='blue' size=3 face="">C&#x2F;S(client&#x2F;server) </font></b> ：客户端之间不进行通信，客户端向服务端发送请求获取数据，服务器要一直开机，需要配备大量的数据中心。比如：微信，google，bing等等。</li>
<li><b><font color='blue' size=3 face="">P2P(peer to peer) </font></b> ：对等通信，不需要数据中心，没有客户端和服务端的区别，应用程序在间断连接的主机对之间直接通信。主要应用在流量密集型应用。比如：迅雷，bitTorrent，或者在局域网的文件内部共享应用中。</li>
</ul>
<p>目前大型互联网应用主要采用的是 C&#x2F;S 架构，导致 P2P 架构逐渐被人遗忘。 C&#x2F;S 架构又可以细分为 C&#x2F;S(client&#x2F;server) 和 B&#x2F;S(browser&#x2F;server)，即根据客户端类型划分。</p>
<ul>
<li>本地客户端：速度快，安全，灵活性较高，但是开发成本就高，比如游戏客户端。</li>
<li>浏览器：不需要安装，依托于浏览器，安全性较低，成本极低。</li>
</ul>
<p>目前很多应用既可以通过本地客户端访问也可以通过浏览器使用。比如，微信，<code>outlook</code>等等。</p>
<h4 id="web的结构组件"><a href="#web的结构组件" class="headerlink" title="web的结构组件 "></a><a href="#context.10"><code>web</code>的结构组件</a><a name="section.10"> </a></h4><p><code>web</code> 是极为复杂的，不仅只有 client 与 server 之间简单的请求响应 ，还包含了一些特殊的 <code>server</code> ，他们承担着一些特殊的作用。</p>
<ul>
<li><strong>代理：位于客户端和服务器之间的 http中间实体。</strong><br>  出于安全考虑，通常会将代理做为转发所有 Web 流量的可信任中间节点使用，可以对请求和响应进行过滤。比如，校园网中可以过滤一些不健康的内容，禁止学生进行访问。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161955749.png" alt="image-20231016195503654"></li>
<li><strong>网关：连接其他应用程序的特殊 web 服务器。</strong><br>  做为其他服务器的中间实体使用。常用于将 http 流量转化为其他的协议。网关接受请求时就好像自己本身是资源源服务器一样，客户端对此无感知。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161955353.png" alt="image-20231016195547275"></li>
<li><strong>隧道： 对 http通信报文进行盲转发的特殊代理。</strong><br>  对两条连接之间的数据进行盲转发，<code>https</code> 就是通过隧道实现的。<code>http</code> 连接承载加密的安全套接字层<code>(ssl,secure sockets layer)</code> 流量，这样 ssl 流量就可以直接穿过只允许 web 流量通过防火墙，反正亦然。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161958342.png" alt="image-20231016195807260"></li>
</ul>
<h4 id="dns域名系统"><a href="#dns域名系统" class="headerlink" title="dns域名系统 "></a><a href="#context.11">dns域名系统</a><a name="section.11"> </a></h4><p>域名系统 (dns,domain name system) 是 Internet 或其他 Internet 协议（ip） 网络中计算机、服务和其他资源的分层分布式命名系统。它将各种信息与分配给每个关联实体的域名相关联。最重要的是，它将容易记忆的域名转换为数字ip地址，用于定位和识别具有底层网络协议的计算机服务和设备。</p>
<h5 id="dns的作用"><a href="#dns的作用" class="headerlink" title="dns的作用 "></a><a href="#context.12">dns的作用</a><a name="section.12"> </a></h5><p>在dns 出现之前，互联网中某台主机的唯一标识是这台机器的 ip 地址，但是这种方式记起来很麻烦，人们更喜欢便于记忆的名称。为了解决这个问题，人们需要一种从主机名称到 ip 地址转换的服务，域名系统作为将域名和 ip 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<blockquote>
<p>小提示：<code>dns</code>域名支持中文字符</p>
</blockquote>
<h5 id="dns服务器的结构"><a href="#dns服务器的结构" class="headerlink" title="dns服务器的结构 "></a><a href="#context.13">dns服务器的结构</a><a name="section.13"> </a></h5><p>dns域名的结构是 xxx.xxx.xxx，是分层的。分为顶级域名（一级域名），二级域名，三级域名 . . . . .</p>
<p>顶级域名会根据国家地区，或者组织进行划分,比如cn（代表中国）、edu（代表教育组织）。二级域名就是在顶级域名前面加前缀,比如 leetcode.cn。也正因为如此，dns服务器的结构是树状的。</p>
<p>域名以及服务器结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162026324.png" alt="image-20231016202631241"></p>
<blockquote>
<p>注意：映射关系为根域名服务器管理顶级域名，顶级域名服务器管理二级域名，权威域名服务器管理日常使用的网址映射记录。</p>
</blockquote>
<h5 id="dns的原理"><a href="#dns的原理" class="headerlink" title="dns的原理 "></a><a href="#context.14">dns的原理</a><a name="section.14"> </a></h5><p>以一个例子来了解 dns 的工作原理。</p>
<p>假设一个客户端 A，想要查询 a.leetcode.cn 的 ip 地址，考虑缓存的情况。</p>
<ol>
<li>客户端 A 首先查询本地的 hosts 文件，查询是否有网址映射关系，如果没有，进行下一步查找。</li>
<li>查找本地的 dns 解析器缓存，如果没有进行下一步。</li>
<li>根据 tcp&#x2F;ip 参数查找设置好的首选 dns 服务器 ip 地址，一般叫做本地 dns 服务器，查询本地 dns 服务器。本地 dns 服务器如果没有，它就会进行下一步操作。</li>
<li>本地dns会访问根服务器 ，然后根据后缀名，从根服务器中查找对应的顶级域名服务器的 ip ，然后以此向下查找域名服务器的 ip ，然后查找网址映射关系,直到找到为止。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162029122.png" alt="image-20231016202955029"></p>
<blockquote>
<p>客户端 A 向本地域名服务器查询为递归查询，本地域名服务器向根域名服务器查询为迭代查询。</p>
</blockquote>
<h5 id="dns数据传输"><a href="#dns数据传输" class="headerlink" title="dns数据传输 "></a><a href="#context.15">dns数据传输</a><a name="section.15"> </a></h5><p>dns 的数据传输是采用 tcp 协议还是 udp 协议 ，或者是其他的什么协议 ？</p>
<p>dns 既采用 udp 协议也采用 tcp 协议:</p>
<ul>
<li>dns 是通过 53 端口进行通信，默认是采用 udp 协议进行数据传输的，除了个别情况，也就是说绝大多数情况是采用 udp 进行传输。</li>
<li>使用 tcp 传输的情况:<ul>
<li>当返回的响应超过的 512 字节（ udp 最大只支持 512 字节的数据）。</li>
<li>区域传送：主域名服务器向辅助域名服务器传送变化的那部分数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意: tcp 协议和 tcp 协议是可以同时绑定同一个端口的。<br>区域传输: dns 服务器中数据不总是一成不变的，域名数量是不断增加，而且一些域名对应着的服务器的也是在变化的，所以其实 dns 服务器中的数据是不断增加的，并且随时流动的，所以可以将区域传输简单理解为 dns 服务器之间进行的数据传输。</p>
</blockquote>
<h5 id="dns域名服务器名称概念"><a href="#dns域名服务器名称概念" class="headerlink" title="dns域名服务器名称概念 "></a><a href="#context.16">dns域名服务器名称概念</a><a name="section.16"> </a></h5><ul>
<li><strong>根域名服务器：</strong>最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的ip地址，全球有 13 个根域名服务器。</li>
<li><strong>顶级域名服务器：</strong>负责处理所有顶级域名，提供到权威域服务器的映射。</li>
<li><strong>授权(权威)域名服务器：</strong>提供主机名到 IP 地址间的映射服务</li>
<li><strong>主域名服务器：</strong>一个或多个区域域名解析工作的主要域名服务器，通常也是一个或多个区域的授权域名服务器。</li>
<li><strong>辅助域名服务器：</strong>协助主域名服务器提供域名查询服务，在主机很多的情况下，可以有效分担主域名服务器的压力。当主域名服务器故障时，辅助域名服务器能够在数据有效期内继续为主机提供域名解析服务。</li>
</ul>
<h4 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程 "></a><a href="#context.17">网页解析全过程</a><a name="section.17"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162035110.png" alt="image-20231016203532026"></p>
<ol>
<li><strong>dns 解析：</strong>访问一个网站时，浏览器获得一个域名，通过 dns 服务将域名解析为 ip 地址。</li>
<li><strong>tcp 连接：</strong>向 Web 服务器发起 tcp 连接请求。</li>
<li><strong>发送 http 请求：</strong>浏览器向 Web 服务器发起一个 http 请求，http 协议是建立在 tcp 协议之上的应用层协议，其本质是在建立起的 tcp连接中，按照 http 协议标准发送一个索要网页的请求。</li>
<li><strong>处理请求并返回：</strong>服务器获取到客户端的 http 请求后，会根据 http 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li>
<li><strong>浏览器渲染：</strong>浏览器根据响应开始显示页面，首先解析 html 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li>
<li><strong>断开连接：</strong>客户端和服务器断开连接。</li>
</ol>
<h3 id="http"><a href="#http" class="headerlink" title="http "></a><a href="#context.18">http</a><a name="section.18"> </a></h3><blockquote>
<p>http(hypertext transfer protocol) 超文本传输协议从诞生到现在，一共存在五个版本。最早期 http0.9，较为完善的 http1.0，当前主流的 http1.1，正在试用的 http2.0，未来的 http3.0。本章节内容涉及的所有关于 http 内容默认为 http1.1 版本的内容。其他版本会进行标注。</p>
</blockquote>
<h4 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构 "></a><a href="#context.19">http报文结构</a><a name="section.19"> </a></h4><ul>
<li>第一部分简略信息，包含请求方法、url 和协议版本；或者协议版本和状态码</li>
<li>第二部分为请求首部 Header 或者响应首部 Header;</li>
<li>第三部分为内容主体</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 第一部分：简略信息</span><br><span class="line">GET https://leetcode.cn/problemset/all/ HTTP/1.1.  </span><br><span class="line">// 第二部分：请求首部或者响应首部</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>leetcode.cn</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;3147526947+gzip&quot;</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 xxx</span><br><span class="line">// --------- 空行 --------------</span><br><span class="line">// 第三部分，内容主体</span><br><span class="line">param1=1&amp;param2=2</span><br></pre></td></tr></table></figure>



<h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法 "></a><a href="#context.20">http请求方法</a><a name="section.20"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162039535.png" alt="image-20231016203901432"></p>
<p>http 请求方法是为了服务器功能实现起来更方便，但不意味着每种特定的方法只能实现某种特定的功能。http 方法设计较为灵活，方法本身虽然有一些规则，但是最重要的还是开发者如何开发设计，正因为如此，不同的浏览器和不同的服务器会有一些限制，但是这和 http 方法关系不大。比如：</p>
<ul>
<li>有些服务器不支持get 方法设置 body，对于这种服务器，get 方法通常是通过以 url 的 parameters 或者 Anchor 进行传递数据的<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162039658.png" alt="image-20231016203924580">也就是说 get 方法传递数据的大小和 url 的长度直接相关，url 本身并没有对长度进行限制，但是浏览器会对 url 进行限制，比如 FireFox 限制 url 的最大长度为 65536 个字符，也就是 64KB的大小，而 Chrome 限制 url 最大长度为 8182个字符，也就是 8 KB 的大小。</li>
<li>post 方法向服务器发送数据是通过 body ，post 方法本身对 body 的大小也没有限制，但是不同的服务器处理的能力是不同的，较为强大的服务器可以接收几十 GB 的数据，而一些服务器最多只能接收几十 MB 的数据。</li>
</ul>
<h5 id="get-和-post-的差别"><a href="#get-和-post-的差别" class="headerlink" title="get 和 post 的差别 "></a><a href="#context.21">get 和 post 的差别</a><a name="section.21"> </a></h5><ul>
<li><p>get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。</p>
<ul>
<li><p>get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</p>
<blockquote>
<p>注意：http有安全方法的概念，即不改变服务器状态。 get 方法不会改变服务器状态，而 post 会改变服务器的状态，从这个角度来看，get方法更安全。<br>总结：get 方法对于服务器更安全，post 方法对于客户端更安全.</p>
</blockquote>
</li>
<li><p>post 可以进行复杂的加密，get 则不可以</p>
</li>
<li><p>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</p>
</li>
<li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制</p>
</li>
</ul>
</li>
<li><p>get 方法具有幂等性，post 方法不具有。</p>
</li>
</ul>
<blockquote>
<p>幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
</blockquote>
<ul>
<li><p>post方法有时会发送两个 tcp 数据包，与浏览器有关</p>
<ul>
<li><p>使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</p>
</li>
<li><p>而 GET 方法 Header 和 Data 会一起发送</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码 "></a><a href="#context.22">http状态码</a><a name="section.22"> </a></h5><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162050741.png" alt="image-20231016204913695"></p>
<p>比较常见的状态码(面试只需要了解以下状态码即可)</p>
<ul>
<li>200：成功返回响应</li>
<li>301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</li>
<li>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。</li>
<li>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</li>
<li>401：没有权限访问，当前用户没有权限访问此资源。</li>
<li>403: 请求被服务器禁止。</li>
<li>404：请求的 url 不存在，一般是 url 出错。</li>
<li>500： 服务器处理请求出现错误。</li>
<li>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</li>
<li>504：来自网关或者代理服务器，请求资源服务器时超时。</li>
</ul>
<blockquote>
<p> http状态码目录：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p>
</blockquote>
<p>与请求方法一样，http 状态码也是为了方便开发的一种标准，大部分的服务器在大范围上都是遵循该标准的。但是不能保证所有服务器严格遵循此标准，毕竟状态码只是服务器返回数据中的一部分，一些自定义的服务器可能对于所有的 5XX 类型错误都返回 500 状态码。</p>
<h5 id="http-首部"><a href="#http-首部" class="headerlink" title="http 首部 "></a><a href="#context.23">http 首部</a><a name="section.23"> </a></h5><p>http 主要有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。除此之外，还有一种扩展首部，该种首部还未添加的 http 标准中去。在一些大型互联网公司内部，开发者需要特定的扩展首部来实现特殊的功能。</p>
<ul>
<li><strong>通用首部字段：</strong>请求和响应都可以使用的首部，与报文相关的最基本的信息。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162052679.png" alt="image-20231016205246590"></li>
<li><strong>请求首部字段：</strong>仅在请求中使用的首部。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162052261.png" alt="image-20231016205255174"></li>
<li><strong>响应首部字段：</strong>仅在响应中使用的首部。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162053299.png" alt="image-20231016205304205"></li>
<li><strong>实体首部字段：</strong>用于应对实体部分的首部，一般是对实体内容进行说明。<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162053173.png" alt="image-20231016205311078"></li>
</ul>
<blockquote>
<p> http请求首部目录：<a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</a></p>
</blockquote>
<p>与状态码一样，对于 http 首部，只要记住几个常用的就可以</p>
<h4 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用 "></a><a href="#context.24">具体应用</a><a name="section.24"> </a></h4><h5 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理 "></a><a href="#context.25">连接管理</a><a name="section.25"> </a></h5><ul>
<li><p><strong>短连接与长连接</strong><br>  当客户端访问一个包含多媒体资源的 html 页面时，除了请求访问的 html 页面资源，还会请求访问多媒体资源。这个过程中需要发送很多个 http 请求，如果每进行一次 http 通信就要新建一个 tcp 连接，对于客户度和服务器的压力是很大的。<br>  长连接只需要建立一次 tcp 连接就能进行多次 http 通信，短连接每个 http请求就要建立一次 tcp 连接。</p>
<ul>
<li>从 http&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，首部为 Connection : close；</li>
<li>在 http&#x2F;1.1 之前默认是短连接的，如果需要使用长连接。首部为 Connection : Keep-Alive。</li>
</ul>
</li>
<li><p><strong>流水线</strong><br>  默认情况下，http 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间，而流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样 http 的速度会快很多，tcp 连接的利用率也会非常高。</p>
</li>
</ul>
<h5 id="无状态协议和cookie"><a href="#无状态协议和cookie" class="headerlink" title="无状态协议和cookie "></a><a href="#context.26">无状态协议和cookie</a><a name="section.26"> </a></h5><ul>
<li>http 是一种不保存状态，即无状态协议。http 协议自身不对请求和响应之间的通信状态进行保存。也就是说 http 协议对于发送过的请求和接受过的请求都不做持久化处理，这样可以更快地处理大量事物，确保协议的可伸缩性。</li>
<li>http 不保存状态，那么服务端是如何知道请求是那个客户端发送过来的呢？解决方案有很多种，我们介绍一下最简单的两种。<ul>
<li>session 的形式<ol>
<li>客户端第一次发送信息到服务器时，服务器为该客户端创建一个 session 对象，该 session 包含客户端身份信息，同时为该 session 生成一个 sessionId 。</li>
<li>服务端将这个 sessionId 分配给客户端，客户端发送请求时带有此 sessionId ，服务端就可以区分客户端。</li>
</ol>
</li>
<li>cookie 的形式<ol>
<li>客户端第一次发送信息到服务器时，服务器根据该客户端信息编码加密生成一个 cookie。</li>
<li>服务端将此 cookie 发送给客户端，客户端发送请求时带有此 cookie ，服务端就可以区分客户端。</li>
</ol>
</li>
</ul>
</li>
<li>服务器将 cookie 和 sessionId 发送给客户端时是通过 set-cookie 首部，客户端将两个字断发送给服务器是通过 cookie 首部。发送请求时，cookie 首部可以包含多个服务端的 cookie，服务端接收请求时，取出自己所需的 cookie。</li>
<li>cookie 首部包含的信息<br>  <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162058358.png" alt="image-20231016205824254"></li>
<li>客户端禁用 cookie 首部时，如何传递 cookie 信息？<br>  可以将 cookie 信息放到 url 的 params 中或者请求的 body 中，但一般的解决方案是放在 url 的 params 中，通过重写 url 的方式传递。</li>
<li>cookie 和 session 两种解决方案的区别<ul>
<li>session 解决方案需要在服务端存储客户端的数据，分布式服务器需要设置单独且唯一的数据中心，占用资源较大。但是客户端携带的 sessionId 不包含的用户信息，较为安全。</li>
<li>cookie 的解决方案不需要在服务器存储客户端的数据，占用资源较小，可拓展性较高；请求携带的cookie 携带着用户信息，相对来说，没那么安全 ；从数据量上来看，cookie 一般都比 sessionId 大，传输过程中占用较大资源。</li>
</ul>
</li>
</ul>
<h4 id="http和https"><a href="#http和https" class="headerlink" title="http和https "></a><a href="#context.27">http和https</a><a name="section.27"> </a></h4><h5 id="http-使用过程中存在安全性问题"><a href="#http-使用过程中存在安全性问题" class="headerlink" title="http 使用过程中存在安全性问题 "></a><a href="#context.28">http 使用过程中存在安全性问题</a><a name="section.28"> </a></h5><ul>
<li>使用明文通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<h5 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？ "></a><a href="#context.29">HTTP 与 HTTPS 有哪些区别？</a><a name="section.29"> </a></h5><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样， <b><font color='blue' size=3 face="">HTTP 默认端口号是 80</font></b> ， <b><font color='blue' size=3 face="">HTTPS 默认端口号是 443</font></b> 。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h5 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？ "></a><a href="#context.30">HTTPS 解决了 HTTP 的哪些问题？</a><a name="section.30"> </a></h5><p> <b><font color='blue' size=3 face="">HTTP</font></b>  由于 <b><font color='blue' size=3 face="">是明文传输</font></b> ，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161703527.png" alt="image-20231016170308423"></p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<blockquote>
<p>HTTPS 是如何解决上面的三个风险的？</p>
</blockquote>
<ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<p> <b><font color='blue' size=3 face=""><em>1. 混合加密</em></font></b> </p>
<p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161704199.png" alt="image-20231016170421071"></p>
<p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<p> <b><font color='blue' size=3 face=""><em>2. 摘要算法 + 数字签名</em></font></b> </p>
<p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p>
<p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p>
<p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161706664.png" alt="image-20231016170611555"></p>
<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<p>举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。</p>
<p>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。</p>
<p>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p>
<p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p>
<ul>
<li>一个是公钥，这个是可以公开给所有人的；</li>
<li>一个是私钥，这个必须由本人管理，不可泄露。</li>
</ul>
<p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p>
<p>流程的不同，意味着目的也不相同：</p>
<ul>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li>
<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
<p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p>
<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161706246.png" alt="image-20231016170652138"></p>
<p>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p>
<p>引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。</p>
<p>这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。</p>
<p> <b><font color='blue' size=3 face=""><em>3. 数字证书</em></font></b> </p>
<p>前面我们知道：</p>
<ul>
<li>可以通过哈希算法来保证消息的完整性；</li>
<li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li>
</ul>
<p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p>
<p>还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。</p>
<p>但是我们还可以自己伪造出一对公私钥啊！</p>
<p>你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。</p>
<p>但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。</p>
<p>好家伙，为了一个请假，真的是斗智斗勇。</p>
<p>后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。</p>
<p>正所谓魔高一丈，道高一尺。</p>
<p>既然伪造公私钥那么随意，所以你爸把他的公钥注册到<strong>警察局</strong>，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个<strong>数字证书，也就是说这个数字证书包含你爸爸的公钥。</strong></p>
<p>这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。</p>
<p>老师拿到了数字证书后，<strong>首先会去警察局验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。</p>
<p><strong>由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的</strong>，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。</p>
<p>正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。</p>
<p>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<p>数字证书的工作流程，我也画了一张图，方便大家理解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310161707407.png" alt="image-20231016170753272"></p>
<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket "></a><a href="#context.31">websocket</a><a name="section.31"> </a></h4><p>一般的 web 程序是 c&#x2F;s 架构，也就是说服务端不能主动给客户端发送数据。只有当客户端向服务端发送请求时，服务端才可以向客户端返回响应。但是很多场景下都需要服务端直接向客户端发送请求，比如进行服务推送。面对这种情况，一般的处理方案是客户端轮训服务端，客户端不断向服务端发送请求。这种方式的效率是十分低下，并且占用大量的计算资源，即包括客户端资源也包括服务器资源。</p>
<p>websocket 的出现就是为了解决这个问题。websocket，即 web 浏览器与 web 服务器之间全双工通信标准。其中，websocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。</p>
<blockquote>
<p>通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
</blockquote>
<p><strong>websocket 的特征：</strong></p>
<ol>
<li>建立在 tcp 协议之上。</li>
<li>与 http 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 http 协议，因此握手时不容易屏蔽，能通过各种 http 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
</ol>
<h3 id="网络编程-socket"><a href="#网络编程-socket" class="headerlink" title="网络编程 socket "></a><a href="#context.32">网络编程 socket</a><a name="section.32"> </a></h3><p>以上提及的一些应用层程序都是在一些应用层协议框架之上实现的，并不是直接利用传输层的接口进行实现。</p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字 "></a><a href="#context.33">套接字</a><a name="section.33"> </a></h4><p>套接字 (Socket) 是对网络中不同主机上的应用进程之间进行通信的接口，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 tcp 用主机的 ip 地址 + 端口号作为 tcp 连接的端点，这个端点就叫做套接字。</p>
<p>套接字主要有以下 <b><font color='DODGERBLUE' size=3 face="">三种类型</font></b> ：</p>
<ul>
<li><b><font color='blue' size=3 face="">流套接字(tcp 套接字）：</font></b> 流套接字基于 tcp 传输协议，tcp协议发送数据流。主要用于提供面向连接、可靠的数据传输服务。由于 tcp 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li>
<li><b><font color='blue' size=3 face="">数据报套接字(udp套接字)：</font></b> 数据报套接字基于 udp 传输协议，udp 协议发送数据报。对应于无连接的 udp 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 udp 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 udp 套接字时，丢包等问题需要在程序中进行处理。</li>
<li><b><font color='blue' size=3 face="">原始套接字：</font></b> 由于流套接字和数据报套接字只能读取 tcp 和 udp 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li>
</ul>
<blockquote>
<p>细节参考传输层</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他 "></a><a href="#context.34">其他</a><a name="section.34"> </a></h3><h4 id="内容分发网-CDN"><a href="#内容分发网-CDN" class="headerlink" title="内容分发网 CDN "></a><a href="#context.35">内容分发网 CDN</a><a name="section.35"> </a></h4><p>内容分发网络(Content distribution network，CDN)是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 html、css、javascript、音乐、图片、视频等静态资源分发给用户。</p>
<p>CDN主要有以下优点：</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
<h4 id="抓包软件原理"><a href="#抓包软件原理" class="headerlink" title="抓包软件原理 "></a><a href="#context.36">抓包软件原理</a><a name="section.36"> </a></h4><p>网络数据在网络中传输，无论如何都要经过网络节点，假如需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包</p>
<h4 id="常用协议及其端口"><a href="#常用协议及其端口" class="headerlink" title="常用协议及其端口 "></a><a href="#context.37">常用协议及其端口</a><a name="section.37"> </a></h4><p>对于应用层来说，考察的重点集中在 http 协议和 dns 这两块，其他协议考察较少，我们仅加以了解即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162108452.png" alt="image-20231016210800353"></p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层 "></a><a href="#context.38">传输层</a><a name="section.38"> </a></h2><p>传输层位于应用层和网络层之间，是分层网络体系结构最重要的部分之一。 传输层依赖网络层提供的网络服务，并且向应用层提供传输服务。</p>
<p><strong>本章高频面试题</strong></p>
<ol>
<li>为什么要进行三次握手？两次握手可以吗?</li>
<li>为什么要四次挥手？</li>
<li>CTIME-WAIT 为什么是 2MSL？</li>
<li>TCP 和 UDP 的区别？</li>
<li>TCP 是如何保证可靠性的，UDP 为什么是不可靠的 ？</li>
<li>TCP 报文包含哪些信息 ？</li>
<li>UDP 包含哪些信息</li>
<li>三次握手和四次挥手过程中，网络断开会发生什么？</li>
</ol>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手 "></a><a href="#context.39">三次握手</a><a name="section.39"> </a></h2><p>服务端先从close到listen</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162342472.png" alt="image-20230616144934262"></p>
<ol>
<li><p>第一个 <code>SYN</code> 报文<br> 客户端随机初始化序列号 <code>client_isn</code>，放进 TCP ⾸部序列号段，然后把 SYN 置1。把SYN报⽂发送给服务端，表示发起连接，之后客户端处于 <code>SYN-SENT</code> 状态</p>
</li>
<li><p>第⼆个报文 <code>SYN+ACK</code> 报文</p>
<p> 服务端收到客户端的 SYN 报文，把自己的序号 <code>server_isn</code> 放进TCP首部序列号段，确认应答号填⼊ <code>client_ins + 1</code>，把 <code>SYN+ACK</code> 置1。把 <code>SYN+ACK</code> 报⽂发送给客户端，然后进入 <code>SYN-RCVD</code> 状态</p>
</li>
<li><p>第三个报文 <code>ACK</code><br> 客户端收到服务端报文后，还要向服务端回应最后⼀个应答报文。首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次 [确认应答号] 字段填入 <code>server_isn+1</code>  ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态</p>
</li>
</ol>
<p><strong>为什么需要三次握手？</strong></p>
<p><strong>总结：</strong></p>
<ol>
<li>三次握手才可以阻止重复历史连接的初始化（主因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手 "></a><a href="#context.40">四次挥手</a><a name="section.40"> </a></h2><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202310162342271.png" alt="image-20230616151619400"></p>
<p><strong>断开过程：</strong></p>
<ol>
<li>假设客户端打算关闭连接，发送⼀个TCP首部FIN被置1的FIN报文给服务端</li>
<li>服务端收到以后，向客户端发送ACK应答报文</li>
<li>等待服务端处理完成数据后，向客户端发送FIN报文</li>
<li>客户端接收到FIN报文后回一个ACK应答报文</li>
<li>服务器收到ACK报文后，进入close状态，服务器完成连接关闭</li>
<li>客户端在经过 2MSL 一段时间后，自动进入close状态，客户端也完成连接的关闭</li>
</ol>
<p><strong>为什么挥手需要四次？</strong></p>
<p><strong>答：</strong> 关闭连接时，客户端发送FIN报文，表示其不再发送数据，但还可以接收数据</p>
<p><strong>为什么 TIME_WAIT 等待的时间是 2MSL</strong></p>
<p><strong>答：</strong> （1）MSL是 Maximum Segment Lifetime，报文最最大存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
<p>​		（2）等待MSL两倍：网络中可能存在发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间</p>
<p>​		（3）2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文， 那么 2MSL 时间将重新计时</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://wyinhui.github.io/2023/10/16/ComputerNetwork/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%98%9F%E6%B5%B7/" rel="tag">星海</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2023/10/10/C++/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class="ri-heart-fill heart_icon"></i> WYh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="breeze"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>