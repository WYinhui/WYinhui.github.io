<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++</title>
    <url>/2023/07/26/C++/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.2">输入输出</a><a name="context.2"> </a><ul>
<li><a href="#section.3">getline</a><a name="context.3"> </a></li>
<li><a href="#section.4">cin</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">nullptr</a><a name="context.5"> </a></li>
<li><a href="#section.6">左值右值</a><a name="context.6"> </a></li>
<li><a href="#section.7">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="context.7"> </a></li>
<li><a href="#section.8">类</a><a name="context.8"> </a></li>
<li><a href="#section.9">友元</a><a name="context.9"> </a><ul>
<li><a href="#section.10">友元函数</a><a name="context.10"> </a></li>
<li><a href="#section.11">友元类</a><a name="context.11"> </a></li>
</ul>
</li>
<li><a href="#section.12">重载</a><a name="context.12"> </a></li>
<li><a href="#section.13">bitset（位库）</a><a name="context.13"> </a></li>
<li><a href="#section.14">STL</a><a name="context.14"> </a></li>
<li><a href="#section.15">unordered_set方法</a><a name="context.15"> </a></li>
<li><a href="#section.16">pair容器</a><a name="context.16"> </a></li>
<li><a href="#section.17">vector 容器</a><a name="context.17"> </a></li>
<li><a href="#section.18">list（链表）</a><a name="context.18"> </a></li>
<li><a href="#section.19">vector和list的区别</a><a name="context.19"> </a></li>
<li><a href="#section.20">deque（双端数组）</a><a name="context.20"> </a></li>
<li><a href="#section.21">stack &#x2F; queue</a><a name="context.21"> </a></li>
<li><a href="#section.22">priority_queue</a><a name="context.22"> </a></li>
<li><a href="#section.23">map &#x2F; set</a><a name="context.23"> </a></li>
<li><a href="#section.24">map &#x2F; unordered_map</a><a name="context.24"> </a></li>
<li><a href="#section.25">multimap</a><a name="context.25"> </a></li>
<li><a href="#section.26">C++模板全特化和偏特化</a><a name="context.26"> </a></li>
<li><a href="#section.27">lambda表达式</a><a name="context.27"> </a></li>
<li><a href="#section.28">智能指针</a><a name="context.28"> </a><ul>
<li><a href="#section.29">定义</a><a name="context.29"> </a></li>
<li><a href="#section.30">shared_ptr（常用）</a><a name="context.30"> </a></li>
<li><a href="#section.31">unique_ptr</a><a name="context.31"> </a></li>
<li><a href="#section.32">weak_ptr</a><a name="context.32"> </a></li>
<li><a href="#section.33">auto_ptr</a><a name="context.33"> </a></li>
</ul>
</li>
<li><a href="#section.34">function</a><a name="context.34"> </a></li>
<li><a href="#section.35">decltype &#x2F; auto</a><a name="context.35"> </a></li>
</ul>
<hr>
<span id="more"></span>

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出 "></a><a href="#context.2">输入输出</a><a name="section.2"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; ++i &lt;&lt; i++ &lt;&lt; i &lt;&lt; i++ &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line"><span class="comment">///&lt; 输出为 &amp;5 3 &amp;5 2 &amp;5</span></span><br></pre></td></tr></table></figure>

<p>cout输出控制台过程如下</p>
<p><img src="https://img-blog.csdnimg.cn/c3b860c89ec5480c94adc55a74024f98.png" alt="img"></p>
<p>从 <code>endl</code> 开始，从右向左依次入栈，最后依次弹出</p>
<h3 id="getline"><a href="#getline" class="headerlink" title="getline "></a><a href="#context.3">getline</a><a name="section.3"> </a></h3><p>默认遇换行符或 <code>EOF</code> 结束，也可自定义结束符</p>
<p>上限字符数为 <code>1024</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare s: 字符串变量</span></span><br><span class="line"><span class="comment"> * @pare n: 字符个数 (第n个补&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;iostream&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">std::cin.<span class="built_in">getline</span>(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare is: 标准输入流函数 (常用 std::cin)</span></span><br><span class="line"><span class="comment"> * @pare str: 存字符的变量名</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;string&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">string::<span class="built_in">getline</span>(istream&amp; is, string&amp; str, <span class="type">char</span> delim);</span><br></pre></td></tr></table></figure>



<h3 id="cin"><a href="#cin" class="headerlink" title="cin "></a><a href="#context.4">cin</a><a name="section.4"> </a></h3><p>在上述的停止条件上，遇空格也会停止</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr "></a><a href="#context.5">nullptr</a><a name="section.5"> </a></h2><p>c++11引入 <code>nullptr</code> ，为 <strong>右值常量</strong></p>
<p>原因：</p>
<p>在函数重载的时候，如果还是用C语言的 <code>NULL</code> 则会出错，并且 <code>NULL</code> 只是单纯的宏定义替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;int\n&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;ptr\n&quot;</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">NULL</span>);  <span class="comment">///&lt; 不注释掉的话会报错</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 输出 &quot;ptr&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值 "></a><a href="#context.6">左值右值</a><a name="section.6"> </a></h2><p>首先区分一下什么是左值，什么是右值。<br>左值就是可以写在赋值号左边的，右值是写在赋值号右边的。<br>比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Stu <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Stu</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是左值</span></span><br><span class="line">Stu s = <span class="built_in">foo</span>(); <span class="comment">// s是左值，foo()的返回值是右值</span></span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// a + b 的结果是右值，c是左值</span></span><br></pre></td></tr></table></figure>

<p><code>foo()</code> 返回了一个没有名字的<code>Stu</code>对象，你不能写<code>foo() = s</code>，所以<code>foo()</code>就是个右值。<br>还有一种定义说是，无法取地址的就是右值，可以取地址的是左值。</p>
<h2 id="左值引用-和右值引用"><a href="#左值引用-和右值引用" class="headerlink" title="左值引用(&amp;)和右值引用(&amp;&amp;) "></a><a href="#context.7">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="section.7"> </a></h2><p>首先要注意一点：<code>&amp;&amp;</code>不是“引用的引用”，这仅仅是一个记号，这个记号我改成<code>$</code>也没什么问题。不能像理解指针<code>**</code>是指针的指针这样去类比。<br>左值引用就是给左值变量起别名，右值引用就是给右值变量起别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;aa = a; <span class="comment">//左值引用</span></span><br><span class="line">Stu &amp;&amp;s = <span class="built_in">foo</span>(); <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>Stu &amp;&amp;s &#x3D; foo()，就是给foo()返回的临时对象起了个别名，本来它在foo()返回后生存期就到了，就该析构了，但是由于s对她进行了引用，他的生存期被延长至和s相同。如果是Stu s &#x3D; foo()则会在赋值时发生一次拷贝构造。</p>
<p>附两篇写的很好的文章<br><a href="https://www.cnblogs.com/sunchaothu/p/11392116.html">C++ 11的移动语义 - 行者孙 - 博客园</a><br><a href="https://www.cnblogs.com/lidabo/p/3908681.html">C++11新特性：右值引用和转移构造函数 - DoubleLi - 博客园</a></p>
<p>作者：wangbingbing</p>
<p>出处：<a href="https://www.cnblogs.com/wangbingbing/p/15179675.html">https://www.cnblogs.com/wangbingbing/p/15179675.html</a></p>
<h2 id="类"><a href="#类" class="headerlink" title="类 "></a><a href="#context.8">类</a><a name="section.8"> </a></h2><p><strong>注意：</strong></p>
<ol>
<li>成员变量和成员函数分开存储</li>
<li>静态成员只能在类外初始化，<code>cosnt</code> 常量静态成员在类内初始化<br>静态成员变量，属于某个类，所有对象共享，无论建立了多少个对象，都只有一个静态数据的拷贝。是在编译阶段就分配好了空间，对象还没有创建时，就已经分配空间。</li>
<li>类的静态成员访问<br>用 <code>::</code> 或者 <code>.</code></li>
<li>类的静态函数只能访问类中的静态变量，其他函数则都可访问</li>
<li>静态函数没有 <code>this</code> 指针，同时静态变量也有访问级别限制（公有，私有，保护）</li>
</ol>
<p><strong>类中的虚函数占用为一个指针的大小</strong></p>
<p><strong>类的成员函数，实际上相当于普通函数，只不过把类对象隐式的传递进去罢了</strong></p>
<p><strong>空类的大小为？</strong></p>
<p>c++要求每个实例在内存中都有独一无二的地址。空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元 "></a><a href="#context.9">友元</a><a name="section.9"> </a></h2><p><strong>友元提供了一种突破封装的方式。</strong>友元函数提供了一种在需要时访问类的私有成员的机制，但应该慎重使用，因为过多的友元函数可能破坏类的封装性。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数 "></a><a href="#context.10">友元函数</a><a name="section.10"> </a></h3><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但是需要在类的内部声明，声明时需要加friend关键字。</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元函数可以访问类的所有成员，但此函数不是类的成员函数</li>
<li>友元函数不能用 <code>const</code> 修饰</li>
<li>友元函数可以在类定义的任何地方申明，不受类访问限定符限制</li>
<li>一个函数可以是多个类的友元函数</li>
<li>友元函数调用和普通函数的调用原理相同</li>
</ol>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类 "></a><a href="#context.11">友元类</a><a name="section.11"> </a></h3><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元关系是单向的，不具有交换性<br>比如Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行</li>
<li>友元关系不能传递<br>如果B是A的友元，C是A的友元，则不能说明C是A的友元</li>
</ol>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载 "></a><a href="#context.12">重载</a><a name="section.12"> </a></h2><p>形式：</p>
<p><strong>[返回值] operator[运算符] (参数…) { … }；</strong></p>
<p><strong>不能重载的5种运算符：</strong></p>
<ol>
<li><code>.*</code><br>任意字符出现零次或多次</li>
<li><code>::</code><br>域作用符  </li>
<li><code>sizeof</code><br>关键字 - 大小</li>
<li><code>?:</code><br>三目运算符</li>
<li><code>.</code><br>点运算符</li>
</ol>
<p>例：重载类运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> _hour;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _sec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span> hour = <span class="number">0</span>, <span class="type">int</span> min = <span class="number">0</span>, <span class="type">int</span> sec = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_hour = hour;</span><br><span class="line">		_min = min;</span><br><span class="line">		_sec = sec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _sec &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为方便演示，让小时+1，但不再判断时间正确性</span></span><br><span class="line">	Time&amp; <span class="keyword">operator</span>++()<span class="comment">// ++A  不带参数为前置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);<span class="comment">//因为自增直接返回this用引用接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	Time <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//A++，参数写int或int i都可以   带参数为后置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Time <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;<span class="comment">//需要返回this自增之前的结果，所以用临时变量返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「就要 宅在家」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/weixin_61857742/article/details/126010673</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 友元函数重载流提取 &lt;&lt; / &gt;&gt;</span></span><br><span class="line"><span class="comment">// 对于流而言，因为是双目运算符，this指针本应该指向左边的类，但左操作数是一个流，又与this的类型冲突。</span></span><br><span class="line"><span class="comment">// 这时，就需要用到友元函数friend。友元函数本身是一个普通函数，但是作为类的友元，能够调用类内的成员，包括private。而且参数不用被类限制为第一个必须是this所指的对象本身。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class &#123;</span></span><br><span class="line"><span class="comment">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Time&amp; t);//友元函数，声明</span></span><br><span class="line"><span class="comment">	friend istream&amp; operator&gt;&gt;(istream&amp; in, Time&amp; t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="bitset（位库）"><a href="#bitset（位库）" class="headerlink" title="bitset（位库） "></a><a href="#context.13">bitset（位库）</a><a name="section.13"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span>  <span class="comment">///&lt; 所在头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">///&lt; 命名空间std</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 默认无参构造</span></span><br><span class="line">    <span class="comment">// 初始化全部位为0</span></span><br><span class="line">    std::bitset&lt;8&gt; bs;</span><br><span class="line">    <span class="comment">//bs[0] = 1;            // 0000 0001</span></span><br><span class="line">    <span class="comment">//bs[7] = 1;            // 1000 0000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传值构造方式</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">0x07</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 构造</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;00000111&quot;</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_ulong</span>();      <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.any()</td>
<td>是否存在值为1的二进制位</td>
</tr>
<tr>
<td>.none()</td>
<td>是否不存在值为1的二进制位<br/>或者说是否全部位为0</td>
</tr>
<tr>
<td>.size()</td>
<td>位长，也即是非模板参数值</td>
</tr>
<tr>
<td>.count()</td>
<td>值为1的个数</td>
</tr>
<tr>
<td>.test(pos)</td>
<td>测试pos处的二进制位是否为1<br/>与0做或运算</td>
</tr>
<tr>
<td>.set()</td>
<td>全部位置1</td>
</tr>
<tr>
<td>.set(pos)</td>
<td>pos位处的二进制位置1<br/>与1做或运算</td>
</tr>
<tr>
<td>.reset()</td>
<td>全部位置0</td>
</tr>
<tr>
<td>.reset(pos)</td>
<td>pos位处的二进制位置0<br/>与0做或运算</td>
</tr>
<tr>
<td>.flip()</td>
<td>全部位逐位取反</td>
</tr>
<tr>
<td>.flip(pos)</td>
<td>pos处的二进制位取反</td>
</tr>
<tr>
<td>.to_ulong()</td>
<td>将二进制转换为unsigned long输出</td>
</tr>
<tr>
<td>.to_string()</td>
<td>将二进制转换为字符串输出</td>
</tr>
<tr>
<td>~bs</td>
<td>按位取反<br/>效果等效为bs.flip()</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>将二进制位输出到os流<br/>小值在右，大值在左</td>
</tr>
</tbody></table>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL "></a><a href="#context.14">STL</a><a name="section.14"> </a></h2><p>STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是：</p>
<ol>
<li><p><strong>容器</strong></p>
<p>各种数据结构，如vector、list、deque、set、map等，⽤来存放数据，从实现角度来看，STL 容器是⼀种 <code>class template</code></p>
</li>
<li><p><strong>算法</strong></p>
<p>各种常⽤的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是⼀种 <code>function template</code></p>
</li>
<li><p><strong>迭代器</strong></p>
<p>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是⼀种将 operator* , operator-&gt; , operator++, operator– 等指针相关操作予以重载的 <code>class template</code>。  </p>
<p>所有STL容器都附带有⾃⼰专属的迭代器，只有容器的设计者才知道如何遍历⾃⼰的元素。  </p>
<p>原⽣指针(native pointer)也是⼀种迭代器。</p>
</li>
<li><p><strong>仿函数</strong></p>
<p>⾏为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是⼀种重载了operator() 的 class 或者 class template</p>
</li>
<li><p><strong>适配器（配接器）</strong></p>
<p>⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东西。  </p>
<p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应</p>
</li>
<li><p><strong>空间配置器</strong></p>
<p>负责空间的配置与管理。从实现角度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的 class template</p>
<p>⼀般的分配器的 std:alloctor 都含有两个函数 allocate 与 deallocte，这两个函数分别调⽤ operator new() 与 delete()，这两个函数的底层⼜分别是malloc() and free(); 但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p>
</li>
</ol>
<p><strong>容器之间的实现关系以及分类：</strong></p>
<p><img src="/C++.assets/image-20230615150413812-1692155829457.png" alt="image-20230615150413812"></p>
<p><strong>STL六⼤组件的交互关系：</strong></p>
<ol>
<li>容器通过空间配置器取得数据存储空间  </li>
<li>算法通过迭代器存储容器中的内容  </li>
<li>仿函数可以协助算法完成不同的策略的变化 </li>
<li>适配器可以修饰仿函数</li>
</ol>
<p><strong>STL的优点</strong></p>
<p>STL 具有⾼可重⽤性，⾼性能，⾼移植性，跨平台的优点</p>
<ol>
<li>⾼可重⽤性<br>STL 中几乎所有的代码都采⽤了模板类和模版函数的⽅式实现，这相⽐于传统的由函数和类组成的库来说提供了更好的代码重⽤机会</li>
<li>⾼性能<br>如 map 可以⾼效地从⼗万条记录⾥⾯查找出指定的记录，因为 map 是采⽤红黑树的变体实现的</li>
<li>⾼移植性<br>如在项⽬ A 上⽤ STL 编写的模块，可以直接移植到项⽬ B 上</li>
</ol>
<p><strong>STL 的⼀个重要特性是将数据和操作分离</strong></p>
<p>数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当 “粘合剂” 以使算法可以和容器交互运作</p>
<h2 id="unordered-set方法"><a href="#unordered-set方法" class="headerlink" title="unordered_set方法 "></a><a href="#context.15">unordered_set方法</a><a name="section.15"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 x 在 us 中， 返回1 否则0 </span></span><br><span class="line">us.<span class="built_in">count</span>(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="pair容器"><a href="#pair容器" class="headerlink" title="pair容器 "></a><a href="#context.16">pair容器</a><a name="section.16"> </a></h2><p>保存两个数据成员，⽤来⽣成特定类型的模板</p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line"><span class="comment">///&lt; 数据成员是public，两个成员分别是first和second</span></span><br></pre></td></tr></table></figure>



<h2 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器 "></a><a href="#context.17">vector 容器</a><a name="section.17"> </a></h2><p><strong>底层：</strong></p>
<p>Vector在堆中分配了⼀段连续的内存空间来存放元素</p>
<p>底层为动态数组</p>
<p>扩容：</p>
<ol>
<li>固定扩容</li>
<li>加倍扩容</li>
</ol>
<h2 id="list（链表）"><a href="#list（链表）" class="headerlink" title="list（链表） "></a><a href="#context.18">list（链表）</a><a name="section.18"> </a></h2><p><strong>中间位置的插入与删除是 O(1)</strong></p>
<p><strong>实现方式：</strong>双向链表</p>
<h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别 "></a><a href="#context.19">vector和list的区别</a><a name="section.19"> </a></h2><ol>
<li>vector 底层实现是数组；list 是双向链表 </li>
<li>vector 是顺序内存，⽀持随机访问，list 不⾏ </li>
<li>vector 在中间节点进⾏插⼊删除会导致内存拷⻉，list不会 </li>
<li>vector ⼀次性分配好内存，不够时才进⾏翻倍扩容；list 每次插⼊新节点都会进⾏内存申请 </li>
<li>vector 随机访问性能好，插⼊删除性能差；list 随机访问性能差，插⼊删除性能好</li>
</ol>
<h2 id="deque（双端数组）"><a href="#deque（双端数组）" class="headerlink" title="deque（双端数组） "></a><a href="#context.20">deque（双端数组）</a><a name="section.20"> </a></h2><ol>
<li>O(1)<br>首尾插入，删除，访问</li>
<li>O(n)<br>中间插入 insert()，erase()</li>
</ol>
<p><strong>在头&#x2F;尾部插入&#x2F;删除时间复杂度为 O(1)</strong></p>
<p><strong>致命缺陷：</strong>不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下</p>
<p>因此，需要线性结构时，大多数情况下优先考虑<code>vector</code>和<code>list</code>，<code>deque</code>的应用并不多，而目前能看到的一个应用就是，STL用其作为<code>stack</code>和<code>queue</code>的底层数据结构。</p>
<p>⽀持快速随机访问，由于 deque 需要处理内部跳转，因此速度上没有 vector 快</p>
<p>deque 是⼀个<strong>双端开口</strong>的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接</p>
<p><strong>注意：</strong></p>
<p>由于deque的迭代器⽐vector要复杂，这影响了各个运算层面，所以除⾮必要尽量使⽤ vector；<br>为了提⾼效率，在对deque进⾏排序操作的时候，我们可以先把 deque 复制到 vector 中再进⾏排序最后在复制回 deque</p>
<p><img src="/C++.assets/image-20230615153051799-1692155829457.png" alt="image-20230615153051799"></p>
<p>deque采⽤⼀块map作为主控，其中的每个元素都是指针，指向另⼀⽚连续线性空间，称之为 缓存区，这个区才是⽤来储存数据的</p>
<h2 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack &#x2F; queue "></a><a href="#context.21">stack &#x2F; queue</a><a name="section.21"> </a></h2><p>概述：栈与队列被称之为 deque 的配接器，其底层是以 deque 为底部架构。通过 deque 执⾏具体操作</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue "></a><a href="#context.22">priority_queue</a><a name="section.22"> </a></h2><pre><code>     优先队列是一种容器适配器，采用了堆这样的数据结构，保证了第一个元素总是整个优先队列中最大的(或最小的)元素。  优先队列默认使用vector作为底层存储数据的容器，在vector上使用了堆算法将vector中的元素构造成堆的结构，所以其实我们就可以把它当作堆，凡是需要用堆的位置，都可以考虑优先队列。
</code></pre>
<p>​		 默认情况下 <code>priority_queue</code> 是大堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="comment">///&lt; 优先队列底层使用的存储结构，可以看出来，默认采用vector</span></span><br><span class="line">          <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;  <span class="comment">///&lt; 定义优先队列中元素的比较方式的类，默认是按小于(less)的方式比较，</span></span><br><span class="line">                                                                <span class="comment">///&lt; 这种比较方式创建出来的就是大堆。所以优先队列默认就是大堆</span></span><br><span class="line">                                                                <span class="comment">///&lt; 如果需要创建小堆，就需要将less改为greater</span></span><br><span class="line">          &gt; <span class="keyword">class</span> priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载比较函数 Compare */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 重载 ()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;  <span class="comment">///&lt; 此处与快排的排序相反， &gt; 表从小到大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(&amp;Cmp)&gt; <span class="built_in">pq</span>(Cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 3: class / struct</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：priority_queue 无迭代器！！</strong></p>
<ol>
<li>push() &#x2F; emplace()<br>O(log N)，push(x) 令x入队，其中 N 为当前优先队列中元素的个数</li>
<li>top()<br>O(1)，获得队首元素(即堆顶元素)</li>
<li>pop()<br>O(log N)，令队首元素(即堆顶元素)出队</li>
<li>empty()<br>O(1)，检测优先队列是否为空，返回 true则空，返回false 则非空</li>
<li>size()<br>O(1)，返回优先队列内元素的个数</li>
</ol>
<p><strong>emplace()与push()的区别</strong></p>
<p>当我们使用push()时，会创建一个对象，然后将其插入优先级队列。而使用emplace()，该对象将原地构造，节省了不必要的副本</p>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map &#x2F; set "></a><a href="#context.23">map &#x2F; set</a><a name="section.23"> </a></h2><p>有序（从小到大），底层为<strong>红黑树</strong></p>
<p><strong>共同点：</strong>都是C++的关联容器，只是通过它提供的接口对里面的元素进行访问，底层都是采⽤红黑树实现</p>
<p><strong>不同点：</strong></p>
<p>set：⽤来判断某⼀个元素是不是在⼀个组里面。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典</p>
<p><strong>优点：</strong></p>
<p>查找某⼀个数的时间为 <code>O(logn)</code>；遍历时采⽤ iterator，效果不错</p>
<p><strong>缺点：</strong></p>
<p>每次插⼊值的时候，都需要调整红黑树，效率有⼀定影响</p>
<p><strong>重载 &lt; 排序方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age):<span class="built_in">name_</span>(name),<span class="built_in">age_</span>(age)&#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Student &amp;s) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(name_ != s.name_)&#123;</span><br><span class="line">            <span class="keyword">return</span> name_ &lt; s.name_;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age_ &lt; s.age_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::string <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name_ + <span class="string">&quot;, age:&quot;</span> + std::<span class="built_in">to_string</span>(age_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    set&lt;Student&gt; s;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;Danney&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        cout &lt;&lt; it.<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小梦_人生如戏」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/yu532164710/article/details/105194036</span></span><br></pre></td></tr></table></figure>



<p><strong>细节：</strong></p>
<ol>
<li><strong>为什么要成倍的扩容而不是⼀次增加⼀个固定⼤⼩的容量呢？</strong><br>采⽤成倍⽅式扩容，可以保证常数的时间复杂度，⽽增加指定⼤⼩的容量只能达到O(n)的时间复杂度</li>
<li><strong>为什么是以两倍的⽅式扩容而不是三倍四倍，或者其他⽅式呢？</strong><br>考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是 1.5 或 2；GCC 是 2；VS 是 1.5，k &#x3D; 2 每次扩展的新尺寸必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤ 1.5 倍的增⻓⽅式可以更好的实现对内存的重复利用</li>
</ol>
<p><strong>注：C++并没有规定扩容因子K，这是由标准库的实现者决定的</strong></p>
<h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map &#x2F; unordered_map "></a><a href="#context.24">map &#x2F; unordered_map</a><a name="section.24"> </a></h2><p>map中元素是⼀些 <code>key-value</code> 对，关键字起索引作⽤，值表示和索引相关的数据</p>
<p><strong>底层实现：</strong></p>
<p><code>map</code> 底层是基于<strong>红黑树</strong>实现的，因此map内部元素排列是有序的<br><code>unordered_map</code> 底层则是基于<strong>哈希表</strong>实现的，因此其元素的排列顺序是杂乱⽆序的</p>
<table>
<thead>
<tr>
<th></th>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>有序性，这是map结构最⼤的优点，<br />其元素的有序性在很多应⽤中都会简化很多的操作<br />map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为 O(logn)</td>
<td>查找、删除、添加的速度快，时间复杂度为常数级O(1）</td>
</tr>
<tr>
<td>缺点</td>
<td>查找、删除、增加等操作平均时间复杂度较慢，与 n 相关</td>
<td>因为unordered_map内部基于哈希表，<br />以（key,value）对的形式存储，因此空间占⽤率⾼<br />unordered_map的查找、删除、添加的时间复杂度不稳定<br />平均为O(1)，取决于哈希函数，极端情况下可能为O(n)</td>
</tr>
</tbody></table>
<p><strong>问题：</strong></p>
<ol>
<li><strong>为什么 <code>insert</code> 之后，以前保存的 <code>iterator</code> 不会失效？</strong><br><strong>答：</strong> 因为 map 和 set 存储的是结点，不需要内存拷⻉和内存移动。但是像 vector 在插入数据时如果内存不够会重新开辟一块内存。 map 和 set 的 iterator 指向的是节点的指针，vector 指向的是内存的某个位置</li>
<li><strong>为何 map 和 set 的插入删除效率比其他序列容器高？</strong><br><strong>答：</strong> 因为 map 和 set 底部使用红黑树实现，插入和删除的时间复杂度是 <code>O(logn)</code>，而像 vector 这样的序列容器插入和删除的时间复杂度是 <code>O(N)</code></li>
</ol>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap "></a><a href="#context.25">multimap</a><a name="section.25"> </a></h2><p>multimap是C++ STL中的一个关联容器，它与map类似，但可以存储多个具有相同键值的元素。</p>
<p>multimap使用红黑树实现，因此它的插入、查找、删除操作的时间复杂度为O(log n)，其中n为multimap中元素的数量。由于multimap允许重复的键值，因此对于某些操作，如查找、删除等，复杂度可能会更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.构造函数</span></span><br><span class="line"><span class="built_in">multimap</span>();                             <span class="comment">///&lt; 创建一个空的multimap。</span></span><br><span class="line"><span class="built_in">multimap</span>(InputIt first, InputIt last);  <span class="comment">///&lt; 创建一个包含[first, last)区间内所有元素的新multimap，要求这些元素必须支持拷贝构造函数。</span></span><br><span class="line"><span class="built_in">multimap</span>(<span class="type">const</span> multimap&amp; other);        <span class="comment">///&lt; 拷贝构造函数，创建一个新的multimap，它与另一个multimap中的元素相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.迭代器</span></span><br><span class="line"><span class="built_in">begin</span>();   <span class="comment">///&lt; 返回指向multimap第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>();     <span class="comment">///&lt; 返回指向multimap最后一个元素之后位置的迭代器。</span></span><br><span class="line"><span class="built_in">rbegin</span>();  <span class="comment">///&lt; 返回指向multimap最后一个元素的反向迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>();    <span class="comment">///&lt; 返回指向multimap第一个元素之前位置的反向迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.容量</span></span><br><span class="line"><span class="built_in">empty</span>();     <span class="comment">///&lt; 如果multimap为空，则返回true，否则返回false。</span></span><br><span class="line"><span class="built_in">size</span>();      <span class="comment">///&lt; 返回multimap中元素的数量。</span></span><br><span class="line"><span class="built_in">max_size</span>();  <span class="comment">///&lt; 返回multimap可以包含的最大元素数量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.插入与删除</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; val);                     <span class="comment">///&lt; 将val插入到multimap中。如果multimap中已经存在一个键值与val相等的元素，</span></span><br><span class="line">                                                   <span class="comment">///&lt; 则新的val将会被插入到该键值所对应的元素序列的尾部。</span></span><br><span class="line"><span class="built_in">insert</span>(InputIt first, InputIt last);               <span class="comment">///&lt; 将[first, last)区间内的所有元素插入到multimap中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* m.emplace(key, value) */</span></span><br><span class="line"><span class="built_in">emplace</span>(key, value);                               <span class="comment">///&lt; 在当前multimap容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key);                        <span class="comment">///&lt; 删除multimap中所有键值为key的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator position);                    <span class="comment">///&lt; 删除迭代器position所指向的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator first, const_iterator last);  <span class="comment">///&lt; 删除[first, last)区间内的所有元素。</span></span><br><span class="line"><span class="built_in">clear</span>();                                           <span class="comment">///&lt; 清空multimap中的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.查找</span></span><br><span class="line"><span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key);        <span class="comment">///&lt; 返回multimap中键值为key的元素数量。</span></span><br><span class="line"><span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key);         <span class="comment">///&lt; 查找并返回multimap中第一个键值为key的元素的迭代器。如果找不到，则返回end()。</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; key);  <span class="comment">///&lt; 返回一个pair，包含两个迭代器，第一个迭代器指向multimap中第一个键值为key的元素，</span></span><br><span class="line">                                   <span class="comment">///&lt; 第二个迭代器指向multimap中第一个键值大于key的元素。如果找不到任何元素，则两个迭代器都等于end()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 除了以上方法，multimap还继承了map类的其他方法，如key_comp()、value_comp()等。 **********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义排序 demo */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，对键进行降序排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string, Compare&gt; myMultimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 insert() 函数插入键值对</span></span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">3</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : myMultimap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key = &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, Value = &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-模板全特化和偏特化"><a href="#C-模板全特化和偏特化" class="headerlink" title="C++模板全特化和偏特化 "></a><a href="#context.26">C++模板全特化和偏特化</a><a name="section.26"> </a></h2><p><strong>模板分为：</strong>1. 类模板  2. 函数模板</p>
<p><strong>特化分为：</strong>1. 特例化（全特化）  2. 部分特例化（偏特化）</p>
<p>对模板特例化是因为对特定类型，可以利⽤某些特定知识来提⾼效率，⽽不是使⽤通⽤模板</p>
<p><strong>对函数模板：</strong></p>
<ol>
<li>模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本</li>
<li>⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化</li>
</ol>
<p><strong>模板函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;模板函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span> , <span class="type">char</span> &gt;(<span class="type">int</span> a, <span class="type">char</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///&lt; 函数模板，只有全特化，偏特化的功能可以通过函数的重载完成</span></span><br></pre></td></tr></table></figure>



<p><strong>对类模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span> , <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i, <span class="type">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">char</span>, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">char</span> i, T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类&gt;偏特化类&gt;主版本模板类</span></span><br></pre></td></tr></table></figure>





<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式 "></a><a href="#context.27">lambda表达式</a><a name="section.27"> </a></h2><p>lambda表达式<strong>表示⼀个可调⽤的代码单元</strong>，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤它，不需要其他地⽅调⽤它</p>
<p>表达式语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; [捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span></span><br><span class="line"><span class="comment">///&lt; 只有 [capture list] 捕获列表和 &#123; function body &#125; 函数体是必选的</span></span><br><span class="line"><span class="comment">///&lt; 其中 -&gt; return type 可省略，单行函数自动判断返回类型</span></span><br><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;function body &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 例：</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [&amp;count](<span class="type">int</span> x) &#123;</span><br><span class="line">    count += x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; count == 0;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">///&lt; count == 1;</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>不捕获任何变量，这种情况下 <code>lambda</code> 表达式内部不能访问外部的变量</td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>以引用方式捕获所有变量（保证 <code>lambda</code> 执行时变量存在）</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>用值的方式捕获所有变量（创建时拷贝，修改对 <code>lambda</code> 内对象无影响）</td>
</tr>
<tr>
<td><code>[=, &amp;foo]</code></td>
<td>以引用捕获变量 <code>foo</code>，但其余变量都靠值捕获</td>
</tr>
<tr>
<td><code>[&amp;, foo]</code></td>
<td>以值捕获 <code>foo</code> ，但其余变量都靠引用捕获</td>
</tr>
<tr>
<td><code>[bar]</code></td>
<td>以值方式捕获 <code>bar</code>，不捕获其他变量</td>
</tr>
<tr>
<td><code>[this]</code></td>
<td>捕获所在类的 <code>this</code> 指针</td>
</tr>
</tbody></table>
<p><strong>lambda最大的⼀个优势是在使⽤STL中的算法(algorithms)库</strong></p>
<p>如数组排序：</p>
<p><img src="/C++.assets/image-20230616102708669-1692155829457.png" alt="image-20230616102708669"></p>
<p>set&lt;&gt;</p>
<p>deque</p>
<p>vector&lt;&gt;</p>
<p>map&lt;&gt;</p>
<p>list&lt;&gt;</p>
<p>stack&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 小端模式，高位存内存高地址，地位存低</span><br><span class="line">浮点数最好用double类型(默认)而不是float</span><br><span class="line"></span><br><span class="line">const int c = 12;			# 同c的 #define，声明常量，c++中应使用const</span><br><span class="line"></span><br><span class="line">int xxx[3] = &#123; 20, 1, 16 &#125;		# 花括号直接给数组赋值</span><br><span class="line"></span><br><span class="line">sizeof xx				# 显示xx变量长度字节，（int）加括号为类型</span><br><span class="line"># char为1bytes</span><br><span class="line"># 整形: char (1), short (2), int (4), long (4), long long (8)</span><br><span class="line"># 浮点型: float (4), double (8), long double (80,96,128位&lt;16字节&gt;  /8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示个数则  xx/xx[0]</span><br><span class="line"># 数组默认表示地址，不能像python一样直接打印数组</span><br><span class="line"></span><br><span class="line">strlen()		# 显示字符串长度，需要include cstring</span><br><span class="line">		# 同python的len()，只针对字符串</span><br><span class="line">.size()		# 同上，需要include string</span><br><span class="line"></span><br><span class="line">--&gt; 字符串以空字符结尾 &#x27;\0&#x27;</span><br><span class="line">--&gt; 字符数组相反</span><br><span class="line">char fish[] = &quot;Bubbles&quot;;		</span><br><span class="line"># 字符串常量直接用双引号，末尾会自动加\0，且表地址</span><br><span class="line"># 字符常量用单引号，如：&#x27;s&#x27; , 且与字符串常量不能互换</span><br><span class="line"></span><br><span class="line">面向行的输入：getline(1, 2)</span><br><span class="line"># 不保存换行符！</span><br><span class="line"># 1.用来存储的数组名称 2.读取的字符数(需要-1)</span><br><span class="line"># 例：getline(name, 20)  读19个存到name</span><br><span class="line"></span><br><span class="line">面向行的输入：get(1, 2)		# 保留回车</span><br><span class="line"># 可用get()来读取一个字符（包括回车）</span><br><span class="line"># 可用 cin.get(name, 10).get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string类</span><br><span class="line"># 可以赋值给变量</span><br><span class="line"></span><br><span class="line">struct	结构体 --&gt; c需要关键字struct xx  ， c++ 不需要struct</span><br><span class="line"># 注意结构体赋值是加花括号 &#123; &#125;</span><br><span class="line"></span><br><span class="line">union	共用体 --&gt; 只能存int,lomg,double</span><br><span class="line"></span><br><span class="line">enum xxx &#123;a, b, c&#125;		# 此时xxx为枚举</span><br><span class="line"># xxx ban			# 定义ban为枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针 "></a><a href="#context.28">智能指针</a><a name="section.28"> </a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.29">定义</a><a name="section.29"> </a></h3><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;TC&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> TC())</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TC *tc = ptr.<span class="built_in">get</span>();  <span class="comment">///&lt; 获取原指针</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>();  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="shared-ptr（常用）"><a href="#shared-ptr（常用）" class="headerlink" title="shared_ptr（常用） "></a><a href="#context.30">shared_ptr（常用）</a><a name="section.30"> </a></h3><p>采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p>
<p><strong>注：</strong></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr "></a><a href="#context.31">unique_ptr</a><a name="section.31"> </a></h3><p>unique_ptr采用的是独享资源所有权，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr "></a><a href="#context.32">weak_ptr</a><a name="section.32"> </a></h3><p>弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr "></a><a href="#context.33">auto_ptr</a><a name="section.33"> </a></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。</p>
<p><code>auto_ptr</code> 是一个失败设计，很多公司明确要求不能使用 <code>auto_ptr</code></p>
<h2 id="function"><a href="#function" class="headerlink" title="function "></a><a href="#context.34">function</a><a name="section.34"> </a></h2><p>类似c的函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;<span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();<span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;;<span class="comment">//lambda表达式</span></span><br></pre></td></tr></table></figure>







<h2 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype &#x2F; auto "></a><a href="#context.35">decltype &#x2F; auto</a><a name="section.35"> </a></h2><p><strong>decltype 作用：</strong>用来<strong>推导表达式类型</strong>的关键字，用来在编译时期进行自动类型推导</p>
<p>与 <code>auto</code> 的区别：</p>
<p>auto 根据 &#x3D; 右边的初始值推导出变量的类型，decltype 根据 exp 表达式推导出变量的类型，跟 &#x3D; 右边的 value 没有关系；<br>auto 要求变量必须初始化，因为 auto 是根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导；<br>而 decltype 不要求，可不用赋值</p>
<p><strong>decltype  的几种形式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;            <span class="comment">// y -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">0</span>;        <span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// *p -&gt; const int, p -&gt; const int*</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *m = &amp;z;          <span class="comment">// *m -&gt; int, m -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(m)* n = &amp;m;          <span class="comment">// *n -&gt; int*, n -&gt; int**</span></span><br></pre></td></tr></table></figure>



<p><strong>推导规则</strong></p>
<ol>
<li><p>如果 <code>exp</code> 是一个不被括号<code>()</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，<code>decltype(exp)</code> 的类型和 <code>exp</code> 一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> A::total = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">decltype</span>(n) x = n;           <span class="comment">// n 为 int，x 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(r) y = n;           <span class="comment">// r 为 const int &amp;，y 被推导为 const int &amp;</span></span><br><span class="line">	<span class="keyword">decltype</span>(A::total)  z = <span class="number">0</span>;   <span class="comment">// total 是类 A 的一个 int 类型的成员变量，z 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(A.name) url = <span class="string">&quot;www.baidu.com&quot;</span>; <span class="comment">// url 为 string 类型</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是函数调用，则 <code>decltype(exp)</code> 的类型就和函数返回值的类型一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;   <span class="comment">// 函数返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;       <span class="comment">// 函数返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">double</span>)</span></span>;       <span class="comment">// 函数返回值为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func4</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">// 函数返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func5</span><span class="params">(<span class="type">void</span>)</span></span>;          <span class="comment">// 函数返回值为 const int&amp;&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func1</span>(<span class="number">100</span>,<span class="string">&#x27;A&#x27;</span>)) a = n; <span class="comment">// a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func2</span>()) b = <span class="number">0</span>;        <span class="comment">// b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func3</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;    <span class="comment">// c 的类型为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func4</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) x = n;    <span class="comment">// x 的类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func5</span>()) y = <span class="number">0</span>;         <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是一个左值，或被括号<code>()</code>包围，<code>decltype(exp)</code> 的类型就是 <code>exp</code> 的引用，假设 <code>exp</code> 的类型为 <code>T</code>，则 <code>decltype(exp)</code> 的类型为 <code>T&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> A obj;</span><br><span class="line">	<span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;   <span class="comment">// a 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>((obj.x)) b = a; <span class="comment">// b 的类型为 int&amp;</span></span><br><span class="line">	 </span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(m + n) c = <span class="number">0</span>;     <span class="comment">// n + m 得到一个右值，c 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(n = n + m) d = c; <span class="comment">// n = n + m 得到一个左值，d 的类型为 int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左值：表达式执行结束后依然存在的数据，即持久性数据；右值是指那些在表达式执行结束不再存在的数据，即临时性数据。一个区分的简单方法是：对表达式取地址，如果编译器不报错就是左值，否则为右值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>类的静态成员可以使用 <code>auto</code>， 对于类的非静态成员无法使用 <code>auto</code>，如果想推导类的非静态成员的类型，只能使用 <code>decltype</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">   <span class="keyword">decltype</span>(T.<span class="built_in">begin</span>()) m_it;</span><br><span class="line">   <span class="comment">// typename T::iterator m_it;   // 这种用法会出错</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	   m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	A&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">	obj.<span class="built_in">func</span>(v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2023/07/27/C/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">快速判断是否是字母</a><a name="context.1"> </a></li>
<li><a href="#section.2">快速判断两字符是否相同且为字母</a><a name="context.2"> </a></li>
<li><a href="#section.3">C 关键字</a><a name="context.3"> </a><ul>
<li><a href="#section.4">free&#x2F;malloc</a><a name="context.4"> </a></li>
<li><a href="#section.5">float&#x2F;double</a><a name="context.5"> </a></li>
<li><a href="#section.6">union&#x2F;volatile</a><a name="context.6"> </a></li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<p><strong>c语言宏 <code>__stdcall</code>, <code>__cdecl</code></strong></p>
<p>​		调用函数时，计算机常用栈来存放函数执行需要的参数，由于栈的空间大小是有限的，在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示overflow。</p>
<p>​		在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的！</p>
<p>​		VC中默认调用是 <code>__cdecl</code> 方式，Windows API 使用 <code>__stdcall</code> 调用方式，在 DLL 导出函数中，为了跟 Windows API 保持一致，建议使用 <code>__stdcall</code> 方式。</p>
<p>C&#x2F;C++ 函数调用约定，主要是对以下两个方面进行了约定：</p>
<ol>
<li>当参数个数多于一个时，按照什么顺序把参数压入堆栈。—-调用函数时，参数的入栈顺序。</li>
<li>函数调用后，由谁来把堆栈恢复原状。—-调用结束后，由谁（调用者还是被调用者）负责将参数出栈。</li>
</ol>
<p>在高级语言中，就是通过函数的调用方式来说明这两个问题的。常见的调用方式有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C 语言:   __cdecl、__stdcall、__fastcall、naked、__pascal。</span><br><span class="line">C++ 语言: __cdecl、__stdcall、__fastcall、naked、__pascal、__thiscall，比 C 语言多出一种 __thiscall 调用方式。</span><br></pre></td></tr></table></figure>



<ol>
<li><p>stdcall<br><code>__stdcall</code> 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C&#x2F;C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。<br>其声明语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int _stdcall function(int a, int b);</span><br></pre></td></tr></table></figure>

<p>stdcall的调用方式意味着：</p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由被调用函数自己来恢复堆栈，称为自动清栈。<br>（3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。</p>
</li>
<li><p>cdecl</p>
<p><code>__cdecl</code> 是C Declaration的缩写（declaration，声明），cdecl调用方式又称为C调用方式，是C语言缺省的调用方式。<br>其声明语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int function(int a, int b);        // 不加修饰符就是C调用方式</span><br><span class="line">int _cdecl function(int a, int b); // 明确指定用C调用方式</span><br></pre></td></tr></table></figure>

<p>cdecl的调用方式意味着：</p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由调用者恢复堆栈，称为手动清栈。<br>（3）函数名自动加前导下划线。</p>
<p>由于是由调用者来恢复堆栈，因此C调用方式允许函数的参数个数是不固定的，这是C语言的一大特色。比如 <code>printf</code></p>
</li>
</ol>
<h2 id="快速判断是否是字母"><a href="#快速判断是否是字母" class="headerlink" title="快速判断是否是字母 "></a><a href="#context.1">快速判断是否是字母</a><a name="section.1"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 包括大小写字母</span><br><span class="line">(uchar)((ch | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<h2 id="快速判断两字符是否相同且为字母"><a href="#快速判断两字符是否相同且为字母" class="headerlink" title="快速判断两字符是否相同且为字母 "></a><a href="#context.2">快速判断两字符是否相同且为字母</a><a name="section.2"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((ch = ch1 ^ ch2) == <span class="number">0</span>) || (ch == <span class="number">0x20</span>) &amp;&amp; ((<span class="type">unsigned</span>)(ch1 | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<p>bit -&gt; Byte -&gt; kb	1Byte &#x3D; 8bit</p>
<p>bit比特位	byte字节	且内存中一个空间占一个字节&#x3D;8位</p>
<p><strong>负数在内存中存储的是补码，求原码-1然后除符号位其余取反</strong></p>
<p><strong>且任何数字在内存中都是以补码存储的，正数原反补都一样</strong></p>
<h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C 关键字 "></a><a href="#context.3">C 关键字</a><a name="section.3"> </a></h2><table>
<thead>
<tr>
<th><strong>auto</strong></th>
<th><strong>break</strong></th>
<th><strong>case</strong></th>
<th><strong>char</strong></th>
<th><strong>const</strong></th>
<th><strong>continue</strong></th>
<th><strong>default</strong></th>
<th><strong>do</strong></th>
<th><strong>double</strong></th>
<th><strong>else</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>enum</strong></td>
<td><strong>extern</strong></td>
<td><strong>float</strong></td>
<td><strong>for</strong></td>
<td><strong>goto</strong></td>
<td><strong>if</strong></td>
<td><strong>int</strong></td>
<td><strong>long</strong></td>
<td><strong>register</strong></td>
<td><strong>return</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>signed</strong></td>
<td><strong>sizeof</strong></td>
<td><strong>static</strong></td>
<td><strong>struct</strong></td>
<td><strong>switch</strong></td>
<td><strong>typedef</strong></td>
<td><strong>union</strong></td>
<td><strong>unsigned</strong></td>
<td><strong>void</strong></td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td><strong>while</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>typedef</strong> unsigned int uint		把unsigned int重定义为unit</p>
<p><strong>void</strong>							声明函数无返回值或无参数</p>
<p><strong>auto</strong>							在局部中自动销毁原变量值</p>
<p><strong>static</strong> 						静态局部变量，不会销毁，保存赋值</p>
<p><strong>const</strong> <strong>x</strong>						定义常量x，不可改变</p>
<p><strong>extern</strong>						声明外部-变量&#x2F;函数</p>
<p><strong>#define</strong> a 100					定义常量和宏，可以是三目运算符</p>
<table>
<thead>
<tr>
<th>Char</th>
<th>Short</th>
<th>Int</th>
<th>long</th>
<th>long long</th>
<th>folat</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>短整型</td>
<td>整型</td>
<td>长整型</td>
<td>超长整型</td>
<td>浮点型</td>
<td>双精度浮点型</td>
</tr>
<tr>
<td>1字节</td>
<td>2字节&#x2F;16位</td>
<td>4字节&#x2F;32位</td>
<td>4字节</td>
<td></td>
<td>4&#x2F;8字节</td>
<td>64位保留后6位</td>
</tr>
</tbody></table>
<p>a&lt;&lt;2			a左移2位</p>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>|</th>
<th>^</th>
<th>!</th>
<th>~</th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td>按位或</td>
<td>异或</td>
<td>非</td>
<td>按位取反</td>
</tr>
<tr>
<td>a&amp;&amp;b（逻辑与）</td>
<td>||</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a, b均为真返回真</td>
<td>逻辑或,有一个返回真</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>%c			打印一个字符串格式的数据</p>
<p>%s			打印字符串</p>
<p>%d			整型十进制数据</p>
<p>%u			无符号的十进制整数</p>
<p>%f			浮点型</p>
<p>%g			浮点，不显示无意义的0</p>
<p>%lf			双精度浮点型</p>
<p>%p			指针，以地址的形式打印</p>
<p>%x			打印十六进制</p>
<p>%o			输出八进制数</p>
<p>%%			‘%’</p>
<p>float</p>
<p>(-1)^s * M * 2^E		s&#x3D;0&#x2F;1	E&#x3D;n(8位,得加127)		M&#x3D;1.?? (23位1.省略)	</p>
<p>​					S	E(8&#x2F;11bit)	M(23&#x2F;52bit)</p>
<p>double				同上，E(加减1023)</p>
<p>整型转换(小转整int)</p>
<p>算数转换(小转大)</p>
<p>​	long double</p>
<p>double</p>
<p>​	float</p>
<p>​	unsigned long int</p>
<p>​	long int</p>
<p>​	unsigned int</p>
<p>​	int</p>
<p>&gt;&gt;			右移（除2），补符号位			左移补0,其他同</p>
<p>exp ? a : b	exp为真则返回a，否则返回b</p>
<p>do{循环语句}</p>
<p>while(判断);</p>
<p>b &#x3D; a++		后置++表示先把a给b，a自己在++</p>
<p>​			前置相反</p>
<p><strong>函数</strong><strong>:</strong></p>
<p>​	声明放到.h中，int Add(int x, int y);	定义放到.c中</p>
<p>​	.h中 à		#ifndef <strong>ADD_H</strong>		&#x2F;&#x2F;if not def 判断是否引用过ADD_H</p>
<p>​				#define <strong>ADD_H</strong>		&#x2F;&#x2F;未引用为真，则往下运行</p>
<p>​				&#x2F;&#x2F;函数声明</p>
<p>​				int Add(int x, int y);</p>
<p>#endif					&#x2F;&#x2F;到endif结束</p>
<p>scanf(“%d”, &amp;n)		获得输入给n</p>
<p>printf(“%d”, n)			打印n</p>
<p>sizeof(char)			看char的长度，单位：byte字节</p>
<p>​					sizeof(数组名) &#x2F; &amp;数组名à表整个数组，其余均表地址</p>
<p>qsort()</p>
<p>strcat(1,2)			把字符串2加到1后面</p>
<p>assert(?)				<strong>断言</strong>，如果?为假则报错，否则继续运行</p>
<p>strcmp(1,2)			逐个比较字符串大小(ASCII)，1&gt;2返回正数，1&#x3D;2返回0，同</p>
<p>strncmp()				同上，比较前n位</p>
<p>strtok(arr,p)			arr,p为指针，在arr中按p切割</p>
<p>定义常量</p>
<p>const int n &#x3D; 4			定义常变量，不能改变</p>
<p>#define n 10			define定义的标识符常量</p>
<p>enum n				枚举常量</p>
<p>{a, b, c}			abc分别对应012</p>
<p>转义符：</p>
<p>\0		在字符串里表到这结束</p>
<p>​	\ddd		ddd表示1-3个八进制的数字，如：\130 表X</p>
<p>​	\xdd		dd表2个十六进制数字，\x30 表0</p>
<table>
<thead>
<tr>
<th>C</th>
<th></th>
<th></th>
<th></th>
<th>Python</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>scanf(“%d”, &amp;a)</td>
<td></td>
<td></td>
<td>输入</td>
<td>input()</td>
<td></td>
</tr>
<tr>
<td>getchar()</td>
<td>获得输入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数组数组名为地址</td>
<td>char arr[] &#x3D; {‘x1’, ‘’…, 0}</td>
<td>0必加</td>
<td></td>
<td>列表</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>char arr[ ][n]</td>
<td>列不可省略</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>字符串长度</td>
<td>strlen()</td>
<td></td>
<td></td>
<td>字符串长度</td>
<td>len(x)</td>
<td></td>
</tr>
<tr>
<td>if ()</td>
<td></td>
<td></td>
<td></td>
<td>if …:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>需要定义变量</td>
<td></td>
<td></td>
<td></td>
<td>不需要定义变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数</td>
<td>int Function(x ,y) {}</td>
<td></td>
<td></td>
<td></td>
<td>def function: {}</td>
<td></td>
</tr>
<tr>
<td>结构体</td>
<td>struct Name{}</td>
<td></td>
<td></td>
<td>类</td>
<td>Class</td>
<td></td>
</tr>
<tr>
<td>字符串</td>
<td>不能直接给变量得用数组</td>
<td>strcpy()</td>
<td></td>
<td>字符串</td>
<td>能直接给变量</td>
<td></td>
</tr>
<tr>
<td>转换类型</td>
<td>(int)3.14</td>
<td>3.14-&gt;3</td>
<td></td>
<td>转换类型</td>
<td>int(3.14)</td>
<td></td>
</tr>
</tbody></table>
<p>switch(x)</p>
<p>{</p>
<p>​	case 1: …; break;			加break表执行完退出switch，</p>
<p>​	case 2: …;					无break表执行完后继续往下执行</p>
<p>​	case n: …;</p>
<p>​	default: …; break;			表默认情况执行default的语句</p>
<p>}</p>
<p><strong>指针</strong>		</p>
<p>数组默认传的是指针，如int arr[]; Function(arr)ßarr为指针，是arr[0]的地址</p>
<p>&amp;a&#x3D;0		取a的地址</p>
<p>int* b &#x3D; &amp;a	b为<strong>指针</strong>变量，存a的地址**,** 32位平台是4个字节，64位平台是8个字节</p>
<p>int<em>*c&#x3D;&amp;*b	int**表c指向int</em></p>
<p>*b &#x3D; 20		*为<strong>解引用操作符</strong>，把20存放进b的地址中</p>
<p>arr				首元素地址</p>
<p>&amp;arr[0]			首元素的地址</p>
<p>&amp;arr				数组的地址</p>
<p>int (*p)[10]&#x3D;&amp;a	数组指针			à去掉名字就是类型</p>
<p>int (*p)(int int)&#x3D;Add	函数指针</p>
<p><strong>结构体</strong></p>
<p>(typedef)struct Book		&#x2F;&#x2F;加typedef则下面a为类型，如a s,定义了s结构体</p>
<p>{</p>
<p>​	char name[20];</p>
<p>​	short price;</p>
<p>}à(a)s1,s2;		&#x2F;&#x2F;s1,s2为同Book的全局变量(python的class)</p>
<p>struct Book n1 &#x3D; {“xxx”, 55};</p>
<p>struct Book* pc &#x3D; &amp;n1			&#x2F;&#x2F;定义指针为pc，存结构体n1</p>
<p>printf(“%s”, pc-&gt;name)			&#x2F;&#x2F;打印name，-&gt;表指向，即取该地址的name</p>
<p>srtcpy(n1.name, “new”)			&#x2F;&#x2F;想改name用字符串拷贝，把new给name</p>
<p><strong>结构体内存对齐</strong></p>
<p>​		对齐到本身对齐数整数倍的地址处（参考上一个）</p>
<p>总大小为最大对齐数的整数倍</p>
<p>（嵌套结构体，按最大的字节算）</p>
<p># 数组随下表增长，地址从低到高变化</p>
<p># 栈区地址从高到低存</p>
<p>栈区à		局部变量</p>
<p>​			函数的形式参数</p>
<p>​			函数调用也开辟空间</p>
<p>堆区à		动态内存分配</p>
<p>​			Malloc&#x2F;free</p>
<p>​			Realloc</p>
<p>​			calloc</p>
<p>静态区à		全局变量</p>
<p>​			静态变量	static</p>
<p><strong>枚举</strong></p>
<p><strong>enum Color</strong></p>
<p><strong>{</strong></p>
<p>​	<strong>RED,</strong>		&#x2F;&#x2F;序号为0，也可以赋值</p>
<p>​	<strong>…</strong></p>
<p><strong>}</strong></p>
<p><strong>数据内存存储模式（</strong>以字节为单位<strong>）</strong></p>
<p>1.小端		数据低位存内存低位		内存地址：低à高（左低右高）</p>
<p>2.大端		数据低位存内存高位		数据：高à低（左高右低）如二进制数</p>
<p><em>*<em>划重点！！*<strong><strong>à</strong>	<strong>Keil，C51为大端</strong>		<strong>X86为小端</strong></strong>，很多</em>*</em><em>ARM,DSP也为小端，有些ARM可选</em>*</p>
<p><strong>C语言</strong> à 编译    +    连接</p>
<p>​	编译生成目标文件		目标文件经过链接器，链接库处理，生成可执行文件</p>
<p>汇编 à 二进制</p>
<p><strong>预处理符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__FILE__				返回文件名+路径</span><br><span class="line"></span><br><span class="line">__LINE__				返回所在行数</span><br><span class="line"></span><br><span class="line">__DATE__			返回当今日期</span><br><span class="line"></span><br><span class="line">__TIME__			返回当前时间</span><br></pre></td></tr></table></figure>

<p><strong>文件处理</strong></p>
<p>FILE* pf &#x3D; fopen(“log.txt”, “w”)			以只读打开&#x2F;创建文件</p>
<p>fprintf(pf, “file:%s	line:%d	date:%s	time:%s	i&#x3D;%d\n”,</p>
<p><strong>FILE</strong>, <strong>LINE</strong>, <strong>DATE</strong>, <strong>TIME</strong>, i)			以格式化写文件</p>
<p>fclose(pf)				关闭文件</p>
<p>pf &#x3D; NULL				指针清空</p>
<p><strong>运算效率</strong></p>
<p>移位 &gt; 赋值 &gt; 大小比较 &gt; 加法 &gt; 减法 &gt; 乘法 &gt; 取模 &gt; 除法</p>
<p><strong>回调函数详述</strong></p>
<p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="free-malloc"><a href="#free-malloc" class="headerlink" title="free&#x2F;malloc "></a><a href="#context.4">free&#x2F;malloc</a><a name="section.4"> </a></h3><p>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</p>
<p>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小</p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了</p>
<h3 id="float-double"><a href="#float-double" class="headerlink" title="float&#x2F;double "></a><a href="#context.5">float&#x2F;double</a><a name="section.5"> </a></h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/float.png" alt="img"></p>
<ul>
<li><em>符号位</em>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li><em>指数位</em>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<strong>指数位的长度越长则数值的表达范围就越大</strong>；</li>
<li><em>尾数位</em>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<strong>尾数的长度决定了这个数的精度</strong>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>例：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/float%E5%AD%98%E5%82%A8.png" alt="img"></p>
<p><strong>把小数点，移动到第一个有效数字后面</strong>，即将 1010.101 右移 <code>3</code> 位成 <code>1.010101</code>，右移 3 位就代表 +3，左移 3 位就是 -3。</p>
<p><strong>float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了</strong>，即指数位这 8 位存的是 <code>10000010</code>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p>
<p><code>1.010101</code> 这个数的<strong>小数点右侧的数字就是 float 里的「尾数位」</strong>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <code>01010100000000000000000</code>。</p>
<p>这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<strong>既然这一位永远都是 1，那就可以不用存起来了</strong>。</p>
<p>于是就让 23 位尾数只存储小数部分，然后在计算时会<strong>自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点</strong>。</p>
<p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/float%E5%85%AC%E5%BC%8F.png" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/float%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BE%8B%E5%AD%90.png" alt="img"></p>
<p><strong>TIPS:</strong></p>
<blockquote>
<p><strong>为什么负数要用补码表示？</strong></p>
</blockquote>
<p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。</p>
<blockquote>
<p><strong>十进制小数怎么转成二进制？</strong></p>
</blockquote>
<p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p>
<blockquote>
<p><strong>计算机是怎么存小数的？</strong></p>
</blockquote>
<p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：</p>
<ul>
<li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li>
<li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</p>
<blockquote>
<p><strong>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</strong></p>
</blockquote>
<p>不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p>
<p>因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p>
<p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>
<h3 id="union-volatile"><a href="#union-volatile" class="headerlink" title="union&#x2F;volatile "></a><a href="#context.6">union&#x2F;volatile</a><a name="section.6"> </a></h3><p><strong>union</strong></p>
<p>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。其占内存为最大成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line"><span class="comment">// sizeof(data) 为 sizeof(double) = 8</span></span><br></pre></td></tr></table></figure>



<p><strong>volatile</strong></p>
<p>修饰异变的参数，每次都要去寄存器或内存重新读取</p>
<p>只要变量可能被意外的修改，就需要把该变量声明为volatile。在实际应用中，只有三种类型数据可能被修改：</p>
<ul>
<li>外设寄存器地址映射</li>
<li>在中断服务程序中修改全局变量</li>
<li>在多线程、多任务应用中，全局变量被多个任务读写</li>
</ul>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>DS</title>
    <url>/2023/07/27/DS/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.2">二叉树</a><a name="context.2"> </a><ul>
<li><a href="#section.3">遍历方式</a><a name="context.3"> </a><ul>
<li><a href="#section.4">深度优先DFS（Depth First Search）</a><a name="context.4"> </a></li>
<li><a href="#section.5">广度优先BFS（Breath First Search）</a><a name="context.5"> </a></li>
</ul>
</li>
<li><a href="#section.6">分类</a><a name="context.6"> </a></li>
</ul>
</li>
<li><a href="#section.7">二叉搜索树（BST）</a><a name="context.7"> </a></li>
<li><a href="#section.8">AVL树（BBT）</a><a name="context.8"> </a><ul>
<li><a href="#section.9">定义</a><a name="context.9"> </a></li>
<li><a href="#section.10">使用场景</a><a name="context.10"> </a></li>
<li><a href="#section.11">插入</a><a name="context.11"> </a><ul>
<li><a href="#section.12">1.左左型右旋</a><a name="context.12"> </a></li>
<li><a href="#section.13">2.左右型的左右旋</a><a name="context.13"> </a></li>
<li><a href="#section.14">3.右右型左旋</a><a name="context.14"> </a></li>
<li><a href="#section.15">4.右左型右左旋</a><a name="context.15"> </a></li>
</ul>
</li>
<li><a href="#section.16">总结</a><a name="context.16"> </a></li>
</ul>
</li>
<li><a href="#section.17">红黑树</a><a name="context.17"> </a><ul>
<li><a href="#section.18">定义</a><a name="context.18"> </a></li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树 "></a><a href="#context.2">二叉树</a><a name="section.2"> </a></h2><p>为<strong>有序树</strong>：</p>
<p>如果结点的各子树从左到右是有次序的、不能颠倒，则为有序树，否则为无序树。对于有序树的孩子来说，最左边的孩子称为第一个孩子，最右边的孩子称为最后一个孩子。</p>
<p>比如，如果树T1是一个有序树，则其根结点的第一个孩子为结点B，最后一个孩子为结点D</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式 "></a><a href="#context.3">遍历方式</a><a name="section.3"> </a></h3><h4 id="深度优先DFS（Depth-First-Search）"><a href="#深度优先DFS（Depth-First-Search）" class="headerlink" title="深度优先DFS（Depth First Search） "></a><a href="#context.4">深度优先DFS（Depth First Search）</a><a name="section.4"> </a></h4><p>递归遍历 - 函数递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///&lt; 中左右</span></span><br><span class="line">        cout &lt;&lt; tree-&gt;val &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTree</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Recur</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统一遍历方法！！！ */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>迭代遍历 - stack + while</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先BFS（Breath-First-Search）"><a href="#广度优先BFS（Breath-First-Search）" class="headerlink" title="广度优先BFS（Breath First Search） "></a><a href="#context.5">广度优先BFS（Breath First Search）</a><a name="section.5"> </a></h4><p>层序遍历 - 队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 迭代法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="分类"><a href="#分类" class="headerlink" title="分类 "></a><a href="#context.6">分类</a><a name="section.6"> </a></h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230719102948357.png" alt="image-20230719102948357"></p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>



<p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST） "></a><a href="#context.7">二叉搜索树（BST）</a><a name="section.7"> </a></h2><p>也称<strong>二叉查找树 BST（Binary Search Tree）</strong></p>
<p>二叉搜索树的<strong>重要特质</strong>为，<strong>在二叉树的基础上增加了左子树的所有值应都小于根节点的值，右子树的所有值应都大于根节点的值</strong>。</p>
<p>乍看二叉搜索树的访问效率很高，最大的遍历次数为树的高度，最小的遍历次数为1。但实际存在某种特殊情况，比如根节点只有一个右孩子，然后剩下的全部元素为一条直线向下排列在左子树，造成分部不均匀，查找和插入效率几乎等同于线性结构。如下图：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230717160027885.png" alt="image-20230717160027885"></p>
<p>力扣参考题目：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>、<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不同的二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                g[i] += g[j - <span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 验证二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recur</span><span class="params">(TreeNode *tree, <span class="type">long</span> min, <span class="type">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!tree)</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &lt;= min || tree-&gt;val &gt;= max)</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = <span class="built_in">Recur</span>(tree-&gt;left, min, tree-&gt;val) &amp;&amp; <span class="built_in">Recur</span>(tree-&gt;right, tree-&gt;val, max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="AVL树（BBT）"><a href="#AVL树（BBT）" class="headerlink" title="AVL树（BBT） "></a><a href="#context.8">AVL树（BBT）</a><a name="section.8"> </a></h2><p><strong>平衡二叉树</strong>全称叫做 平衡二叉搜索（排序）树，简称 AVL树。英文：Balanced Binary Tree （BBT）</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.9">定义</a><a name="section.9"> </a></h3><p>AVL树本质上是一颗二叉搜索树，但它又具有以下特点：</p>
<ol>
<li>它是一颗空树或它的左右两个子树的高度差的绝对值不超过 1</li>
<li>左右两个子树也是一颗平衡二叉树</li>
</ol>
<p><strong>需满足以下特征：</strong></p>
<ol>
<li>对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li>
<li>对于AVL树而言，其中任何子树仍然是AVL树；</li>
<li>每个节点的左右子节点的高度之差的绝对值最多为1；</li>
</ol>
<p><strong>平衡因子（BF -  Balance Factor） &#x3D; 左子树的深度 - 右子树的深度</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景 "></a><a href="#context.10">使用场景</a><a name="section.10"> </a></h3><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;&#x3D; 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p>
<p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是增加删除频繁的场景。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入 "></a><a href="#context.11">插入</a><a name="section.11"> </a></h3><h4 id="1-左左型右旋"><a href="#1-左左型右旋" class="headerlink" title="1.左左型右旋 "></a><a href="#context.12">1.左左型右旋</a><a name="section.12"> </a></h4><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718152017647.png" alt="image-20230718152017647"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左左型</strong> ，我们应该进行右旋转。</p>
<h4 id="2-左右型的左右旋"><a href="#2-左右型的左右旋" class="headerlink" title="2.左右型的左右旋 "></a><a href="#context.13">2.左右型的左右旋</a><a name="section.13"> </a></h4><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718152120654.png" alt="image-20230718152120654"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左右型</strong> ，我们应该进行左右旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718154009644.png" alt="image-20230718154009644"></p>
<h4 id="3-右右型左旋"><a href="#3-右右型左旋" class="headerlink" title="3.右右型左旋 "></a><a href="#context.14">3.右右型左旋</a><a name="section.14"> </a></h4><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718154115097.png" alt="image-20230718154115097"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右右型</strong> ，我们应该进行左旋转。</p>
<h4 id="4-右左型右左旋"><a href="#4-右左型右左旋" class="headerlink" title="4.右左型右左旋 "></a><a href="#context.15">4.右左型右左旋</a><a name="section.15"> </a></h4><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718154205028.png" alt="image-20230718154205028"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右左型</strong> ，我们应该进行右左旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230718154226276.png" alt="image-20230718154226276"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结 "></a><a href="#context.16">总结</a><a name="section.16"> </a></h3><table>
<thead>
<tr>
<th>插入位置</th>
<th>状态</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>在结点T的左结点（L）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>左左型</td>
<td>右旋</td>
</tr>
<tr>
<td>在结点T的左结点（L）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>左右型</td>
<td>左右旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>右右型</td>
<td>左旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>右左型</td>
<td>右左旋</td>
</tr>
</tbody></table>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树 "></a><a href="#context.17">红黑树</a><a name="section.17"> </a></h2><p>红黑树（RBT）继承了AVL可自平衡的优点，</p>
<p>同时, 红黑树（RBT）在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除频繁</strong>的场景。</p>
<p>在实际应用中，红黑树的使用要多得多。</p>
<p><strong>查找插入删除的时间复杂度为 O(logN)</strong></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 "></a><a href="#context.18">定义</a><a name="section.18"> </a></h3><p><strong>需满足以下特征：</strong></p>
<ol>
<li>节点非黑即红</li>
<li>根节点一定是黑色</li>
<li>叶子节点（NIL）一定是黑色</li>
<li>每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li>
</ol>
<p><strong>注：默认插入节点颜色为红色</strong></p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCodeTop100</title>
    <url>/2023/07/26/LeetCodeTop100/</url>
    <content><![CDATA[<h1 id="力扣TOP100"><a href="#力扣TOP100" class="headerlink" title="力扣TOP100"></a>力扣TOP100</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.2">哈希</a><a name="context.2"> </a></li>
<li><a href="#section.3">双指针</a><a name="context.3"> </a></li>
<li><a href="#section.4">滑动窗口</a><a name="context.4"> </a></li>
<li><a href="#section.5">子串</a><a name="context.5"> </a></li>
<li><a href="#section.6">数组</a><a name="context.6"> </a></li>
<li><a href="#section.7">矩阵</a><a name="context.7"> </a></li>
<li><a href="#section.8">链表</a><a name="context.8"> </a></li>
</ul>
<hr>
<span id="more"></span>

<p><a href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希 "></a><a href="#context.2">哈希</a><a name="section.2"> </a></h2><p><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment">你可以按任意顺序返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment">输出：[1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,3], target = 6</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">只会存在一个有效答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (it != um.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = &#123;it-&gt;second, i&#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                um[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= strs.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= strs[i].length &lt;= 100</span></span><br><span class="line"><span class="comment">strs[i] 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">string <span class="title">s</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c: str)</span><br><span class="line">                    ++s[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                </span><br><span class="line">                um[s].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it: um)</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [100,4,200,1,3,2]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(num - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cur = num;</span><br><span class="line">                    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (us.<span class="built_in">count</span>(++cur))</span><br><span class="line">                        ++size;</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针 "></a><a href="#context.3">双指针</a><a name="section.3"> </a></h2><p><a href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0,1,0,3,12]</span></span><br><span class="line"><span class="comment">输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0]</span></span><br><span class="line"><span class="comment">输出: [0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; nums.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p><img src="/LeetCodeTop100.assets/image-20230808221705531.png" alt="image-20230808221705531"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment">返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment">说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：[1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="comment">输出：49 </span></span><br><span class="line"><span class="comment">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [1,1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">2 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                len = right - left;</span><br><span class="line">                ret = height[left] &gt; height[right]</span><br><span class="line">                      ? <span class="built_in">max</span>(ret, len * height[right--])</span><br><span class="line">                      : <span class="built_in">max</span>(ret, len * height[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked">15. 3Sum - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,1,1]</span></span><br><span class="line"><span class="comment">输出：[]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和不为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,0,0]</span></span><br><span class="line"><span class="comment">输出：[[0,0,0]]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 &lt;= nums.length &lt;= 3000</span></span><br><span class="line"><span class="comment">-105 &lt;= nums[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>, e = nums.<span class="built_in">size</span>() - <span class="number">2</span>; s &lt; e; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[s] &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; <span class="number">0</span> &amp;&amp; nums[s] == nums[s - <span class="number">1</span>])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> left = s + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> sum;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum = nums[s] + nums[left] + nums[right];</span><br><span class="line">                        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                            --right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                            ++left;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ret.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[s], nums[left], nums[right]&#125;);</span><br><span class="line">                            <span class="keyword">while</span> (++left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">while</span> (left &lt; --right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p>
<p><img src="/LeetCodeTop100.assets/image-20230808221849426.png" alt="image-20230808221849426"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [4,2,0,3,2,5]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, hl = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>, hr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                hl = <span class="built_in">max</span>(hl, height[left]);</span><br><span class="line">                hr = <span class="built_in">max</span>(hr, height[right]);</span><br><span class="line">                ret += height[left] &gt; height[right] ? hr - height[right--] : hl - height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口 "></a><a href="#context.4">滑动窗口</a><a name="section.4"> </a></h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment">输出: 3 </span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment">输出: 1</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="comment">输出: 3</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">0 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">s 由英文字母、数字、符号和空格组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</span></span><br><span class="line"><span class="comment">异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">输出: [0,6]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span></span><br><span class="line"><span class="comment">输出: [0,1,2]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length, p.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">s 和 p 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tar</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: p)</span><br><span class="line">            ++tar[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">        &#123;</span><br><span class="line">            --tar[s[fast] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">while</span> (tar[s[fast] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                ++tar[s[slow++] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast - slow + <span class="number">1</span> == p.<span class="built_in">size</span>())</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="子串"><a href="#子串" class="headerlink" title="子串 "></a><a href="#context.5">子串</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,1,1], k = 2</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3], k = 3</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">-1000 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">-107 &lt;= k &lt;= 107</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 前缀 + 哈希 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            um[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                pre += n;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(pre - k))</span><br><span class="line">                    ret += um[pre - k];</span><br><span class="line"></span><br><span class="line">                ++um[pre];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment">返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span><br><span class="line"><span class="comment">输出：[3,3,5,5,6,7]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">滑动窗口的位置                最大值</span></span><br><span class="line"><span class="comment">---------------               -----</span></span><br><span class="line"><span class="comment">[1  3  -1] -3  5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1 [3  -1  -3] 5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1  3 [-1  -3  5] 3  6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1 [-3  5  3] 6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3 [5  3  6] 7       6</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3  5 [3  6  7]      7</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输入：nums = [1], k = 1</span></span><br><span class="line"><span class="comment">输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= nums.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 采用堆结构 priority_queue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">                <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt;= i - k)</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log⁡n)，因此总时间复杂度为 O(nlog⁡n)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 单调栈 deque</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                </span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">空间复杂度：O(k)，与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment">如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;BANC&quot;</span></span><br><span class="line"><span class="comment">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;a&quot;, t = &quot;a&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;a&quot;</span></span><br><span class="line"><span class="comment">解释：整个字符串 s 是最小覆盖子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span></span><br><span class="line"><span class="comment">输出: &quot;&quot;</span></span><br><span class="line"><span class="comment">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span></span><br><span class="line"><span class="comment">因此没有符合条件的子字符串，返回空字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == s.length</span></span><br><span class="line"><span class="comment">n == t.length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 105</span></span><br><span class="line"><span class="comment">s 和 t 由英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: t)</span><br><span class="line">            &#123;</span><br><span class="line">                --um[c];</span><br><span class="line">                ++need;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>, fast, start;</span><br><span class="line">            <span class="type">int</span> min_size = INT_MAX;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; s.<span class="built_in">size</span>() &amp;&amp; !um.<span class="built_in">count</span>(s[slow])) ++slow;</span><br><span class="line">            <span class="keyword">for</span> (fast = slow; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(s[fast]))</span><br><span class="line">                &#123;</span><br><span class="line">                    need -= ++um[s[fast]] &lt;= <span class="number">0</span>;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(fast);</span><br><span class="line">                    <span class="keyword">while</span> (need == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; min_size)</span><br><span class="line">                        &#123;</span><br><span class="line">                            start = slow;</span><br><span class="line">                            min_size = fast - slow + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (--um[s[slow]] &lt; <span class="number">0</span>)</span><br><span class="line">                            ++need;</span><br><span class="line"></span><br><span class="line">                        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                        slow = dq.<span class="built_in">front</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min_size != INT_MAX)</span><br><span class="line">                ret = s.<span class="built_in">substr</span>(start, min_size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组 "></a><a href="#context.6">数组</a><a name="section.6"> </a></h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment">子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [5,4,-1,7,8]</span></span><br><span class="line"><span class="comment">输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 动规（无后效性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">                pre = <span class="built_in">max</span>(pre + num, num);</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/first-missing-positive/description/">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,0]</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,4,-1,1]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [7,8,9,11,12]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 5 * 105</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 在元素组上哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    nums[i] = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= nums.<span class="built_in">size</span>()) <span class="comment">///&lt; num [1, N]</span></span><br><span class="line">                    nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵 "></a><a href="#context.7">矩阵</a><a name="section.7"> </a></h2><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked">54. 螺旋矩阵 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 10</span></span><br><span class="line"><span class="comment">-100 &lt;= matrix[i][j] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) ret.<span class="built_in">emplace_back</span>(matrix[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (++u &gt; d)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;= d; ++i) ret.<span class="built_in">emplace_back</span>(matrix[i][r]);</span><br><span class="line">                <span class="keyword">if</span> (--r &lt; l)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; --i) ret.<span class="built_in">emplace_back</span>(matrix[d][i]);</span><br><span class="line">                <span class="keyword">if</span> (--d &lt; u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = d; i &gt;= u; --i) ret.<span class="built_in">emplace_back</span>(matrix[i][l]);</span><br><span class="line">                <span class="keyword">if</span> (++l &gt; r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment">你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[[7,4,1],[8,5,2],[9,6,3]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span></span><br><span class="line"><span class="comment">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == matrix.length == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">-1000 &lt;= matrix[i][j] &lt;= 1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = u; i &lt; r; ++i, ++j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][r]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = r; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[d][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = d; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][l]);</span><br><span class="line"></span><br><span class="line">                ++u;</span><br><span class="line">                --d;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</span></span><br><span class="line"><span class="comment">每行的元素从左到右升序排列。</span></span><br><span class="line"><span class="comment">每列的元素从上到下升序排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n, m &lt;= 300</span></span><br><span class="line"><span class="comment">-109 &lt;= matrix[i][j] &lt;= 109</span></span><br><span class="line"><span class="comment">每行的所有元素从左到右升序排列</span></span><br><span class="line"><span class="comment">每列的所有元素从上到下升序排列</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 矩阵向左旋转45度，转换为BST树(二叉搜索树)，左树小，右树大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>() &amp;&amp; matrix[<span class="number">0</span>][<span class="number">0</span>] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">///&lt; 列</span></span><br><span class="line">            <span class="type">int</span> row = <span class="number">0</span>;  <span class="comment">///&lt; 行</span></span><br><span class="line">            <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt; matrix.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">                    ++row;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target)</span><br><span class="line">                    --col;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表 "></a><a href="#context.8">链表</a><a name="section.8"> </a></h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listA 中节点数目为 m</span></span><br><span class="line"><span class="comment">listB 中节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">1 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= skipA &lt;= m</span></span><br><span class="line"><span class="comment">0 &lt;= skipB &lt;= n</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 没有交点，intersectVal 为 0</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 双指针，两条路各走一遍</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA &amp;&amp; headB)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pa = headA, *pb = headB;</span><br><span class="line">            <span class="keyword">while</span> (pa != pb)</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa == <span class="literal">nullptr</span> ? headB : pa-&gt;next;</span><br><span class="line">                pb = pb == <span class="literal">nullptr</span> ? headA : pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = pa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">206. 反转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：head = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">输出：[5,4,3,2,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 三指针赋值 pre cur next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span>  (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中节点数目在范围[1, 105] 内</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 存vector转用双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head != <span class="literal">nullptr</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] == arr[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ret = l &gt;= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针 + 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已知非空，故不做判断</span></span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode *temp = fast-&gt;next ? fast-&gt;next : fast;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == temp-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == temp-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ret = temp == <span class="literal">nullptr</span>;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能用 O(1)（即，常量）内存解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head-&gt;next;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow &amp;&amp; fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = fast != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">不允许修改 链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你是否可以使用 O(1) 空间解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(head))</span><br><span class="line">                &#123;</span><br><span class="line">                    us.<span class="built_in">emplace</span>(head);</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = head;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != fast)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两个链表的节点数目范围是 [0, 50]</span></span><br><span class="line"><span class="comment">-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">l1 和 l2 均按 非递减顺序 排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力(略)</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 循环迭代 + 智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_ptr&lt;ListNode&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> ListNode())</span></span>;</span><br><span class="line">        ListNode *pre = ptr.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = list1 ? list1 : list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(c++)</title>
    <url>/2023/07/26/algorithm/</url>
    <content><![CDATA[<h1 id="算法（c-）"><a href="#算法（c-）" class="headerlink" title="算法（c++）"></a>算法（c++）</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">字符串</a><a name="context.1"> </a><ul>
<li><a href="#section.2">KMP算法</a><a name="context.2"> </a></li>
<li><a href="#section.3">Manacher算法（马拉车）</a><a name="context.3"> </a></li>
<li><a href="#section.4">不重复最长子串</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">快排</a><a name="context.5"> </a></li>
<li><a href="#section.6">回溯</a><a name="context.6"> </a></li>
<li><a href="#section.7">递归法</a><a name="context.7"> </a></li>
<li><a href="#section.8">贪心</a><a name="context.8"> </a></li>
</ul>
<hr>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串 "></a><a href="#context.1">字符串</a><a name="section.1"> </a></h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法 "></a><a href="#context.2">KMP算法</a><a name="section.2"> </a></h3><p>用于字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。</p>
<p><strong>求前缀表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 求前缀表（最长公共子串） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>相关例题：</p>
<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">KMP 459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 */</span></span><br><span class="line"><span class="comment">/** 字符串 459 重复的子字符串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string &amp;s, <span class="type">int</span> *next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">///&lt; j 为前缀末尾, i 为后缀末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="built_in">GetNext</span>(s, next);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">            ret = next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; (len % (len - (next[len - <span class="number">1</span>]))) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: arr)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!haystack.<span class="built_in">empty</span>() &amp;&amp; !needle.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; needle.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needle[i] == needle[j])</span><br><span class="line">                    ++j;</span><br><span class="line"></span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (haystack[i] == needle[j] &amp;&amp; ++j == needle.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i - j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manacher算法（马拉车）"><a href="#Manacher算法（马拉车）" class="headerlink" title="Manacher算法（马拉车） "></a><a href="#context.3">Manacher算法（马拉车）</a><a name="section.3"> </a></h3><p>一个高效匹配回文子串长度的算法，他可以在o(n)的时间复杂度中计算出一个字符串的回文子串的长度</p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 5 最长回文子串 马拉车算法 Manacher */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;  <span class="comment">///&lt; p 用来记录各点的回文半径</span></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;           <span class="comment">///&lt; 某个回文串延伸到的最右边下标</span></span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;         <span class="comment">///&lt; r 所属回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_mid = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_rad = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文半径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, end = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 i 还在区间内, 则此处半径为 i 关于 mid 对称点 j 处的半径(不超过左边界)</span></span><br><span class="line">            p[i] = i &lt; r ? <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i) : <span class="number">1</span>;  <span class="comment">///&lt; 重要!!! 需理解!!!</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴力计算回文串长度</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]])</span><br><span class="line">                ++p[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 i 处的回文字符串长度超过右边界 r 时  更新 mid 和 r</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                r = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max_rad 记录最大的半径 max_mid 记录最大半径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; max_rad) &#123;</span><br><span class="line">                max_rad = p[i];</span><br><span class="line">                max_mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>((max_mid - max_rad) &gt;&gt; <span class="number">1</span>, max_rad - <span class="number">1</span>);  <span class="comment">///&lt; 注意起始点需 / 2, 长度需 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 647 回文子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">            &#123;</span><br><span class="line">                t += c;</span><br><span class="line">                t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size())</span></span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, e = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">                p[i] = i &lt; r ? <span class="built_in">min</span>(r - i, p[<span class="number">2</span> * mid - i]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i + p[i] &gt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = i + p[i];</span><br><span class="line">                    mid = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret += (p[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>总结马拉车</strong></p>
<p>步骤如下</p>
<ol>
<li><code>p[i] = i &lt; r ? min(p[2 * mid - i], r - i) : 1;</code></li>
<li>暴力外扩</li>
<li>外扩后判断<strong>半径</strong>是否超右边界，如果是，则更新右边界和中心点</li>
<li>更新最大半径和最大半径的中心点</li>
</ol>
<h3 id="不重复最长子串"><a href="#不重复最长子串" class="headerlink" title="不重复最长子串 "></a><a href="#context.4">不重复最长子串</a><a name="section.4"> </a></h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 */</span></span><br><span class="line"><span class="comment">/** 字符串 3 无重复字符的最长子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="快排"><a href="#快排" class="headerlink" title="快排 "></a><a href="#context.5">快排</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecurQS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, temp;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            left = start;</span><br><span class="line">            right = end;</span><br><span class="line"></span><br><span class="line">            mid = nums[<span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start];  <span class="comment">// 随机效率比中位数高将近10倍</span></span><br><span class="line"><span class="comment">//            mid = nums[start + ((end - start) &gt;&gt; 1)];</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(nums[left], mid))</span><br><span class="line">                    ++left;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(mid, nums[right]))</span><br><span class="line">                    --right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = nums[left];</span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    nums[right] = temp;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; right)</span><br><span class="line">                <span class="built_in">RecurQS</span>(nums, start, right);</span><br><span class="line"></span><br><span class="line">            start = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RecurQS</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯 "></a><a href="#context.6">回溯</a><a name="section.6"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码模板 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法 "></a><a href="#context.7">递归法</a><a name="section.7"> </a></h2><p>三部曲：</p>
<ol>
<li><p><strong>确定递归函数的参数和返回值</strong></p>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>确定终止条件</strong><br>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。<br>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
</li>
<li></li>
<li><p><strong>确定单层递归的逻辑</strong></p>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心 "></a><a href="#context.8">贪心</a><a name="section.8"> </a></h2><p>如果找到局部最优，然后推出整体最优，那么就是贪心</p>
<p>局部最优 → 总体最优</p>
<p><a href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 贪心 53 最大子数组和 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">///&lt; 1. 贪心</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = INT32_MIN;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 2. 优化空间后的动态规划</span></span><br><span class="line"><span class="comment">//            ret = nums[0];</span></span><br><span class="line"><span class="comment">//            int pre = 0;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                pre = max(pre + nums[i], nums[i]);</span></span><br><span class="line"><span class="comment">//                ret = max(ret, pre);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 3. 未优化空间的动态规划</span></span><br><span class="line"><span class="comment">//            vector&lt;int&gt; dp(nums.size(), 0);</span></span><br><span class="line"><span class="comment">//            dp[0] = nums[0];</span></span><br><span class="line"><span class="comment">//            ret = dp[0];</span></span><br><span class="line"><span class="comment">//            for (int i = 1; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                if (dp[i - 1] &gt; 0)</span></span><br><span class="line"><span class="comment">//                    dp[i] = dp[i - 1] + nums[i];</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    dp[i] = nums[i];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                ret = max(ret, dp[i]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/08/16/demo/</url>
    <content><![CDATA[<p>test</p>
<p>asdasa</p>
<p>3</p>
]]></content>
  </entry>
</search>
