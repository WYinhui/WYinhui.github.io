<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++</title>
    <url>/2023/07/26/C++/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">输入输出</a><a name="context.1"> </a><ul>
<li><a href="#section.2">getline</a><a name="context.2"> </a></li>
<li><a href="#section.3">cin</a><a name="context.3"> </a></li>
</ul>
</li>
<li><a href="#section.4">nullptr</a><a name="context.4"> </a></li>
<li><a href="#section.5">左值右值</a><a name="context.5"> </a></li>
<li><a href="#section.6">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="context.6"> </a></li>
<li><a href="#section.7">类</a><a name="context.7"> </a></li>
<li><a href="#section.8">友元</a><a name="context.8"> </a><ul>
<li><a href="#section.9">友元函数</a><a name="context.9"> </a></li>
<li><a href="#section.10">友元类</a><a name="context.10"> </a></li>
</ul>
</li>
<li><a href="#section.11">重载</a><a name="context.11"> </a></li>
<li><a href="#section.12">bitset（位库）</a><a name="context.12"> </a></li>
<li><a href="#section.13">STL</a><a name="context.13"> </a></li>
<li><a href="#section.14">unordered_set方法</a><a name="context.14"> </a></li>
<li><a href="#section.15">pair容器</a><a name="context.15"> </a></li>
<li><a href="#section.16">vector 容器</a><a name="context.16"> </a></li>
<li><a href="#section.17">list（链表）</a><a name="context.17"> </a></li>
<li><a href="#section.18">vector和list的区别</a><a name="context.18"> </a></li>
<li><a href="#section.19">deque（双端数组）</a><a name="context.19"> </a></li>
<li><a href="#section.20">stack &#x2F; queue</a><a name="context.20"> </a></li>
<li><a href="#section.21">priority_queue</a><a name="context.21"> </a></li>
<li><a href="#section.22">map &#x2F; set</a><a name="context.22"> </a></li>
<li><a href="#section.23">map &#x2F; unordered_map</a><a name="context.23"> </a></li>
<li><a href="#section.24">multimap</a><a name="context.24"> </a></li>
<li><a href="#section.25">C++模板全特化和偏特化</a><a name="context.25"> </a></li>
<li><a href="#section.26">lambda表达式</a><a name="context.26"> </a></li>
<li><a href="#section.27">智能指针</a><a name="context.27"> </a><ul>
<li><a href="#section.28">定义</a><a name="context.28"> </a></li>
<li><a href="#section.29">shared_ptr（常用）</a><a name="context.29"> </a></li>
<li><a href="#section.30">unique_ptr</a><a name="context.30"> </a></li>
<li><a href="#section.31">weak_ptr</a><a name="context.31"> </a></li>
<li><a href="#section.32">auto_ptr</a><a name="context.32"> </a></li>
</ul>
</li>
<li><a href="#section.33">function</a><a name="context.33"> </a></li>
<li><a href="#section.34">decltype &#x2F; auto</a><a name="context.34"> </a></li>
</ul>
<hr>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出 "></a><a href="#context.1">输入输出</a><a name="section.1"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; ++i &lt;&lt; i++ &lt;&lt; i &lt;&lt; i++ &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line"><span class="comment">///&lt; 输出为 &amp;5 3 &amp;5 2 &amp;5</span></span><br></pre></td></tr></table></figure>

<p>cout输出控制台过程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161641648.png" alt="img"></p>
<p>从 <code>endl</code> 开始，从右向左依次入栈，最后依次弹出</p>
<h3 id="getline"><a href="#getline" class="headerlink" title="getline "></a><a href="#context.2">getline</a><a name="section.2"> </a></h3><p>默认遇换行符或 <code>EOF</code> 结束，也可自定义结束符</p>
<p>上限字符数为 <code>1024</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare s: 字符串变量</span></span><br><span class="line"><span class="comment"> * @pare n: 字符个数 (第n个补&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;iostream&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">std::cin.<span class="built_in">getline</span>(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare is: 标准输入流函数 (常用 std::cin)</span></span><br><span class="line"><span class="comment"> * @pare str: 存字符的变量名</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;string&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">string::<span class="built_in">getline</span>(istream&amp; is, string&amp; str, <span class="type">char</span> delim);</span><br></pre></td></tr></table></figure>



<h3 id="cin"><a href="#cin" class="headerlink" title="cin "></a><a href="#context.3">cin</a><a name="section.3"> </a></h3><p>在上述的停止条件上，遇空格也会停止</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr "></a><a href="#context.4">nullptr</a><a name="section.4"> </a></h2><p>c++11引入 <code>nullptr</code> ，为 <strong>右值常量</strong></p>
<p>原因：</p>
<p>在函数重载的时候，如果还是用C语言的 <code>NULL</code> 则会出错，并且 <code>NULL</code> 只是单纯的宏定义替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;int\n&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;ptr\n&quot;</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">NULL</span>);  <span class="comment">///&lt; 不注释掉的话会报错</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 输出 &quot;ptr&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值 "></a><a href="#context.5">左值右值</a><a name="section.5"> </a></h2><p>首先区分一下什么是左值，什么是右值。<br>左值就是可以写在赋值号左边的，右值是写在赋值号右边的。<br>比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Stu <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Stu</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是左值</span></span><br><span class="line">Stu s = <span class="built_in">foo</span>(); <span class="comment">// s是左值，foo()的返回值是右值</span></span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// a + b 的结果是右值，c是左值</span></span><br></pre></td></tr></table></figure>

<p><code>foo()</code> 返回了一个没有名字的<code>Stu</code>对象，你不能写<code>foo() = s</code>，所以<code>foo()</code>就是个右值。<br>还有一种定义说是，无法取地址的就是右值，可以取地址的是左值。</p>
<h2 id="左值引用-和右值引用"><a href="#左值引用-和右值引用" class="headerlink" title="左值引用(&amp;)和右值引用(&amp;&amp;) "></a><a href="#context.6">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="section.6"> </a></h2><p>首先要注意一点：<code>&amp;&amp;</code>不是“引用的引用”，这仅仅是一个记号，这个记号我改成<code>$</code>也没什么问题。不能像理解指针<code>**</code>是指针的指针这样去类比。<br>左值引用就是给左值变量起别名，右值引用就是给右值变量起别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;aa = a; <span class="comment">//左值引用</span></span><br><span class="line">Stu &amp;&amp;s = <span class="built_in">foo</span>(); <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>Stu &amp;&amp;s &#x3D; foo()，就是给foo()返回的临时对象起了个别名，本来它在foo()返回后生存期就到了，就该析构了，但是由于s对她进行了引用，他的生存期被延长至和s相同。如果是Stu s &#x3D; foo()则会在赋值时发生一次拷贝构造。</p>
<p>附两篇写的很好的文章<br><a href="https://www.cnblogs.com/sunchaothu/p/11392116.html">C++ 11的移动语义 - 行者孙 - 博客园</a><br><a href="https://www.cnblogs.com/lidabo/p/3908681.html">C++11新特性：右值引用和转移构造函数 - DoubleLi - 博客园</a></p>
<p>作者：wangbingbing</p>
<p>出处：<a href="https://www.cnblogs.com/wangbingbing/p/15179675.html">https://www.cnblogs.com/wangbingbing/p/15179675.html</a></p>
<h2 id="类"><a href="#类" class="headerlink" title="类 "></a><a href="#context.7">类</a><a name="section.7"> </a></h2><p><strong>注意：</strong></p>
<ol>
<li>成员变量和成员函数分开存储</li>
<li>静态成员只能在类外初始化，<code>cosnt</code> 常量静态成员在类内初始化<br>静态成员变量，属于某个类，所有对象共享，无论建立了多少个对象，都只有一个静态数据的拷贝。是在编译阶段就分配好了空间，对象还没有创建时，就已经分配空间。</li>
<li>类的静态成员访问<br>用 <code>::</code> 或者 <code>.</code></li>
<li>类的静态函数只能访问类中的静态变量，其他函数则都可访问</li>
<li>静态函数没有 <code>this</code> 指针，同时静态变量也有访问级别限制（公有，私有，保护）</li>
</ol>
<p><strong>类中的虚函数占用为一个指针的大小</strong></p>
<p><strong>类的成员函数，实际上相当于普通函数，只不过把类对象隐式的传递进去罢了</strong></p>
<p><strong>空类的大小为？</strong></p>
<p>c++要求每个实例在内存中都有独一无二的地址。空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元 "></a><a href="#context.8">友元</a><a name="section.8"> </a></h2><p><strong>友元提供了一种突破封装的方式。</strong>友元函数提供了一种在需要时访问类的私有成员的机制，但应该慎重使用，因为过多的友元函数可能破坏类的封装性。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数 "></a><a href="#context.9">友元函数</a><a name="section.9"> </a></h3><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但是需要在类的内部声明，声明时需要加friend关键字。</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元函数可以访问类的所有成员，但此函数不是类的成员函数</li>
<li>友元函数不能用 <code>const</code> 修饰</li>
<li>友元函数可以在类定义的任何地方申明，不受类访问限定符限制</li>
<li>一个函数可以是多个类的友元函数</li>
<li>友元函数调用和普通函数的调用原理相同</li>
</ol>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类 "></a><a href="#context.10">友元类</a><a name="section.10"> </a></h3><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元关系是单向的，不具有交换性<br>比如Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行</li>
<li>友元关系不能传递<br>如果B是A的友元，C是A的友元，则不能说明C是A的友元</li>
</ol>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载 "></a><a href="#context.11">重载</a><a name="section.11"> </a></h2><p>形式：</p>
<p><strong>[返回值] operator[运算符] (参数…) { … }；</strong></p>
<p><strong>不能重载的5种运算符：</strong></p>
<ol>
<li><code>.*</code><br>任意字符出现零次或多次</li>
<li><code>::</code><br>域作用符  </li>
<li><code>sizeof</code><br>关键字 - 大小</li>
<li><code>?:</code><br>三目运算符</li>
<li><code>.</code><br>点运算符</li>
</ol>
<p>例：重载类运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> _hour;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _sec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span> hour = <span class="number">0</span>, <span class="type">int</span> min = <span class="number">0</span>, <span class="type">int</span> sec = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_hour = hour;</span><br><span class="line">		_min = min;</span><br><span class="line">		_sec = sec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _sec &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为方便演示，让小时+1，但不再判断时间正确性</span></span><br><span class="line">	Time&amp; <span class="keyword">operator</span>++()<span class="comment">// ++A  不带参数为前置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);<span class="comment">//因为自增直接返回this用引用接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	Time <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//A++，参数写int或int i都可以   带参数为后置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Time <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;<span class="comment">//需要返回this自增之前的结果，所以用临时变量返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「就要 宅在家」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/weixin_61857742/article/details/126010673</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 友元函数重载流提取 &lt;&lt; / &gt;&gt;</span></span><br><span class="line"><span class="comment">// 对于流而言，因为是双目运算符，this指针本应该指向左边的类，但左操作数是一个流，又与this的类型冲突。</span></span><br><span class="line"><span class="comment">// 这时，就需要用到友元函数friend。友元函数本身是一个普通函数，但是作为类的友元，能够调用类内的成员，包括private。而且参数不用被类限制为第一个必须是this所指的对象本身。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class &#123;</span></span><br><span class="line"><span class="comment">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Time&amp; t);//友元函数，声明</span></span><br><span class="line"><span class="comment">	friend istream&amp; operator&gt;&gt;(istream&amp; in, Time&amp; t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="bitset（位库）"><a href="#bitset（位库）" class="headerlink" title="bitset（位库） "></a><a href="#context.12">bitset（位库）</a><a name="section.12"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span>  <span class="comment">///&lt; 所在头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">///&lt; 命名空间std</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 默认无参构造</span></span><br><span class="line">    <span class="comment">// 初始化全部位为0</span></span><br><span class="line">    std::bitset&lt;8&gt; bs;</span><br><span class="line">    <span class="comment">//bs[0] = 1;            // 0000 0001</span></span><br><span class="line">    <span class="comment">//bs[7] = 1;            // 1000 0000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传值构造方式</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">0x07</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 构造</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;00000111&quot;</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_ulong</span>();      <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.any()</td>
<td>是否存在值为1的二进制位</td>
</tr>
<tr>
<td>.none()</td>
<td>是否不存在值为1的二进制位<br/>或者说是否全部位为0</td>
</tr>
<tr>
<td>.size()</td>
<td>位长，也即是非模板参数值</td>
</tr>
<tr>
<td>.count()</td>
<td>值为1的个数</td>
</tr>
<tr>
<td>.test(pos)</td>
<td>测试pos处的二进制位是否为1<br/>与0做或运算</td>
</tr>
<tr>
<td>.set()</td>
<td>全部位置1</td>
</tr>
<tr>
<td>.set(pos)</td>
<td>pos位处的二进制位置1<br/>与1做或运算</td>
</tr>
<tr>
<td>.reset()</td>
<td>全部位置0</td>
</tr>
<tr>
<td>.reset(pos)</td>
<td>pos位处的二进制位置0<br/>与0做或运算</td>
</tr>
<tr>
<td>.flip()</td>
<td>全部位逐位取反</td>
</tr>
<tr>
<td>.flip(pos)</td>
<td>pos处的二进制位取反</td>
</tr>
<tr>
<td>.to_ulong()</td>
<td>将二进制转换为unsigned long输出</td>
</tr>
<tr>
<td>.to_string()</td>
<td>将二进制转换为字符串输出</td>
</tr>
<tr>
<td>~bs</td>
<td>按位取反<br/>效果等效为bs.flip()</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>将二进制位输出到os流<br/>小值在右，大值在左</td>
</tr>
</tbody></table>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL "></a><a href="#context.13">STL</a><a name="section.13"> </a></h2><p>STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是：</p>
<ol>
<li><p><strong>容器</strong></p>
<p>各种数据结构，如vector、list、deque、set、map等，⽤来存放数据，从实现角度来看，STL 容器是⼀种 <code>class template</code></p>
</li>
<li><p><strong>算法</strong></p>
<p>各种常⽤的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是⼀种 <code>function template</code></p>
</li>
<li><p><strong>迭代器</strong></p>
<p>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是⼀种将 operator* , operator-&gt; , operator++, operator– 等指针相关操作予以重载的 <code>class template</code>。  </p>
<p>所有STL容器都附带有⾃⼰专属的迭代器，只有容器的设计者才知道如何遍历⾃⼰的元素。  </p>
<p>原⽣指针(native pointer)也是⼀种迭代器。</p>
</li>
<li><p><strong>仿函数</strong></p>
<p>⾏为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是⼀种重载了operator() 的 class 或者 class template</p>
</li>
<li><p><strong>适配器（配接器）</strong></p>
<p>⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东西。  </p>
<p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应</p>
</li>
<li><p><strong>空间配置器</strong></p>
<p>负责空间的配置与管理。从实现角度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的 class template</p>
<p>⼀般的分配器的 std:alloctor 都含有两个函数 allocate 与 deallocte，这两个函数分别调⽤ operator new() 与 delete()，这两个函数的底层⼜分别是malloc() and free(); 但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p>
</li>
</ol>
<p><strong>容器之间的实现关系以及分类：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161642801.png" alt="image-20230615150413812-1692155829457"></p>
<p><strong>STL六⼤组件的交互关系：</strong></p>
<ol>
<li>容器通过空间配置器取得数据存储空间  </li>
<li>算法通过迭代器存储容器中的内容  </li>
<li>仿函数可以协助算法完成不同的策略的变化 </li>
<li>适配器可以修饰仿函数</li>
</ol>
<p><strong>STL的优点</strong></p>
<p>STL 具有⾼可重⽤性，⾼性能，⾼移植性，跨平台的优点</p>
<ol>
<li>⾼可重⽤性<br>STL 中几乎所有的代码都采⽤了模板类和模版函数的⽅式实现，这相⽐于传统的由函数和类组成的库来说提供了更好的代码重⽤机会</li>
<li>⾼性能<br>如 map 可以⾼效地从⼗万条记录⾥⾯查找出指定的记录，因为 map 是采⽤红黑树的变体实现的</li>
<li>⾼移植性<br>如在项⽬ A 上⽤ STL 编写的模块，可以直接移植到项⽬ B 上</li>
</ol>
<p><strong>STL 的⼀个重要特性是将数据和操作分离</strong></p>
<p>数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当 “粘合剂” 以使算法可以和容器交互运作</p>
<h2 id="unordered-set方法"><a href="#unordered-set方法" class="headerlink" title="unordered_set方法 "></a><a href="#context.14">unordered_set方法</a><a name="section.14"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 x 在 us 中， 返回1 否则0 </span></span><br><span class="line">us.<span class="built_in">count</span>(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="pair容器"><a href="#pair容器" class="headerlink" title="pair容器 "></a><a href="#context.15">pair容器</a><a name="section.15"> </a></h2><p>保存两个数据成员，⽤来⽣成特定类型的模板</p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line"><span class="comment">///&lt; 数据成员是public，两个成员分别是first和second</span></span><br></pre></td></tr></table></figure>



<h2 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器 "></a><a href="#context.16">vector 容器</a><a name="section.16"> </a></h2><p><strong>底层：</strong></p>
<p>Vector在堆中分配了⼀段连续的内存空间来存放元素</p>
<p>底层为动态数组</p>
<p>扩容：</p>
<ol>
<li>固定扩容</li>
<li>加倍扩容</li>
</ol>
<h2 id="list（链表）"><a href="#list（链表）" class="headerlink" title="list（链表） "></a><a href="#context.17">list（链表）</a><a name="section.17"> </a></h2><p><strong>中间位置的插入与删除是 O(1)</strong></p>
<p><strong>实现方式：</strong>双向链表</p>
<h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别 "></a><a href="#context.18">vector和list的区别</a><a name="section.18"> </a></h2><ol>
<li>vector 底层实现是数组；list 是双向链表 </li>
<li>vector 是顺序内存，⽀持随机访问，list 不⾏ </li>
<li>vector 在中间节点进⾏插⼊删除会导致内存拷⻉，list不会 </li>
<li>vector ⼀次性分配好内存，不够时才进⾏翻倍扩容；list 每次插⼊新节点都会进⾏内存申请 </li>
<li>vector 随机访问性能好，插⼊删除性能差；list 随机访问性能差，插⼊删除性能好</li>
</ol>
<h2 id="deque（双端数组）"><a href="#deque（双端数组）" class="headerlink" title="deque（双端数组） "></a><a href="#context.19">deque（双端数组）</a><a name="section.19"> </a></h2><ol>
<li>O(1)<br>首尾插入，删除，访问</li>
<li>O(n)<br>中间插入 insert()，erase()</li>
</ol>
<p><strong>在头&#x2F;尾部插入&#x2F;删除时间复杂度为 O(1)</strong></p>
<p><strong>致命缺陷：</strong>不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下</p>
<p>因此，需要线性结构时，大多数情况下优先考虑<code>vector</code>和<code>list</code>，<code>deque</code>的应用并不多，而目前能看到的一个应用就是，STL用其作为<code>stack</code>和<code>queue</code>的底层数据结构。</p>
<p>⽀持快速随机访问，由于 deque 需要处理内部跳转，因此速度上没有 vector 快</p>
<p>deque 是⼀个<strong>双端开口</strong>的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接</p>
<p><strong>注意：</strong></p>
<p>由于deque的迭代器⽐vector要复杂，这影响了各个运算层面，所以除⾮必要尽量使⽤ vector；<br>为了提⾼效率，在对deque进⾏排序操作的时候，我们可以先把 deque 复制到 vector 中再进⾏排序最后在复制回 deque</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161643278.png" alt="image-20230615153051799-1692155829457"></p>
<p>deque采⽤⼀块map作为主控，其中的每个元素都是指针，指向另⼀⽚连续线性空间，称之为 缓存区，这个区才是⽤来储存数据的</p>
<h2 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack &#x2F; queue "></a><a href="#context.20">stack &#x2F; queue</a><a name="section.20"> </a></h2><p>概述：栈与队列被称之为 deque 的配接器，其底层是以 deque 为底部架构。通过 deque 执⾏具体操作</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue "></a><a href="#context.21">priority_queue</a><a name="section.21"> </a></h2><pre><code>     优先队列是一种容器适配器，采用了堆这样的数据结构，保证了第一个元素总是整个优先队列中最大的(或最小的)元素。  优先队列默认使用vector作为底层存储数据的容器，在vector上使用了堆算法将vector中的元素构造成堆的结构，所以其实我们就可以把它当作堆，凡是需要用堆的位置，都可以考虑优先队列。
</code></pre>
<p>​		 默认情况下 <code>priority_queue</code> 是大堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="comment">///&lt; 优先队列底层使用的存储结构，可以看出来，默认采用vector</span></span><br><span class="line">          <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;  <span class="comment">///&lt; 定义优先队列中元素的比较方式的类，默认是按小于(less)的方式比较，</span></span><br><span class="line">                                                                <span class="comment">///&lt; 这种比较方式创建出来的就是大堆。所以优先队列默认就是大堆</span></span><br><span class="line">                                                                <span class="comment">///&lt; 如果需要创建小堆，就需要将less改为greater</span></span><br><span class="line">          &gt; <span class="keyword">class</span> priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载比较函数 Compare */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 重载 ()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;  <span class="comment">///&lt; 此处与快排的排序相反， &gt; 表从小到大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(&amp;Cmp)&gt; <span class="built_in">pq</span>(Cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 3: class / struct</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：priority_queue 无迭代器！！</strong></p>
<ol>
<li>push() &#x2F; emplace()<br>O(log N)，push(x) 令x入队，其中 N 为当前优先队列中元素的个数</li>
<li>top()<br>O(1)，获得队首元素(即堆顶元素)</li>
<li>pop()<br>O(log N)，令队首元素(即堆顶元素)出队</li>
<li>empty()<br>O(1)，检测优先队列是否为空，返回 true则空，返回false 则非空</li>
<li>size()<br>O(1)，返回优先队列内元素的个数</li>
</ol>
<p><strong>emplace()与push()的区别</strong></p>
<p>当我们使用push()时，会创建一个对象，然后将其插入优先级队列。而使用emplace()，该对象将原地构造，节省了不必要的副本</p>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map &#x2F; set "></a><a href="#context.22">map &#x2F; set</a><a name="section.22"> </a></h2><p>有序（从小到大），底层为<strong>红黑树</strong></p>
<p><strong>共同点：</strong>都是C++的关联容器，只是通过它提供的接口对里面的元素进行访问，底层都是采⽤红黑树实现</p>
<p><strong>不同点：</strong></p>
<p>set：⽤来判断某⼀个元素是不是在⼀个组里面。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典</p>
<p><strong>优点：</strong></p>
<p>查找某⼀个数的时间为 <code>O(logn)</code>；遍历时采⽤ iterator，效果不错</p>
<p><strong>缺点：</strong></p>
<p>每次插⼊值的时候，都需要调整红黑树，效率有⼀定影响</p>
<p><strong>重载 &lt; 排序方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age):<span class="built_in">name_</span>(name),<span class="built_in">age_</span>(age)&#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Student &amp;s) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(name_ != s.name_)&#123;</span><br><span class="line">            <span class="keyword">return</span> name_ &lt; s.name_;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age_ &lt; s.age_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::string <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name_ + <span class="string">&quot;, age:&quot;</span> + std::<span class="built_in">to_string</span>(age_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    set&lt;Student&gt; s;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;Danney&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        cout &lt;&lt; it.<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小梦_人生如戏」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/yu532164710/article/details/105194036</span></span><br></pre></td></tr></table></figure>



<p><strong>细节：</strong></p>
<ol>
<li><strong>为什么要成倍的扩容而不是⼀次增加⼀个固定⼤⼩的容量呢？</strong><br>采⽤成倍⽅式扩容，可以保证常数的时间复杂度，⽽增加指定⼤⼩的容量只能达到O(n)的时间复杂度</li>
<li><strong>为什么是以两倍的⽅式扩容而不是三倍四倍，或者其他⽅式呢？</strong><br>考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是 1.5 或 2；GCC 是 2；VS 是 1.5，k &#x3D; 2 每次扩展的新尺寸必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤ 1.5 倍的增⻓⽅式可以更好的实现对内存的重复利用</li>
</ol>
<p><strong>注：C++并没有规定扩容因子K，这是由标准库的实现者决定的</strong></p>
<h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map &#x2F; unordered_map "></a><a href="#context.23">map &#x2F; unordered_map</a><a name="section.23"> </a></h2><p>map中元素是⼀些 <code>key-value</code> 对，关键字起索引作⽤，值表示和索引相关的数据</p>
<p><strong>底层实现：</strong></p>
<p><code>map</code> 底层是基于<strong>红黑树</strong>实现的，因此map内部元素排列是有序的<br><code>unordered_map</code> 底层则是基于<strong>哈希表</strong>实现的，因此其元素的排列顺序是杂乱⽆序的</p>
<table>
<thead>
<tr>
<th></th>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>有序性，这是map结构最⼤的优点，<br />其元素的有序性在很多应⽤中都会简化很多的操作<br />map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为 O(logn)</td>
<td>查找、删除、添加的速度快，时间复杂度为常数级O(1）</td>
</tr>
<tr>
<td>缺点</td>
<td>查找、删除、增加等操作平均时间复杂度较慢，与 n 相关</td>
<td>因为unordered_map内部基于哈希表，<br />以（key,value）对的形式存储，因此空间占⽤率⾼<br />unordered_map的查找、删除、添加的时间复杂度不稳定<br />平均为O(1)，取决于哈希函数，极端情况下可能为O(n)</td>
</tr>
</tbody></table>
<p><strong>问题：</strong></p>
<ol>
<li><strong>为什么 <code>insert</code> 之后，以前保存的 <code>iterator</code> 不会失效？</strong><br><strong>答：</strong> 因为 map 和 set 存储的是结点，不需要内存拷⻉和内存移动。但是像 vector 在插入数据时如果内存不够会重新开辟一块内存。 map 和 set 的 iterator 指向的是节点的指针，vector 指向的是内存的某个位置</li>
<li><strong>为何 map 和 set 的插入删除效率比其他序列容器高？</strong><br><strong>答：</strong> 因为 map 和 set 底部使用红黑树实现，插入和删除的时间复杂度是 <code>O(logn)</code>，而像 vector 这样的序列容器插入和删除的时间复杂度是 <code>O(N)</code></li>
</ol>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap "></a><a href="#context.24">multimap</a><a name="section.24"> </a></h2><p>multimap是C++ STL中的一个关联容器，它与map类似，但可以存储多个具有相同键值的元素。</p>
<p>multimap使用红黑树实现，因此它的插入、查找、删除操作的时间复杂度为O(log n)，其中n为multimap中元素的数量。由于multimap允许重复的键值，因此对于某些操作，如查找、删除等，复杂度可能会更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.构造函数</span></span><br><span class="line"><span class="built_in">multimap</span>();                             <span class="comment">///&lt; 创建一个空的multimap。</span></span><br><span class="line"><span class="built_in">multimap</span>(InputIt first, InputIt last);  <span class="comment">///&lt; 创建一个包含[first, last)区间内所有元素的新multimap，要求这些元素必须支持拷贝构造函数。</span></span><br><span class="line"><span class="built_in">multimap</span>(<span class="type">const</span> multimap&amp; other);        <span class="comment">///&lt; 拷贝构造函数，创建一个新的multimap，它与另一个multimap中的元素相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.迭代器</span></span><br><span class="line"><span class="built_in">begin</span>();   <span class="comment">///&lt; 返回指向multimap第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>();     <span class="comment">///&lt; 返回指向multimap最后一个元素之后位置的迭代器。</span></span><br><span class="line"><span class="built_in">rbegin</span>();  <span class="comment">///&lt; 返回指向multimap最后一个元素的反向迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>();    <span class="comment">///&lt; 返回指向multimap第一个元素之前位置的反向迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.容量</span></span><br><span class="line"><span class="built_in">empty</span>();     <span class="comment">///&lt; 如果multimap为空，则返回true，否则返回false。</span></span><br><span class="line"><span class="built_in">size</span>();      <span class="comment">///&lt; 返回multimap中元素的数量。</span></span><br><span class="line"><span class="built_in">max_size</span>();  <span class="comment">///&lt; 返回multimap可以包含的最大元素数量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.插入与删除</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; val);                     <span class="comment">///&lt; 将val插入到multimap中。如果multimap中已经存在一个键值与val相等的元素，</span></span><br><span class="line">                                                   <span class="comment">///&lt; 则新的val将会被插入到该键值所对应的元素序列的尾部。</span></span><br><span class="line"><span class="built_in">insert</span>(InputIt first, InputIt last);               <span class="comment">///&lt; 将[first, last)区间内的所有元素插入到multimap中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* m.emplace(key, value) */</span></span><br><span class="line"><span class="built_in">emplace</span>(key, value);                               <span class="comment">///&lt; 在当前multimap容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key);                        <span class="comment">///&lt; 删除multimap中所有键值为key的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator position);                    <span class="comment">///&lt; 删除迭代器position所指向的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator first, const_iterator last);  <span class="comment">///&lt; 删除[first, last)区间内的所有元素。</span></span><br><span class="line"><span class="built_in">clear</span>();                                           <span class="comment">///&lt; 清空multimap中的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.查找</span></span><br><span class="line"><span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key);        <span class="comment">///&lt; 返回multimap中键值为key的元素数量。</span></span><br><span class="line"><span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key);         <span class="comment">///&lt; 查找并返回multimap中第一个键值为key的元素的迭代器。如果找不到，则返回end()。</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; key);  <span class="comment">///&lt; 返回一个pair，包含两个迭代器，第一个迭代器指向multimap中第一个键值为key的元素，</span></span><br><span class="line">                                   <span class="comment">///&lt; 第二个迭代器指向multimap中第一个键值大于key的元素。如果找不到任何元素，则两个迭代器都等于end()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 除了以上方法，multimap还继承了map类的其他方法，如key_comp()、value_comp()等。 **********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义排序 demo */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，对键进行降序排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string, Compare&gt; myMultimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 insert() 函数插入键值对</span></span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">3</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : myMultimap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key = &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, Value = &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-模板全特化和偏特化"><a href="#C-模板全特化和偏特化" class="headerlink" title="C++模板全特化和偏特化 "></a><a href="#context.25">C++模板全特化和偏特化</a><a name="section.25"> </a></h2><p><strong>模板分为：</strong>1. 类模板  2. 函数模板</p>
<p><strong>特化分为：</strong>1. 特例化（全特化）  2. 部分特例化（偏特化）</p>
<p>对模板特例化是因为对特定类型，可以利⽤某些特定知识来提⾼效率，⽽不是使⽤通⽤模板</p>
<p><strong>对函数模板：</strong></p>
<ol>
<li>模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本</li>
<li>⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化</li>
</ol>
<p><strong>模板函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;模板函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span> , <span class="type">char</span> &gt;(<span class="type">int</span> a, <span class="type">char</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///&lt; 函数模板，只有全特化，偏特化的功能可以通过函数的重载完成</span></span><br></pre></td></tr></table></figure>



<p><strong>对类模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span> , <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i, <span class="type">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">char</span>, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">char</span> i, T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类&gt;偏特化类&gt;主版本模板类</span></span><br></pre></td></tr></table></figure>





<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式 "></a><a href="#context.26">lambda表达式</a><a name="section.26"> </a></h2><p>lambda表达式<strong>表示⼀个可调⽤的代码单元</strong>，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤它，不需要其他地⽅调⽤它</p>
<p>表达式语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; [捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span></span><br><span class="line"><span class="comment">///&lt; 只有 [capture list] 捕获列表和 &#123; function body &#125; 函数体是必选的</span></span><br><span class="line"><span class="comment">///&lt; 其中 -&gt; return type 可省略，单行函数自动判断返回类型</span></span><br><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;function body &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 例：</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [&amp;count](<span class="type">int</span> x) &#123;</span><br><span class="line">    count += x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; count == 0;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">///&lt; count == 1;</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>不捕获任何变量，这种情况下 <code>lambda</code> 表达式内部不能访问外部的变量</td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>以引用方式捕获所有变量（保证 <code>lambda</code> 执行时变量存在）</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>用值的方式捕获所有变量（创建时拷贝，修改对 <code>lambda</code> 内对象无影响）</td>
</tr>
<tr>
<td><code>[=, &amp;foo]</code></td>
<td>以引用捕获变量 <code>foo</code>，但其余变量都靠值捕获</td>
</tr>
<tr>
<td><code>[&amp;, foo]</code></td>
<td>以值捕获 <code>foo</code> ，但其余变量都靠引用捕获</td>
</tr>
<tr>
<td><code>[bar]</code></td>
<td>以值方式捕获 <code>bar</code>，不捕获其他变量</td>
</tr>
<tr>
<td><code>[this]</code></td>
<td>捕获所在类的 <code>this</code> 指针</td>
</tr>
</tbody></table>
<p><strong>lambda最大的⼀个优势是在使⽤STL中的算法(algorithms)库</strong></p>
<p>如数组排序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161644180.png" alt="image-20230616102708669-1692155829457"></p>
<p>set&lt;&gt;</p>
<p>deque</p>
<p>vector&lt;&gt;</p>
<p>map&lt;&gt;</p>
<p>list&lt;&gt;</p>
<p>stack&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 小端模式，高位存内存高地址，地位存低</span><br><span class="line">浮点数最好用double类型(默认)而不是float</span><br><span class="line"></span><br><span class="line">const int c = 12;			# 同c的 #define，声明常量，c++中应使用const</span><br><span class="line"></span><br><span class="line">int xxx[3] = &#123; 20, 1, 16 &#125;		# 花括号直接给数组赋值</span><br><span class="line"></span><br><span class="line">sizeof xx				# 显示xx变量长度字节，（int）加括号为类型</span><br><span class="line"># char为1bytes</span><br><span class="line"># 整形: char (1), short (2), int (4), long (4), long long (8)</span><br><span class="line"># 浮点型: float (4), double (8), long double (80,96,128位&lt;16字节&gt;  /8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示个数则  xx/xx[0]</span><br><span class="line"># 数组默认表示地址，不能像python一样直接打印数组</span><br><span class="line"></span><br><span class="line">strlen()		# 显示字符串长度，需要include cstring</span><br><span class="line">		# 同python的len()，只针对字符串</span><br><span class="line">.size()		# 同上，需要include string</span><br><span class="line"></span><br><span class="line">--&gt; 字符串以空字符结尾 &#x27;\0&#x27;</span><br><span class="line">--&gt; 字符数组相反</span><br><span class="line">char fish[] = &quot;Bubbles&quot;;		</span><br><span class="line"># 字符串常量直接用双引号，末尾会自动加\0，且表地址</span><br><span class="line"># 字符常量用单引号，如：&#x27;s&#x27; , 且与字符串常量不能互换</span><br><span class="line"></span><br><span class="line">面向行的输入：getline(1, 2)</span><br><span class="line"># 不保存换行符！</span><br><span class="line"># 1.用来存储的数组名称 2.读取的字符数(需要-1)</span><br><span class="line"># 例：getline(name, 20)  读19个存到name</span><br><span class="line"></span><br><span class="line">面向行的输入：get(1, 2)		# 保留回车</span><br><span class="line"># 可用get()来读取一个字符（包括回车）</span><br><span class="line"># 可用 cin.get(name, 10).get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string类</span><br><span class="line"># 可以赋值给变量</span><br><span class="line"></span><br><span class="line">struct	结构体 --&gt; c需要关键字struct xx  ， c++ 不需要struct</span><br><span class="line"># 注意结构体赋值是加花括号 &#123; &#125;</span><br><span class="line"></span><br><span class="line">union	共用体 --&gt; 只能存int,lomg,double</span><br><span class="line"></span><br><span class="line">enum xxx &#123;a, b, c&#125;		# 此时xxx为枚举</span><br><span class="line"># xxx ban			# 定义ban为枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针 "></a><a href="#context.27">智能指针</a><a name="section.27"> </a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.28">定义</a><a name="section.28"> </a></h3><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;TC&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> TC())</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TC *tc = ptr.<span class="built_in">get</span>();  <span class="comment">///&lt; 获取原指针</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>();  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="shared-ptr（常用）"><a href="#shared-ptr（常用）" class="headerlink" title="shared_ptr（常用） "></a><a href="#context.29">shared_ptr（常用）</a><a name="section.29"> </a></h3><p>采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p>
<p><strong>注：</strong></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr "></a><a href="#context.30">unique_ptr</a><a name="section.30"> </a></h3><p>unique_ptr采用的是独享资源所有权，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr "></a><a href="#context.31">weak_ptr</a><a name="section.31"> </a></h3><p>弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr "></a><a href="#context.32">auto_ptr</a><a name="section.32"> </a></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。</p>
<p><code>auto_ptr</code> 是一个失败设计，很多公司明确要求不能使用 <code>auto_ptr</code></p>
<h2 id="function"><a href="#function" class="headerlink" title="function "></a><a href="#context.33">function</a><a name="section.33"> </a></h2><p>类似c的函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;<span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();<span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;;<span class="comment">//lambda表达式</span></span><br></pre></td></tr></table></figure>







<h2 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype &#x2F; auto "></a><a href="#context.34">decltype &#x2F; auto</a><a name="section.34"> </a></h2><p><strong>decltype 作用：</strong>用来<strong>推导表达式类型</strong>的关键字，用来在编译时期进行自动类型推导</p>
<p>与 <code>auto</code> 的区别：</p>
<p>auto 根据 &#x3D; 右边的初始值推导出变量的类型，decltype 根据 exp 表达式推导出变量的类型，跟 &#x3D; 右边的 value 没有关系；<br>auto 要求变量必须初始化，因为 auto 是根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导；<br>而 decltype 不要求，可不用赋值</p>
<p><strong>decltype  的几种形式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;            <span class="comment">// y -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">0</span>;        <span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// *p -&gt; const int, p -&gt; const int*</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *m = &amp;z;          <span class="comment">// *m -&gt; int, m -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(m)* n = &amp;m;          <span class="comment">// *n -&gt; int*, n -&gt; int**</span></span><br></pre></td></tr></table></figure>



<p><strong>推导规则</strong></p>
<ol>
<li><p>如果 <code>exp</code> 是一个不被括号<code>()</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，<code>decltype(exp)</code> 的类型和 <code>exp</code> 一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> A::total = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">decltype</span>(n) x = n;           <span class="comment">// n 为 int，x 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(r) y = n;           <span class="comment">// r 为 const int &amp;，y 被推导为 const int &amp;</span></span><br><span class="line">	<span class="keyword">decltype</span>(A::total)  z = <span class="number">0</span>;   <span class="comment">// total 是类 A 的一个 int 类型的成员变量，z 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(A.name) url = <span class="string">&quot;www.baidu.com&quot;</span>; <span class="comment">// url 为 string 类型</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是函数调用，则 <code>decltype(exp)</code> 的类型就和函数返回值的类型一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;   <span class="comment">// 函数返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;       <span class="comment">// 函数返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">double</span>)</span></span>;       <span class="comment">// 函数返回值为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func4</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">// 函数返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func5</span><span class="params">(<span class="type">void</span>)</span></span>;          <span class="comment">// 函数返回值为 const int&amp;&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func1</span>(<span class="number">100</span>,<span class="string">&#x27;A&#x27;</span>)) a = n; <span class="comment">// a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func2</span>()) b = <span class="number">0</span>;        <span class="comment">// b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func3</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;    <span class="comment">// c 的类型为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func4</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) x = n;    <span class="comment">// x 的类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func5</span>()) y = <span class="number">0</span>;         <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是一个左值，或被括号<code>()</code>包围，<code>decltype(exp)</code> 的类型就是 <code>exp</code> 的引用，假设 <code>exp</code> 的类型为 <code>T</code>，则 <code>decltype(exp)</code> 的类型为 <code>T&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> A obj;</span><br><span class="line">	<span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;   <span class="comment">// a 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>((obj.x)) b = a; <span class="comment">// b 的类型为 int&amp;</span></span><br><span class="line">	 </span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(m + n) c = <span class="number">0</span>;     <span class="comment">// n + m 得到一个右值，c 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(n = n + m) d = c; <span class="comment">// n = n + m 得到一个左值，d 的类型为 int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左值：表达式执行结束后依然存在的数据，即持久性数据；右值是指那些在表达式执行结束不再存在的数据，即临时性数据。一个区分的简单方法是：对表达式取地址，如果编译器不报错就是左值，否则为右值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>类的静态成员可以使用 <code>auto</code>， 对于类的非静态成员无法使用 <code>auto</code>，如果想推导类的非静态成员的类型，只能使用 <code>decltype</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">   <span class="keyword">decltype</span>(T.<span class="built_in">begin</span>()) m_it;</span><br><span class="line">   <span class="comment">// typename T::iterator m_it;   // 这种用法会出错</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	   m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	A&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">	obj.<span class="built_in">func</span>(v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2023/07/27/C/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">快速判断是否是字母</a><a name="context.1"> </a></li>
<li><a href="#section.2">快速判断两字符是否相同且为字母</a><a name="context.2"> </a></li>
<li><a href="#section.3">C 关键字</a><a name="context.3"> </a><ul>
<li><a href="#section.4">free&#x2F;malloc</a><a name="context.4"> </a></li>
<li><a href="#section.5">float&#x2F;double</a><a name="context.5"> </a></li>
<li><a href="#section.6">union&#x2F;volatile</a><a name="context.6"> </a></li>
</ul>
</li>
</ul>
<hr>
<p><strong>c语言宏 <code>__stdcall</code>, <code>__cdecl</code></strong></p>
<p>​		调用函数时，计算机常用栈来存放函数执行需要的参数，由于栈的空间大小是有限的，在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示overflow。</p>
<p>​		在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的！</p>
<p>​		VC中默认调用是 <code>__cdecl</code> 方式，Windows API 使用 <code>__stdcall</code> 调用方式，在 DLL 导出函数中，为了跟 Windows API 保持一致，建议使用 <code>__stdcall</code> 方式。</p>
<p>C&#x2F;C++ 函数调用约定，主要是对以下两个方面进行了约定：</p>
<ol>
<li>当参数个数多于一个时，按照什么顺序把参数压入堆栈。—-调用函数时，参数的入栈顺序。</li>
<li>函数调用后，由谁来把堆栈恢复原状。—-调用结束后，由谁（调用者还是被调用者）负责将参数出栈。</li>
</ol>
<p>在高级语言中，就是通过函数的调用方式来说明这两个问题的。常见的调用方式有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C 语言:   __cdecl、__stdcall、__fastcall、naked、__pascal。</span><br><span class="line">C++ 语言: __cdecl、__stdcall、__fastcall、naked、__pascal、__thiscall，比 C 语言多出一种 __thiscall 调用方式。</span><br></pre></td></tr></table></figure>



<ol>
<li><p>stdcall<br><code>__stdcall</code> 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C&#x2F;C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。<br>其声明语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int _stdcall function(int a, int b);</span><br></pre></td></tr></table></figure>

<p>stdcall的调用方式意味着：</p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由被调用函数自己来恢复堆栈，称为自动清栈。<br>（3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。</p>
</li>
<li><p>cdecl</p>
<p><code>__cdecl</code> 是C Declaration的缩写（declaration，声明），cdecl调用方式又称为C调用方式，是C语言缺省的调用方式。<br>其声明语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int function(int a, int b);        // 不加修饰符就是C调用方式</span><br><span class="line">int _cdecl function(int a, int b); // 明确指定用C调用方式</span><br></pre></td></tr></table></figure>

<p>cdecl的调用方式意味着：</p>
<p>（1）参数从右向左依次压入堆栈.<br>（2）由调用者恢复堆栈，称为手动清栈。<br>（3）函数名自动加前导下划线。</p>
<p>由于是由调用者来恢复堆栈，因此C调用方式允许函数的参数个数是不固定的，这是C语言的一大特色。比如 <code>printf</code></p>
</li>
</ol>
<h2 id="快速判断是否是字母"><a href="#快速判断是否是字母" class="headerlink" title="快速判断是否是字母 "></a><a href="#context.1">快速判断是否是字母</a><a name="section.1"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 包括大小写字母</span><br><span class="line">(uchar)((ch | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<h2 id="快速判断两字符是否相同且为字母"><a href="#快速判断两字符是否相同且为字母" class="headerlink" title="快速判断两字符是否相同且为字母 "></a><a href="#context.2">快速判断两字符是否相同且为字母</a><a name="section.2"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((ch = ch1 ^ ch2) == <span class="number">0</span>) || (ch == <span class="number">0x20</span>) &amp;&amp; ((<span class="type">unsigned</span>)(ch1 | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<p>bit -&gt; Byte -&gt; kb	1Byte &#x3D; 8bit</p>
<p>bit比特位	byte字节	且内存中一个空间占一个字节&#x3D;8位</p>
<p><strong>负数在内存中存储的是补码，求原码-1然后除符号位其余取反</strong></p>
<p><strong>且任何数字在内存中都是以补码存储的，正数原反补都一样</strong></p>
<h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C 关键字 "></a><a href="#context.3">C 关键字</a><a name="section.3"> </a></h2><table>
<thead>
<tr>
<th><strong>auto</strong></th>
<th><strong>break</strong></th>
<th><strong>case</strong></th>
<th><strong>char</strong></th>
<th><strong>const</strong></th>
<th><strong>continue</strong></th>
<th><strong>default</strong></th>
<th><strong>do</strong></th>
<th><strong>double</strong></th>
<th><strong>else</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>enum</strong></td>
<td><strong>extern</strong></td>
<td><strong>float</strong></td>
<td><strong>for</strong></td>
<td><strong>goto</strong></td>
<td><strong>if</strong></td>
<td><strong>int</strong></td>
<td><strong>long</strong></td>
<td><strong>register</strong></td>
<td><strong>return</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>signed</strong></td>
<td><strong>sizeof</strong></td>
<td><strong>static</strong></td>
<td><strong>struct</strong></td>
<td><strong>switch</strong></td>
<td><strong>typedef</strong></td>
<td><strong>union</strong></td>
<td><strong>unsigned</strong></td>
<td><strong>void</strong></td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td><strong>while</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>typedef</strong> unsigned int uint		把unsigned int重定义为unit</p>
<p><strong>void</strong>							声明函数无返回值或无参数</p>
<p><strong>auto</strong>							在局部中自动销毁原变量值</p>
<p><strong>static</strong> 						静态局部变量，不会销毁，保存赋值</p>
<p><strong>const</strong> <strong>x</strong>						定义常量x，不可改变</p>
<p><strong>extern</strong>						声明外部-变量&#x2F;函数</p>
<p><strong>#define</strong> a 100					定义常量和宏，可以是三目运算符</p>
<table>
<thead>
<tr>
<th>Char</th>
<th>Short</th>
<th>Int</th>
<th>long</th>
<th>long long</th>
<th>folat</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>短整型</td>
<td>整型</td>
<td>长整型</td>
<td>超长整型</td>
<td>浮点型</td>
<td>双精度浮点型</td>
</tr>
<tr>
<td>1字节</td>
<td>2字节&#x2F;16位</td>
<td>4字节&#x2F;32位</td>
<td>4字节</td>
<td></td>
<td>4&#x2F;8字节</td>
<td>64位保留后6位</td>
</tr>
</tbody></table>
<p>a&lt;&lt;2			a左移2位</p>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>|</th>
<th>^</th>
<th>!</th>
<th>~</th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td>按位或</td>
<td>异或</td>
<td>非</td>
<td>按位取反</td>
</tr>
<tr>
<td>a&amp;&amp;b（逻辑与）</td>
<td>||</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a, b均为真返回真</td>
<td>逻辑或,有一个返回真</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>%c			打印一个字符串格式的数据</p>
<p>%s			打印字符串</p>
<p>%d			整型十进制数据</p>
<p>%u			无符号的十进制整数</p>
<p>%f			浮点型</p>
<p>%g			浮点，不显示无意义的0</p>
<p>%lf			双精度浮点型</p>
<p>%p			指针，以地址的形式打印</p>
<p>%x			打印十六进制</p>
<p>%o			输出八进制数</p>
<p>%%			‘%’</p>
<p>float</p>
<p>(-1)^s * M * 2^E		s&#x3D;0&#x2F;1	E&#x3D;n(8位,得加127)		M&#x3D;1.?? (23位1.省略)	</p>
<p>​					S	E(8&#x2F;11bit)	M(23&#x2F;52bit)</p>
<p>double				同上，E(加减1023)</p>
<p>整型转换(小转整int)</p>
<p>算数转换(小转大)</p>
<p>​	long double</p>
<p>double</p>
<p>​	float</p>
<p>​	unsigned long int</p>
<p>​	long int</p>
<p>​	unsigned int</p>
<p>​	int</p>
<p>&gt;&gt;			右移（除2），补符号位			左移补0,其他同</p>
<p>exp ? a : b	exp为真则返回a，否则返回b</p>
<p>do{循环语句}</p>
<p>while(判断);</p>
<p>b &#x3D; a++		后置++表示先把a给b，a自己在++</p>
<p>​			前置相反</p>
<p>函数</p>
<p>scanf(“%d”, &amp;n)		获得输入给n</p>
<p>printf(“%d”, n)			打印n</p>
<p>sizeof(char)			看char的长度，单位：byte字节</p>
<p>​					sizeof(数组名) &#x2F; &amp;数组名à表整个数组，其余均表地址</p>
<p>qsort()</p>
<p>strcat(1,2)			把字符串2加到1后面</p>
<p>assert(?)				<strong>断言</strong>，如果?为假则报错，否则继续运行</p>
<p>strcmp(1,2)			逐个比较字符串大小(ASCII)，1&gt;2返回正数，1&#x3D;2返回0，同</p>
<p>strncmp()				同上，比较前n位</p>
<p>strtok(arr,p)			arr,p为指针，在arr中按p切割</p>
<p>定义常量</p>
<p>const int n &#x3D; 4			定义常变量，不能改变</p>
<p>#define n 10			define定义的标识符常量</p>
<p>enum n				枚举常量</p>
<p>{a, b, c}			abc分别对应012</p>
<p>转义符：</p>
<p>\0		在字符串里表到这结束</p>
<p>​	\ddd		ddd表示1-3个八进制的数字，如：\130 表X</p>
<p>​	\xdd		dd表2个十六进制数字，\x30 表0</p>
<table>
<thead>
<tr>
<th>C</th>
<th></th>
<th></th>
<th></th>
<th>Python</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>scanf(“%d”, &amp;a)</td>
<td></td>
<td></td>
<td>输入</td>
<td>input()</td>
<td></td>
</tr>
<tr>
<td>getchar()</td>
<td>获得输入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数组数组名为地址</td>
<td>char arr[] &#x3D; {‘x1’, ‘’…, 0}</td>
<td>0必加</td>
<td></td>
<td>列表</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>char arr[ ][n]</td>
<td>列不可省略</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>字符串长度</td>
<td>strlen()</td>
<td></td>
<td></td>
<td>字符串长度</td>
<td>len(x)</td>
<td></td>
</tr>
<tr>
<td>if ()</td>
<td></td>
<td></td>
<td></td>
<td>if …:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>需要定义变量</td>
<td></td>
<td></td>
<td></td>
<td>不需要定义变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数</td>
<td>int Function(x ,y) {}</td>
<td></td>
<td></td>
<td></td>
<td>def function: {}</td>
<td></td>
</tr>
<tr>
<td>结构体</td>
<td>struct Name{}</td>
<td></td>
<td></td>
<td>类</td>
<td>Class</td>
<td></td>
</tr>
<tr>
<td>字符串</td>
<td>不能直接给变量得用数组</td>
<td>strcpy()</td>
<td></td>
<td>字符串</td>
<td>能直接给变量</td>
<td></td>
</tr>
<tr>
<td>转换类型</td>
<td>(int)3.14</td>
<td>3.14-&gt;3</td>
<td></td>
<td>转换类型</td>
<td>int(3.14)</td>
<td></td>
</tr>
</tbody></table>
<p>switch(x)</p>
<p>{</p>
<p>​	case 1: …; break;			加break表执行完退出switch，</p>
<p>​	case 2: …;					无break表执行完后继续往下执行</p>
<p>​	case n: …;</p>
<p>​	default: …; break;			表默认情况执行default的语句</p>
<p>}</p>
<p><strong>指针</strong>		</p>
<p>数组默认传的是指针，如int arr[]; Function(arr)ßarr为指针，是arr[0]的地址</p>
<p>&amp;a&#x3D;0		取a的地址</p>
<p>int* b &#x3D; &amp;a	b为<strong>指针</strong>变量，存a的地址**,** 32位平台是4个字节，64位平台是8个字节</p>
<p>int<em>*c&#x3D;&amp;*b	int**表c指向int</em></p>
<p>*b &#x3D; 20		*为<strong>解引用操作符</strong>，把20存放进b的地址中</p>
<p>arr				首元素地址</p>
<p>&amp;arr[0]			首元素的地址</p>
<p>&amp;arr				数组的地址</p>
<p>int (*p)[10]&#x3D;&amp;a	数组指针			à去掉名字就是类型</p>
<p>int (*p)(int int)&#x3D;Add	函数指针</p>
<p><strong>结构体</strong></p>
<p>(typedef)struct Book		&#x2F;&#x2F;加typedef则下面a为类型，如a s,定义了s结构体</p>
<p>{</p>
<p>​	char name[20];</p>
<p>​	short price;</p>
<p>}à(a)s1,s2;		&#x2F;&#x2F;s1,s2为同Book的全局变量(python的class)</p>
<p>struct Book n1 &#x3D; {“xxx”, 55};</p>
<p>struct Book* pc &#x3D; &amp;n1			&#x2F;&#x2F;定义指针为pc，存结构体n1</p>
<p>printf(“%s”, pc-&gt;name)			&#x2F;&#x2F;打印name，-&gt;表指向，即取该地址的name</p>
<p>srtcpy(n1.name, “new”)			&#x2F;&#x2F;想改name用字符串拷贝，把new给name</p>
<p><strong>结构体内存对齐</strong></p>
<p>​		对齐到本身对齐数整数倍的地址处（参考上一个）</p>
<p>总大小为最大对齐数的整数倍</p>
<p>（嵌套结构体，按最大的字节算）</p>
<p># 数组随下表增长，地址从低到高变化</p>
<p># 栈区地址从高到低存</p>
<p>栈区à		局部变量</p>
<p>​			函数的形式参数</p>
<p>​			函数调用也开辟空间</p>
<p>堆区à		动态内存分配</p>
<p>​			Malloc&#x2F;free</p>
<p>​			Realloc</p>
<p>​			calloc</p>
<p>静态区à		全局变量</p>
<p>​			静态变量	static</p>
<p><strong>枚举</strong></p>
<p><strong>enum Color</strong></p>
<p><strong>{</strong></p>
<p>​	<strong>RED,</strong>		&#x2F;&#x2F;序号为0，也可以赋值</p>
<p>​	<strong>…</strong></p>
<p><strong>}</strong></p>
<p><strong>数据内存存储模式（</strong>以字节为单位<strong>）</strong></p>
<p>1.小端		数据低位存内存低位		内存地址：低à高（左低右高）</p>
<p>2.大端		数据低位存内存高位		数据：高à低（左高右低）如二进制数</p>
<p><em>*<em>划重点！！*<strong><strong>à</strong>	<strong>Keil，C51为大端</strong>		<strong>X86为小端</strong></strong>，很多</em>*</em><em>ARM,DSP也为小端，有些ARM可选</em>*</p>
<p><strong>C语言</strong> à 编译    +    连接</p>
<p>​	编译生成目标文件		目标文件经过链接器，链接库处理，生成可执行文件</p>
<p>汇编 à 二进制</p>
<p><strong>预处理符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__FILE__				返回文件名+路径</span><br><span class="line"></span><br><span class="line">__LINE__				返回所在行数</span><br><span class="line"></span><br><span class="line">__DATE__			返回当今日期</span><br><span class="line"></span><br><span class="line">__TIME__			返回当前时间</span><br></pre></td></tr></table></figure>

<p><strong>文件处理</strong></p>
<p>FILE* pf &#x3D; fopen(“log.txt”, “w”)			以只读打开&#x2F;创建文件</p>
<p>fprintf(pf, “file:%s	line:%d	date:%s	time:%s	i&#x3D;%d\n”,</p>
<p><strong>FILE</strong>, <strong>LINE</strong>, <strong>DATE</strong>, <strong>TIME</strong>, i)			以格式化写文件</p>
<p>fclose(pf)				关闭文件</p>
<p>pf &#x3D; NULL				指针清空</p>
<p><strong>运算效率</strong></p>
<p>移位 &gt; 赋值 &gt; 大小比较 &gt; 加法 &gt; 减法 &gt; 乘法 &gt; 取模 &gt; 除法</p>
<p><strong>回调函数详述</strong></p>
<p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="free-malloc"><a href="#free-malloc" class="headerlink" title="free&#x2F;malloc "></a><a href="#context.4">free&#x2F;malloc</a><a name="section.4"> </a></h3><p>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</p>
<p>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小</p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了</p>
<h3 id="float-double"><a href="#float-double" class="headerlink" title="float&#x2F;double "></a><a href="#context.5">float&#x2F;double</a><a name="section.5"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/float.png" alt="img"></p>
<ul>
<li><em>符号位</em>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li><em>指数位</em>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<strong>指数位的长度越长则数值的表达范围就越大</strong>；</li>
<li><em>尾数位</em>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<strong>尾数的长度决定了这个数的精度</strong>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161639261.png" alt="img"></p>
<p><strong>把小数点，移动到第一个有效数字后面</strong>，即将 1010.101 右移 <code>3</code> 位成 <code>1.010101</code>，右移 3 位就代表 +3，左移 3 位就是 -3。</p>
<p><strong>float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了</strong>，即指数位这 8 位存的是 <code>10000010</code>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p>
<p><code>1.010101</code> 这个数的<strong>小数点右侧的数字就是 float 里的「尾数位」</strong>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <code>01010100000000000000000</code>。</p>
<p>这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<strong>既然这一位永远都是 1，那就可以不用存起来了</strong>。</p>
<p>于是就让 23 位尾数只存储小数部分，然后在计算时会<strong>自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点</strong>。</p>
<p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640274.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640766.png" alt="img"></p>
<p><strong>TIPS:</strong></p>
<blockquote>
<p><strong>为什么负数要用补码表示？</strong></p>
</blockquote>
<p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。</p>
<blockquote>
<p><strong>十进制小数怎么转成二进制？</strong></p>
</blockquote>
<p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p>
<blockquote>
<p><strong>计算机是怎么存小数的？</strong></p>
</blockquote>
<p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：</p>
<ul>
<li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li>
<li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</p>
<blockquote>
<p><strong>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</strong></p>
</blockquote>
<p>不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p>
<p>因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p>
<p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>
<h3 id="union-volatile"><a href="#union-volatile" class="headerlink" title="union&#x2F;volatile "></a><a href="#context.6">union&#x2F;volatile</a><a name="section.6"> </a></h3><p><strong>union</strong></p>
<p>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。其占内存为最大成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line"><span class="comment">// sizeof(data) 为 sizeof(double) = 8</span></span><br></pre></td></tr></table></figure>



<p><strong>volatile</strong></p>
<p>修饰异变的参数，每次都要去寄存器或内存重新读取</p>
<p>只要变量可能被意外的修改，就需要把该变量声明为volatile。在实际应用中，只有三种类型数据可能被修改：</p>
<ul>
<li>外设寄存器地址映射</li>
<li>在中断服务程序中修改全局变量</li>
<li>在多线程、多任务应用中，全局变量被多个任务读写</li>
</ul>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/07/27/DS/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">二叉树</a><a name="context.1"> </a><ul>
<li><a href="#section.2">遍历方式</a><a name="context.2"> </a><ul>
<li><a href="#section.3">深度优先DFS（Depth First Search）</a><a name="context.3"> </a></li>
<li><a href="#section.4">广度优先BFS（Breath First Search）</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">分类</a><a name="context.5"> </a></li>
</ul>
</li>
<li><a href="#section.6">二叉搜索树（BST）</a><a name="context.6"> </a></li>
<li><a href="#section.7">AVL树（BBT）</a><a name="context.7"> </a><ul>
<li><a href="#section.8">定义</a><a name="context.8"> </a></li>
<li><a href="#section.9">使用场景</a><a name="context.9"> </a></li>
<li><a href="#section.10">插入</a><a name="context.10"> </a><ul>
<li><a href="#section.11">1.左左型右旋</a><a name="context.11"> </a></li>
<li><a href="#section.12">2.左右型的左右旋</a><a name="context.12"> </a></li>
<li><a href="#section.13">3.右右型左旋</a><a name="context.13"> </a></li>
<li><a href="#section.14">4.右左型右左旋</a><a name="context.14"> </a></li>
</ul>
</li>
<li><a href="#section.15">总结</a><a name="context.15"> </a></li>
</ul>
</li>
<li><a href="#section.16">红黑树</a><a name="context.16"> </a><ul>
<li><a href="#section.17">定义</a><a name="context.17"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树 "></a><a href="#context.1">二叉树</a><a name="section.1"> </a></h2><p>为<strong>有序树</strong>：</p>
<p>如果结点的各子树从左到右是有次序的、不能颠倒，则为有序树，否则为无序树。对于有序树的孩子来说，最左边的孩子称为第一个孩子，最右边的孩子称为最后一个孩子。</p>
<p>比如，如果树T1是一个有序树，则其根结点的第一个孩子为结点B，最后一个孩子为结点D</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式 "></a><a href="#context.2">遍历方式</a><a name="section.2"> </a></h3><h4 id="深度优先DFS（Depth-First-Search）"><a href="#深度优先DFS（Depth-First-Search）" class="headerlink" title="深度优先DFS（Depth First Search） "></a><a href="#context.3">深度优先DFS（Depth First Search）</a><a name="section.3"> </a></h4><p>递归遍历 - 函数递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///&lt; 中左右</span></span><br><span class="line">        cout &lt;&lt; tree-&gt;val &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTree</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Recur</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统一遍历方法！！！ */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>迭代遍历 - stack + while</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先BFS（Breath-First-Search）"><a href="#广度优先BFS（Breath-First-Search）" class="headerlink" title="广度优先BFS（Breath First Search） "></a><a href="#context.4">广度优先BFS（Breath First Search）</a><a name="section.4"> </a></h4><p>层序遍历 - 队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 迭代法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="分类"><a href="#分类" class="headerlink" title="分类 "></a><a href="#context.5">分类</a><a name="section.5"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230719102948357.png" alt="image-20230719102948357"></p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>



<p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST） "></a><a href="#context.6">二叉搜索树（BST）</a><a name="section.6"> </a></h2><p>也称<strong>二叉查找树 BST（Binary Search Tree）</strong></p>
<p>二叉搜索树的<strong>重要特质</strong>为，<strong>在二叉树的基础上增加了左子树的所有值应都小于根节点的值，右子树的所有值应都大于根节点的值</strong>。</p>
<p>乍看二叉搜索树的访问效率很高，最大的遍历次数为树的高度，最小的遍历次数为1。但实际存在某种特殊情况，比如根节点只有一个右孩子，然后剩下的全部元素为一条直线向下排列在左子树，造成分部不均匀，查找和插入效率几乎等同于线性结构。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230717160027885.png" alt="image-20230717160027885"></p>
<p>力扣参考题目：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>、<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不同的二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                g[i] += g[j - <span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 验证二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recur</span><span class="params">(TreeNode *tree, <span class="type">long</span> min, <span class="type">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!tree)</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &lt;= min || tree-&gt;val &gt;= max)</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = <span class="built_in">Recur</span>(tree-&gt;left, min, tree-&gt;val) &amp;&amp; <span class="built_in">Recur</span>(tree-&gt;right, tree-&gt;val, max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="AVL树（BBT）"><a href="#AVL树（BBT）" class="headerlink" title="AVL树（BBT） "></a><a href="#context.7">AVL树（BBT）</a><a name="section.7"> </a></h2><p><strong>平衡二叉树</strong>全称叫做 平衡二叉搜索（排序）树，简称 AVL树。英文：Balanced Binary Tree （BBT）</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.8">定义</a><a name="section.8"> </a></h3><p>AVL树本质上是一颗二叉搜索树，但它又具有以下特点：</p>
<ol>
<li>它是一颗空树或它的左右两个子树的高度差的绝对值不超过 1</li>
<li>左右两个子树也是一颗平衡二叉树</li>
</ol>
<p><strong>需满足以下特征：</strong></p>
<ol>
<li>对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li>
<li>对于AVL树而言，其中任何子树仍然是AVL树；</li>
<li>每个节点的左右子节点的高度之差的绝对值最多为1；</li>
</ol>
<p><strong>平衡因子（BF -  Balance Factor） &#x3D; 左子树的深度 - 右子树的深度</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景 "></a><a href="#context.9">使用场景</a><a name="section.9"> </a></h3><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;&#x3D; 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p>
<p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是增加删除频繁的场景。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入 "></a><a href="#context.10">插入</a><a name="section.10"> </a></h3><h4 id="1-左左型右旋"><a href="#1-左左型右旋" class="headerlink" title="1.左左型右旋 "></a><a href="#context.11">1.左左型右旋</a><a name="section.11"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718152017647.png" alt="image-20230718152017647"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左左型</strong> ，我们应该进行右旋转。</p>
<h4 id="2-左右型的左右旋"><a href="#2-左右型的左右旋" class="headerlink" title="2.左右型的左右旋 "></a><a href="#context.12">2.左右型的左右旋</a><a name="section.12"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718152120654.png" alt="image-20230718152120654"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左右型</strong> ，我们应该进行左右旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154009644.png" alt="image-20230718154009644"></p>
<h4 id="3-右右型左旋"><a href="#3-右右型左旋" class="headerlink" title="3.右右型左旋 "></a><a href="#context.13">3.右右型左旋</a><a name="section.13"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154115097.png" alt="image-20230718154115097"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右右型</strong> ，我们应该进行左旋转。</p>
<h4 id="4-右左型右左旋"><a href="#4-右左型右左旋" class="headerlink" title="4.右左型右左旋 "></a><a href="#context.14">4.右左型右左旋</a><a name="section.14"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154205.png" alt="image-20230718154205"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右左型</strong> ，我们应该进行右左旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154226276.png" alt="image-20230718154226276"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结 "></a><a href="#context.15">总结</a><a name="section.15"> </a></h3><table>
<thead>
<tr>
<th>插入位置</th>
<th>状态</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>在结点T的左结点（L）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>左左型</td>
<td>右旋</td>
</tr>
<tr>
<td>在结点T的左结点（L）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>左右型</td>
<td>左右旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>右右型</td>
<td>左旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>右左型</td>
<td>右左旋</td>
</tr>
</tbody></table>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树 "></a><a href="#context.16">红黑树</a><a name="section.16"> </a></h2><p>红黑树（RBT）继承了AVL可自平衡的优点，</p>
<p>同时, 红黑树（RBT）在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除频繁</strong>的场景。</p>
<p>在实际应用中，红黑树的使用要多得多。</p>
<p><strong>查找插入删除的时间复杂度为 O(logN)</strong></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 "></a><a href="#context.17">定义</a><a name="section.17"> </a></h3><p><strong>需满足以下特征：</strong></p>
<ol>
<li>节点非黑即红</li>
<li>根节点一定是黑色</li>
<li>叶子节点（NIL）一定是黑色</li>
<li>每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li>
</ol>
<p><strong>注：默认插入节点颜色为红色</strong></p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS</title>
    <url>/2023/08/18/FreeRTOS/</url>
    <content><![CDATA[<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">第11章 - 移植FreeRTOS到STM32</a><a name="context.1"> </a></li>
<li><a href="#section.2">第12章 - 任务</a><a name="context.2"> </a><ul>
<li><a href="#section.3">静态创建示例</a><a name="context.3"> </a></li>
<li><a href="#section.4">动态创建示例</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">第13章 - FreeRTOS 的启动流程</a><a name="context.5"> </a></li>
<li><a href="#section.6">第14章 - 任务管理</a><a name="context.6"> </a><ul>
<li><a href="#section.7">任务迁移图</a><a name="context.7"> </a></li>
<li><a href="#section.8">任务函数</a><a name="context.8"> </a></li>
<li><a href="#section.9">任务设计要点</a><a name="context.9"> </a></li>
<li><a href="#section.10">互斥量</a><a name="context.10"> </a></li>
</ul>
</li>
<li><a href="#section.11">第15章 - 消息队列</a><a name="context.11"> </a><ul>
<li><a href="#section.12">应用场景</a><a name="context.12"> </a></li>
<li><a href="#section.13">常用函数</a><a name="context.13"> </a></li>
</ul>
</li>
<li><a href="#section.14">第16章 - 信号量</a><a name="context.14"> </a><ul>
<li><a href="#section.15">二值信号量</a><a name="context.15"> </a><ul>
<li><a href="#section.16">二值信号量与互斥量的区别</a><a name="context.16"> </a></li>
</ul>
</li>
<li><a href="#section.17">互斥信号量量</a><a name="context.17"> </a></li>
<li><a href="#section.18">计数信号量</a><a name="context.18"> </a></li>
<li><a href="#section.19">递归信号量</a><a name="context.19"> </a></li>
<li><a href="#section.20">其他函数</a><a name="context.20"> </a></li>
</ul>
</li>
<li><a href="#section.21">第17章 - 互斥量</a><a name="context.21"> </a><ul>
<li><a href="#section.22">相关函数</a><a name="context.22"> </a></li>
</ul>
</li>
<li><a href="#section.23">第18章 - 事件</a><a name="context.23"> </a><ul>
<li><a href="#section.24">事件函数</a><a name="context.24"> </a></li>
</ul>
</li>
<li><a href="#section.25">第19章 - 软件定时器</a><a name="context.25"> </a><ul>
<li><a href="#section.26">定时器函数</a><a name="context.26"> </a></li>
</ul>
</li>
<li><a href="#section.27">第20章 - 任务通知</a><a name="context.27"> </a><ul>
<li><a href="#section.28">任务通知函数</a><a name="context.28"> </a></li>
</ul>
</li>
<li><a href="#section.29">第21章 - 内存管理</a><a name="context.29"> </a><ul>
<li><a href="#section.30">内存管理接口</a><a name="context.30"> </a></li>
</ul>
</li>
<li><a href="#section.31">第22章 - 中断管理</a><a name="context.31"> </a><ul>
<li><a href="#section.32">异常分类</a><a name="context.32"> </a></li>
<li><a href="#section.33">中断</a><a name="context.33"> </a></li>
</ul>
</li>
<li><a href="#section.34">第23章 - CPU利用率</a><a name="context.34"> </a></li>
<li><a href="#section.35">FreeRTOS操作系统调度方式有哪些？</a><a name="context.35"> </a></li>
</ul>
<hr>
<h2 id="第11章-移植FreeRTOS到STM32"><a href="#第11章-移植FreeRTOS到STM32" class="headerlink" title="第11章 - 移植FreeRTOS到STM32 "></a><a href="#context.1">第11章 - 移植FreeRTOS到STM32</a><a name="section.1"> </a></h2><p>demo工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└---- demo</span><br><span class="line">      ├---- doc</span><br><span class="line">      ...</span><br><span class="line">      ├---- FreeRTOS</span><br><span class="line">      |     ├---- include		# FreeRTOS/Source/include/*</span><br><span class="line">      |     ├---- port			# FreeRTOS/Source/portable/ MemMang + RVDS</span><br><span class="line">      |     └---- src			# FreeRTOS/Source/*.c</span><br><span class="line">      └---- User</span><br><span class="line">            ...</span><br><span class="line">            ├---- FreeRTOSConfig.h		# FreeRTOS/Demo/CORTEX_STM32F103_Keil/  建议使用野火的，有注释</span><br><span class="line">            ├---- stm32f10x_conf.h</span><br><span class="line">            ├---- stm32f10x_it.c</span><br><span class="line">            ├---- stm32f10x_it.h</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<p><strong>修改 FreeRTOSConfig.h 一定要注意</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">            FreeRTOS与中断服务函数有关的配置选项                         </span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler 	PendSV_Handler		<span class="comment">///&lt; 实现需注释掉</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler 	SVC_Handler</span></span><br></pre></td></tr></table></figure>

<p>同时，将 <code>stm32f10x_it.c</code> 中的上面两个实现注释掉，并且实现 <code>systick</code>中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SysTick Handler.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">    <span class="keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_xTaskGetSchedulerState */</span>        </span></span><br><span class="line">        xPortSysTickHandler();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_xTaskGetSchedulerState */</span>        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多任务管理机制分为<strong>抢占式</strong>和<strong>协作式</strong>两种。</p>
<p>抢占式优先处理优先级高的任务，协作式等待任务主动释放后才切换任务。</p>
<h2 id="第12章-任务"><a href="#第12章-任务" class="headerlink" title="第12章 - 任务 "></a><a href="#context.2">第12章 - 任务</a><a name="section.2"> </a></h2><p>创建任务方式分为两种：</p>
<ol>
<li>静态创建<br><code>SRAM</code> 静态内存的例程中，任务控制块和任务栈的内存空间都是从内部的 <code>SRAM</code> 中分配的，具体分配到哪个地址由编译器决定。</li>
<li>动态创建<br>即，堆。其实堆也是内存，也属于 <code>SRAM</code> 。<code>FreeRTOS</code> 的做法是在 <code>SRAM</code> 中定义一个大数组（即堆内存）供 <code>FreeRTOS</code> 的动态内存分配函数使用。第一次使用会对堆初始化，在 <code>heap_x.c</code> 中实现。</li>
</ol>
<p><strong>注：FreeRTOS默认动态创建</strong></p>
<h3 id="静态创建示例"><a href="#静态创建示例" class="headerlink" title="静态创建示例 "></a><a href="#context.3">静态创建示例</a><a name="section.3"> </a></h3><p>静态创建需要自己定义栈大小等，且在 <code>FreeRTOSConfig.h</code> 中需要打开宏 <code>configSUPPORT_STATIC_ALLOCATION</code></p>
<p>还需要对栈进行8字节对齐(FreeRTOS默认8字节对齐)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             包含的头文件</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="comment">/* FreeRTOS头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开发板硬件bsp头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 任务句柄 ****************************/</span></span><br><span class="line"><span class="comment">/* 创建任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t AppTaskCreate_Handle;</span><br><span class="line"><span class="comment">/* LED 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED_Task_Handle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 全局变量申明(静态创建任务需要) ****************************/</span></span><br><span class="line"><span class="comment">/* AppTaskCreate任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t AppTaskCreate_Stack[<span class="number">128</span>];</span><br><span class="line"><span class="comment">/* LED任务栈*/</span></span><br><span class="line"><span class="type">static</span> StackType_t LED_Task_Stack[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AppTaskCreate 任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t AppTaskCreate_TCB;</span><br><span class="line"><span class="comment">/* LED_Task 任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t LED_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];</span><br><span class="line"><span class="comment">/* 定时器任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Idle_Task_TCB;</span><br><span class="line"><span class="comment">/* 定时器任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Timer_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             函数申明</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态创建任务需要 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                   StackType_t **ppxIdleTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态创建任务需要 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                    StackType_t **ppxTimerTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulTimerTaskStackSize)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************</span></span><br><span class="line"><span class="comment">* @brief 主函数</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @retval 无</span></span><br><span class="line"><span class="comment">* @note step.1 开发板硬件初始化</span></span><br><span class="line"><span class="comment">        step.2 创建APP应用任务</span></span><br><span class="line"><span class="comment">        step.3 启动FreeTROS，开始多任务调度</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 开发板硬件初始化 */</span></span><br><span class="line">    BSP_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my rtos demo\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建AppTaskCreate 任务 */</span></span><br><span class="line">    AppTaskCreate_Handle = xTaskCreateStatic((TaskFunction_t)AppTaskCreate,</span><br><span class="line">                                             (<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;AppTaskCreate&quot;</span>,</span><br><span class="line">                                             (<span class="type">uint32_t</span>)<span class="number">128</span>,</span><br><span class="line">                                             (<span class="type">void</span>*)<span class="literal">NULL</span>,</span><br><span class="line">                                             (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                                             (StackType_t*)AppTaskCreate_Stack,</span><br><span class="line">                                             (StaticTask_t*)&amp;AppTaskCreate_TCB);</span><br><span class="line">                                             </span><br><span class="line">    <span class="keyword">if</span> (AppTaskCreate_Handle != <span class="literal">NULL</span>)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        vTaskStartScheduler();  <span class="comment">///&lt; 启动任务，开启调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常情况下不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();  <span class="comment">///&lt; 进入临界区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 LED_Task 任务 */</span></span><br><span class="line">    LED_Task_Handle = xTaskCreateStatic((TaskFunction_t)LED_Task,</span><br><span class="line">                                       (<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;LED_Task&quot;</span>,</span><br><span class="line">                                       (<span class="type">uint32_t</span>)<span class="number">128</span>,</span><br><span class="line">                                       (<span class="type">void</span>*)<span class="literal">NULL</span>,</span><br><span class="line">                                       (UBaseType_t)<span class="number">4</span>,</span><br><span class="line">                                       (StackType_t*)LED_Task_Stack,</span><br><span class="line">                                       (StaticTask_t*)&amp;LED_Task_TCB);</span><br><span class="line">                                       </span><br><span class="line">    <span class="keyword">if</span> (LED_Task_Handle != <span class="literal">NULL</span>)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vTaskDelete(AppTaskCreate_Handle);  <span class="comment">///&lt; 删除 AppTaskCreate 任务</span></span><br><span class="line">    taskEXIT_CRITICAL();  <span class="comment">///&lt; 退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED3_ON;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led3_task running, LED3_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led3_task running, LED3_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * STM32中断优先级分组为4，即4位都用来表示抢占优先级，范围为0~15</span></span><br><span class="line"><span class="comment">     * 优先级只需要分组一次即可，以后如果有其他的任务需要用到中断，</span></span><br><span class="line"><span class="comment">     * 都统一用这个优先级分组，千万不要再分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* LED 初始化 */</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试硬件是否正常工作 */</span></span><br><span class="line">    LED3_ON;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串口初始化 */</span></span><br><span class="line">    USART_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                   StackType_t **ppxIdleTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *ppxIdleTaskTCBBuffer = &amp;Idle_Task_TCB;</span><br><span class="line">    *ppxIdleTaskStackBuffer = Idle_Task_Stack;</span><br><span class="line">    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                    StackType_t **ppxTimerTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulTimerTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *ppxTimerTaskTCBBuffer = &amp;Timer_Task_TCB;</span><br><span class="line">    *ppxTimerTaskStackBuffer = Timer_Task_Stack;</span><br><span class="line">    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************END OF FILE****************************/</span></span><br></pre></td></tr></table></figure>



<h3 id="动态创建示例"><a href="#动态创建示例" class="headerlink" title="动态创建示例 "></a><a href="#context.4">动态创建示例</a><a name="section.4"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             包含的头文件</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="comment">/* FreeRTOS头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开发板硬件bsp头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 任务句柄 ****************************/</span></span><br><span class="line"><span class="comment">/* 创建任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t AppTaskCreate_Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* LED1 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED1_Task_Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* LED2 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED2_Task_Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 全局变量申明 ****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             函数申明</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED2_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************</span></span><br><span class="line"><span class="comment">* @brief 主函数</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @retval 无</span></span><br><span class="line"><span class="comment">* @note step.1 开发板硬件初始化</span></span><br><span class="line"><span class="comment">        step.2 创建APP应用任务</span></span><br><span class="line"><span class="comment">        step.3 启动FreeTROS，开始多任务调度</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;  <span class="comment">///&lt; 定义一个创建信息返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开发板硬件初始化 */</span></span><br><span class="line">    BSP_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my rtos demo\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 AppTaskCreate 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)AppTaskCreate,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;AppTaskCreate&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">1</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;AppTaskCreate_Handle);</span><br><span class="line">                          </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        vTaskStartScheduler();  <span class="comment">///&lt; 启动任务，开启调度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常情况下不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;  <span class="comment">///&lt; 定义一个创建信息返回值</span></span><br><span class="line">    </span><br><span class="line">    taskENTER_CRITICAL();  <span class="comment">///&lt; 进入临界区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 LED1_Task 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)LED1_Task,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;LED1_Task&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">2</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;LED1_Task_Handle);</span><br><span class="line">                                </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 LED2_Task 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)LED2_Task,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;LED2_Task&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">3</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;LED2_Task_Handle);</span><br><span class="line">                                </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vTaskDelete(AppTaskCreate_Handle);  <span class="comment">///&lt; 删除 AppTaskCreate 任务</span></span><br><span class="line">    taskEXIT_CRITICAL();  <span class="comment">///&lt; 退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED3_ON;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led1_task running, LED3_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led1_task running, LED3_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED2_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2_ON;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led2_task running, LED2_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led2_task running, LED2_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * STM32中断优先级分组为4，即4位都用来表示抢占优先级，范围为0~15</span></span><br><span class="line"><span class="comment">     * 优先级只需要分组一次即可，以后如果有其他的任务需要用到中断，</span></span><br><span class="line"><span class="comment">     * 都统一用这个优先级分组，千万不要再分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* LED 初始化 */</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试硬件是否正常工作 */</span></span><br><span class="line">    LED3_ON;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串口初始化 */</span></span><br><span class="line">    USART_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************END OF FILE****************************/</span></span><br></pre></td></tr></table></figure>





<h2 id="第13章-FreeRTOS-的启动流程"><a href="#第13章-FreeRTOS-的启动流程" class="headerlink" title="第13章 - FreeRTOS 的启动流程 "></a><a href="#context.5">第13章 - FreeRTOS 的启动流程</a><a name="section.5"> </a></h2><p>主要有两种：</p>
<ol>
<li>万事俱备只欠东风<br>一次性创建完所有带阻塞的任务，然后直接进行任务调度</li>
<li>小心翼翼，十分谨慎<br>只创建一个任务，然后开始调度，在任务中创建其他带阻塞的任务，最后需删除初始任务</li>
</ol>
<p><strong>注：RT-Thread和FreeRTOS默认使用第二种</strong></p>
<p><strong>在临界区创建的任务会在退出临界区后按优先级排序执行！</strong></p>
<h2 id="第14章-任务管理"><a href="#第14章-任务管理" class="headerlink" title="第14章 - 任务管理 "></a><a href="#context.6">第14章 - 任务管理</a><a name="section.6"> </a></h2><p><code>freeRTOS</code> 内核采用两种方法寻找最高优先级的任务，</p>
<ol>
<li>通用方法：<br>在就绪链表中从高优先级往低优先级查找 <code>uxTopPriority</code>，因为在创建任务时已经将优先级进行排序，查找到的第一个 <code>uxTopPriority</code> 就是我们需要的任务，然后通过 <code>uxTopPriority</code> 获取对应的任务控制块。</li>
<li>特殊方法：<br>利用计算前导零指令 <code>CLZ</code>，直接在 <code>uxTopReadyPriority</code> 这个32位的变量中得出 <code>uxTopPriority</code>，这样就可以知道哪一个优先级任务能够运行，这种调度算法比普通方法更便捷，但受限于平台（在 <code>STM32</code> 中我们就使用这种方法）。</li>
</ol>
<h3 id="任务迁移图"><a href="#任务迁移图" class="headerlink" title="任务迁移图 "></a><a href="#context.7">任务迁移图</a><a name="section.7"> </a></h3><p><img src="D:\1wyh\Learning\经验书23\FreeRTOS.assets\image-20230510190415673.png" alt="image-20230510190415673"></p>
<h3 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数 "></a><a href="#context.8">任务函数</a><a name="section.8"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务挂起</span></span><br><span class="line"><span class="comment"> * @note: 挂起任务调度器（挂起所有任务），调用几次就需要恢复几次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * @note: 调用一次即可恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * @note: 同上，区别是此函数专门用在中断服务函数程序中，不能用于任务和中断间的同步!!!</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 需要进行上下文切换; pdFASLE: 不需要上下文切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">vTaskResumeFromISR</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * return pdTRUE: 需要进行上下文切换; pdFASLE: 不需要上下文切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">vTaskResumeAll</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务删除</span></span><br><span class="line"><span class="comment"> * @param xTaskToDelete: 若为 NULL 则表示删除自身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务延时（相对）</span></span><br><span class="line"><span class="comment"> * @note: 相对延时，调用结束后开始计算，不适用于周期性执行任务的场合，因为会被打断!!!</span></span><br><span class="line"><span class="comment"> * @param xTicksToDelay: 单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务延时（绝对）</span></span><br><span class="line"><span class="comment"> * @note: 绝对延时，常用于较精确的周期运行任务，不受外界影响</span></span><br><span class="line"><span class="comment"> * @param pxPreviousWakeTime: 指针变量，保存任务最后一次解除阻塞的时刻，第一次使用时必须为当前时间!</span></span><br><span class="line"><span class="comment"> * @param xTimeIncrement: 周期循环时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">(TickType_T * <span class="type">const</span> pxPreviousWakeTime, </span></span><br><span class="line"><span class="params">                     <span class="type">const</span> TickType_t   xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>



<h3 id="任务设计要点"><a href="#任务设计要点" class="headerlink" title="任务设计要点 "></a><a href="#context.9">任务设计要点</a><a name="section.9"> </a></h3><p>需要考虑任务运行的上下文环境，任务的执行时间是否合理</p>
<ol>
<li><p>中断服务函数</p>
<p>优先级最高，运行在非任务的执行环境下（一般为芯片的特殊运行模式，也称特权模式），一般只标记事件的发生，然后通知任务去处理，需要快进快出，因此不能挂起当前任务，不能调用会阻塞运行的API</p>
</li>
<li><p>普通任务<br>不允许出现死循环（无阻塞）</p>
</li>
<li><p>空闲任务（idle任务）<br>FreeRTOS需要保证至少有一个任务在运行，因此这是唯一一个不允许出现阻塞的任务</p>
</li>
<li><p>任务的执行时间<br>指两方面，一是任务从开始到结束的时间；二是任务的周期<br>设计时，必须考虑任务的时间，一般来说处理时间更短的任务，其优先级应设置得更高一些。</p>
</li>
</ol>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量 "></a><a href="#context.10">互斥量</a><a name="section.10"> </a></h3><p>互斥量是二值信号量的特殊形式 (它也是通过 Queue 实现)，与二值信号量不同，互斥量用于控制多个任务之间共享资源的访问，也就是互锁；</p>
<p>不同于上面两种，互斥量不但开放了中断，同时也不挂起调度器；</p>
<p>注：<strong>互斥量具有优先级继承机制！！！</strong>使用互斥量，需要定义 <strong>configUSE_MUTEXES</strong> 为 1</p>
<p>如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么优先级继承能够降低优先级翻转的影响呢？举个例子，现在有任务A、任务B和任务C，三个任务的优先级顺序为任务C&gt;任务B&gt;任务A。任务A和任务C都要使用某一个硬件资源，并且当前任务A占有该资源。</span><br><span class="line"></span><br><span class="line">先看没有优先级继承的情况：任务C也要使用该资源，但是此时任务A正在使用这个资源，因此任务C进入阻塞，此时三个任务的优先级顺序没有发生变化。在任务C进入阻塞之后，某硬件产生了一次中断，唤醒了一个事件，该事件可以解除任务B的阻塞状态。在中断结束后，因为任务B的优先级是大于任务A的，所以任务B抢占任务A的CPU权限。那么任务C的阻塞时间就至少为：中断处理时间+任务B的运行时间+任务A的运行时间。</span><br><span class="line"></span><br><span class="line">再看有优先级继承的情况：任务C也要使用该资源，但是此时任务A正在使用这个资源，因此任务C进入阻塞，此时由于优先级A会继承任务C的优先级，三个任务的优先级顺序发生了变化，新的优先级顺序为：任务C=任务A&gt;任务B。在任务C进入阻塞之后，某硬件产生了一次中断，唤醒了一个事件，该事件可以解除任务B的阻塞状态。在中断结束后，因为任务A的优先级临时被提高，大于任务B的优先级，所以任务A继续获得CPU权限。任务A完成后，处于高优先级的任务C会接管CPU。所以任务C的阻塞时间为：中断处理时间+任务A的运行时间。看，任务C的阻塞时间变小了，这就是优先级继承的优势。</span><br></pre></td></tr></table></figure>





<h2 id="第15章-消息队列"><a href="#第15章-消息队列" class="headerlink" title="第15章 - 消息队列 "></a><a href="#context.11">第15章 - 消息队列</a><a name="section.11"> </a></h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景 "></a><a href="#context.12">应用场景</a><a name="section.12"> </a></h3><p>队列是 <code>FreeRTOS</code> 主要的任务间通信方式，读取采用先进先出（FIFO），也支持后进先出（LIFO）</p>
<p>用于 1.任务与任务间；2.中断和任务间；传送信息，通过复制的方式实现的，数据量过大时传指针。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数 "></a><a href="#context.13">常用函数</a><a name="section.13"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建队列</span></span><br><span class="line"><span class="comment"> * @param uxQueueLength: 队列能够存储的最大消息单元数目，即队列长度</span></span><br><span class="line"><span class="comment"> * @param uxItemSize: 队列中消息单元的大小、以字节为单位</span></span><br><span class="line"><span class="comment"> * @return 创建成功则返回队列句柄，用于访问创建的队列；不成功则返回NULL，可能原因是创建队列所需的RAM分配失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">(UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                           UBaseType_t uxItemSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态创建队列</span></span><br><span class="line"><span class="comment"> * @param uxQueueLength: 队列能够存储的最大单元数目，即队列深度</span></span><br><span class="line"><span class="comment"> * @param uxItemSize: 队列中数据单元的长度，以字节为单位</span></span><br><span class="line"><span class="comment"> * @param pucQueueStorageBuffer: 指针，指向一个 uint8_t 类型的数组，数组大小至少为 uxQueueLength * uxItemSize 个字节；</span></span><br><span class="line"><span class="comment"> *							     为 0 时，pxQueueBuffer 可以为NULL</span></span><br><span class="line"><span class="comment"> * @param pxQueueBuffer: 指针，指向 StaticQueue_t 类型的变量，此变量用于存储队列的数据结构</span></span><br><span class="line"><span class="comment"> * @return 创建成功则返回队列句柄，用于访问创建的队列；不成功则返回NULL，可能原因是创建队列所需的RAM分配失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(UBaseType_t   uxQueueLength,</span></span><br><span class="line"><span class="params">                                 UBaseType_t   uxItemSize,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint8_t</span>       *pucQueueStorageBuffer,</span></span><br><span class="line"><span class="params">                                 StaticQueue_t *pxQueueBuffer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除队列</span></span><br><span class="line"><span class="comment"> * @param xQueue: 所需删除的队列句柄，如果未被创建无法删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xQueueDelete</span><span class="params">(QueueHandle_t xQueue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列发送消息</span></span><br><span class="line"><span class="comment"> * @brief: 向队列尾部插入</span></span><br><span class="line"><span class="comment"> * @note: 等同于 xQueueSendToBack();</span></span><br><span class="line"><span class="comment"> * 		  不能在中断服务程序中被调用，在中断中必须使用带有中断保护功能的 xQueueSendFromISR()</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列尾部的队列消息</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                      TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列发送消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向队列尾部插入</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列尾部的队列消息</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将此设置成 pdTRUE，</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	     cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                             BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">/* demo</span></span><br><span class="line"><span class="comment">void vBufferISR(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    char cIn;</span></span><br><span class="line"><span class="comment">    BaseType_t xHighterPriorityTaskWoken;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    /* 在ISR开始时，我们并没有唤醒任务 */</span></span><br><span class="line">    xHighterPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 直到缓冲区为空 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 从缓冲区获取一个字节的数据 */</span></span><br><span class="line">        cIn = portINPUT_BTYE(RX_REGISTER_ADRESS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送这个数据 */</span></span><br><span class="line">        xQueueSendFromISR(xRxQueue, &amp;cIn, &amp;xHighterPriorityTaskWoken);</span><br><span class="line">    &#125; <span class="keyword">while</span> (portINPUT_BTYE(BUFFER_COUNT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这时 buffer 已经为空，如果需要，则进行上下文切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (xHighterPriorityTaskWoken) &#123;</span><br><span class="line">        <span class="comment">/* 上下文切换，这时一个宏，不同的处理器，具体的方法不一样 */</span></span><br><span class="line">        taskYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列头发送消息</span></span><br><span class="line"><span class="comment"> * @brief: 向队列头部插入</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列头部的消息</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	     cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                             TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列头发送消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向队列头部插入信息</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列头部的消息</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将此设置成 pdTRUE，</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	            cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                    BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息</span></span><br><span class="line"><span class="comment"> * @brief: 从一个队列中接收消息，并把接收的消息从队列中删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                         TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息</span></span><br><span class="line"><span class="comment"> * @brief: 从一个队列中接收消息，不删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                      TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中从一个队列中接收消息，并从队列中删除该消息</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 任务在向队列投递消息时，如果队列已满，则任务将阻塞在该队列上。</span></span><br><span class="line"><span class="comment"> *                                   如果导致一个任务解除阻塞，需将此设置成 pdTRUE，否则不变</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                                BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中从一个队列中接收消息，不删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 任务在向队列投递消息时，如果队列已满，则任务将阻塞在该队列上。</span></span><br><span class="line"><span class="comment"> *                                   如果导致一个任务解除阻塞，需将此设置成 pdTRUE，否则不变</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>          *pvBuffer)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第16章-信号量"><a href="#第16章-信号量" class="headerlink" title="第16章 - 信号量 "></a><a href="#context.14">第16章 - 信号量</a><a name="section.14"> </a></h2><p>信号量控制块结构体与消息队列结构体是一样的，只是某些成员参数代表含义不同。</p>
<h3 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量 "></a><a href="#context.15">二值信号量</a><a name="section.15"> </a></h3><p>既可以用于临界资源访问，也可以用于同步功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建二值信号量</span></span><br><span class="line"><span class="comment"> * @note: 创建成功后为空，需要先调用 xSemaphoreGive()，归还后才能获取</span></span><br><span class="line"><span class="comment"> *        老式函数 vSemaphoreCreateBinary() 创建的二值信号量则不用，创建后为1，可以直接获取(take)</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄，原型为 void 类型指针; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>







<h5 id="二值信号量与互斥量的区别"><a href="#二值信号量与互斥量的区别" class="headerlink" title="二值信号量与互斥量的区别 "></a><a href="#context.16">二值信号量与互斥量的区别</a><a name="section.16"> </a></h5><p>互斥量具有继承机制，二值信号没有。</p>
<p>二值信号更适合应用于同步功能（任务与任务，任务和中断）</p>
<p>互斥量更偏向应用于临街资源访问</p>
<h3 id="互斥信号量量"><a href="#互斥信号量量" class="headerlink" title="互斥信号量量 "></a><a href="#context.17">互斥信号量量</a><a name="section.17"> </a></h3><p>为特殊的二值信号量，其特有的优先级继承机制使它更适用于简单互斥锁，也就是保护临界资源。</p>
<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量 "></a><a href="#context.18">计数信号量</a><a name="section.18"> </a></h3><p>用于计数，被任务取走时（take），计数减一；归还时（give），计数加一；为0不可用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建计数信号量</span></span><br><span class="line"><span class="comment"> * @brief: 创建一个计数信号量</span></span><br><span class="line"><span class="comment"> * @param uxMaxCount: 计数信号量的最大值，当达到这个值时，信号量不能再被释放(give)</span></span><br><span class="line"><span class="comment"> * @param uxInitialCount: 创建计数信号量的初始值(一般为uxMaxCount)</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                           UBaseType_t uxInitialCount)</span>;</span><br></pre></td></tr></table></figure>





<h3 id="递归信号量"><a href="#递归信号量" class="headerlink" title="递归信号量 "></a><a href="#context.19">递归信号量</a><a name="section.19"> </a></h3><p>是可以重复获取调用的信号量。</p>
<p>已经获取递归互斥量的任务可以重复获取该递归互斥量，该任务拥有递归信号量的所有权。</p>
<p>注意，成功获取几次就需归返几次，在此之前递归互斥量都处于无效状态，其他任务无法获取，只有持有递归信号量的任务才能获取与释放。</p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数 "></a><a href="#context.20">其他函数</a><a name="section.20"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量删除</span></span><br><span class="line"><span class="comment"> * @brief: 删除一个信号量</span></span><br><span class="line"><span class="comment"> * @note: 如果有任务阻塞在该信号量上，不要删除</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xSemaphoreDelete</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量释放（归还）</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于释放信号量，实现为消息队列通用发送函数 xQueueGenericSend()</span></span><br><span class="line"><span class="comment"> * @note: 可用于释放 1.二值信号量 2.计数信号量 3.互斥信号量</span></span><br><span class="line"><span class="comment"> *        不能用于递归互斥量，由 xSemaphoreCreateRecursiveMutex() 创建</span></span><br><span class="line"><span class="comment"> *        不能在中断中使用！！！</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量释放（中断中归还）</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于释放信号量，带中断保护</span></span><br><span class="line"><span class="comment"> * @note: 可用于释放 1.二值信号量 2.计数信号量</span></span><br><span class="line"><span class="comment"> *        不能用于互斥信号量，因为互斥量不可在中断中使用，且互斥量的优先级继承只能在任务中起作用，在中断中毫无意义</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 因为调用此函数可能会唤醒阻塞在该信号量上的任务，</span></span><br><span class="line"><span class="comment"> *                                   如果被唤醒的优先级大于当前任务，则此为 pdTRUE，然后在中断退出前执行一次上下文切换；</span></span><br><span class="line"><span class="comment"> *                                   从 FreeRTOS V7.3.0 开始作为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: pdFALSE；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                 BaseType_t        *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量获取(拿走)</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于获取信号量，不带中断保护</span></span><br><span class="line"><span class="comment"> * @note: 可用于获取 1.二值信号量 2.计数信号量 3.互斥信号量</span></span><br><span class="line"><span class="comment"> *        不能用于递归互斥量，不能在中断中使用！！！</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 等待信号量可用的最大超时时间，单位为 tick（系统节拍周期），若为 portMAX_DELAY，则将一直阻塞</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                          TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量获取(中断中拿走)</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于中断中获取信号量，不带阻塞机制（其实很少在中断中获取信号量）</span></span><br><span class="line"><span class="comment"> * @note: 可用于获取 1.二值信号量 2.计数信号量</span></span><br><span class="line"><span class="comment"> *        不能用于互斥信号量，因为互斥量不可在中断中使用，且互斥量的优先级继承只能在任务中起作用，在中断中毫无意义</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 因为调用此函数可能会唤醒阻塞在该信号量上的任务，</span></span><br><span class="line"><span class="comment"> *                                   如果被唤醒的优先级大于当前任务，则此为 pdTRUE，然后在中断退出前执行一次上下文切换；</span></span><br><span class="line"><span class="comment"> *                                   从 FreeRTOS V7.3.0 开始作为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY, 表信号量不可用;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                 <span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取当前计数信号的可用次数</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 计数信号量句柄，二值信号量句柄</span></span><br><span class="line"><span class="comment"> * @return 如果信号量是计数信号量，则返回信号量的当前计数值 &gt;=0</span></span><br><span class="line"><span class="comment"> *         如果信号量是二值信号量，则当信号量可用时，返回 1，当信号量不可用时，返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxSemaphoreGetCount</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"><span class="comment">/* demo</span></span><br><span class="line"><span class="comment">UBaseType_t semavalue = uxSemaphoreGetCount(xCountingSemaphore);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="第17章-互斥量"><a href="#第17章-互斥量" class="headerlink" title="第17章 - 互斥量 "></a><a href="#context.21">第17章 - 互斥量</a><a name="section.21"> </a></h2><p>互斥量又称互斥信号量，是一种特殊的二值信号。互斥量和信号量的不同之处在于，它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界区资源的独占式处理。</p>
<p><strong>注：只在任务中起作用，不能用于中断服务函数中！！！</strong></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数 "></a><a href="#context.22">相关函数</a><a name="section.22"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，创建一个互斥信号量</span></span><br><span class="line"><span class="comment"> * @return 成功: 互斥量句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建递归互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @return 成功: 互斥量句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateRecursiveMutex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xSemaphoreDelete</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 互斥量获取</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                          TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归互斥量获取</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 只能获取由 xSemaphoreCreateRecursiveMutex 创建的互斥量</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 等待信号量可用的最大超时时间，单位为 tick（系统节拍周期），若为 portMAX_DELAY，则将一直阻塞</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeRecursive</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                   TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 互斥量释放</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归互斥量释放</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 只能获取由 xSemaphoreCreateRecursiveMutex 创建的互斥量</span></span><br><span class="line"><span class="comment"> *        拿走几次都需要释放几次!</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveRecursive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第18章-事件"><a href="#第18章-事件" class="headerlink" title="第18章 - 事件 "></a><a href="#context.23">第18章 - 事件</a><a name="section.23"> </a></h2><p>​		事件是一种实现任务间通信的机制，主要用于实现多任务间的同步，但<strong>事件通信只能是事件类型的通信，无数据传输</strong>。与信号量不同的是，事件可以实现一对多、多对多的同步，即一个任务可以等待多个事件的发生：1.可以是任意一个事件发生时唤醒任务进行事件处理；2.也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。</p>
<p>​		每一个事件组只需要很少的RAM空间来保存其状态。</p>
<p>​		如果宏 <code>configUSE_16_BIT_TICKS</code> 定义为1，则 <code>uxEventBits</code> 就是16位的，其中有8位来存储事件组。</p>
<p>​		否则， <code>uxEventBits</code> 就是32位的，其中有24位来存储事件组。</p>
<h3 id="事件函数"><a href="#事件函数" class="headerlink" title="事件函数 "></a><a href="#context.24">事件函数</a><a name="section.24"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件创建</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件删除</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件句柄</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xEventGroupDelete</span><span class="params">(EventGroupHandle_t xEventGroup)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件置位</span></span><br><span class="line"><span class="comment"> * @brief: 置位事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToSet: 指定事件中的事件标志位。</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x08，则只置位位3,</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x09，则置位位3和位0</span></span><br><span class="line"><span class="comment"> * @return 返回调用 xEventGroupSetBits() 时事件组中的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup, </span></span><br><span class="line"><span class="params">                               <span class="type">const</span> EventBits_t  uxBitsToSet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件置位（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断函数中，置位事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToSet: 指定事件中的事件标志位。</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x08，则只置位位3,</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x09，则置位位3和位0</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用之前必须初始化为 pdFALSE;</span></span><br><span class="line"><span class="comment"> *                                   调用会给守护任务发送一个消息，如果守护任务的优先级高于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   此参会被置为 pdTRUE，然后再中断退出前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息成功发送给守护任务; pdFALSE: 发送失败;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup, </span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> EventBits_t  uxBitsToSet,</span></span><br><span class="line"><span class="params">                                     BaseType_t         *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 等待事件</span></span><br><span class="line"><span class="comment"> * @brief: 用于获取任务感兴趣的事件</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToWaitFor: 一个按位或的值，指定需要等待事件组中的哪些位 置1</span></span><br><span class="line"><span class="comment"> * @param xClearOnExit: pdTRUE: 当等待到满足任务唤醒的事件时，系统将清除由形参 uxBitsToWaitFor 指定的事件标志位</span></span><br><span class="line"><span class="comment"> *                      pdFALSE: 不会清除由形参 uxBitsToWaitFor 指定的事件标志位</span></span><br><span class="line"><span class="comment"> * @param xWaitForAllBits: pdTRUE: 指定的标志位都置位时（事件都存在），才满足唤醒条件</span></span><br><span class="line"><span class="comment"> *                         pdFALSE: 指定的标志位任一位 置位时（事件存在一个即可），满足唤醒条件</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 最大超时时间</span></span><br><span class="line"><span class="comment"> * @return 返回事件中的哪些事件标志位被置位，返回值很可能并不是用户指定的事件位，需要对返回值进行判断后再处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(<span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t        uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t         xClearOnExit,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t         xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                TickType_t               xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除事件组指定位</span></span><br><span class="line"><span class="comment"> * @brief: 清除事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToClear: 指定事件组中的哪个位需要清除</span></span><br><span class="line"><span class="comment"> * @return 在还没有清除指定位之前事件的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t  uxBitsToClear)</span>;</span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> EventBits_t  uxBitsToClear)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第19章-软件定时器"><a href="#第19章-软件定时器" class="headerlink" title="第19章 - 软件定时器 "></a><a href="#context.25">第19章 - 软件定时器</a><a name="section.25"> </a></h2><p>​		定时器，是指从指定的时刻开始，经过一段指定的时间后触发一个超时事件，用户可以自定义定时器的周期与频率。类似生活中的闹钟，我们可以设置闹钟什么时候响，还能设置响的次数，是响一次还是每天都响。</p>
<ol>
<li>硬件定时器<br>    是芯片本身提供定时功能，一般是由外部晶振为芯片提供输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后，芯片中断控制产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</li>
<li>软件定时器<br>    利用回调函数的方式处理中断。定时精度与系统时钟的周期有关。一般系统利用 <code>SysTick</code> 作为软件定时器的基础时钟，软件定时器的回调函数类似硬件的中断服务函数，所以回调函数也需要快进快出，并且不能有任何阻塞任务运行的情况。</li>
</ol>
<p><code>FreeRTOS</code> 软件定时器功能上支持：</p>
<ol>
<li>裁剪，可通过宏关闭软件定时器功能</li>
<li>软件定时器创建</li>
<li>软件定时器启动</li>
<li>软件定时器停止</li>
<li>软件定时器复位</li>
<li>软件定时器删除</li>
<li>单次模式</li>
<li>周期模式</li>
</ol>
<p><strong>注意：软件定时器的精度是无法和硬件定时器相比的，因为软件定时器过程中有可能被其他中断所打断，这是由于软件定时器的执行上下文是任务。</strong></p>
<h3 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数 "></a><a href="#context.26">定时器函数</a><a name="section.26"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器创建</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @note: 创建成功后是休眠的</span></span><br><span class="line"><span class="comment"> * @param pcTimerName: 定时器名称</span></span><br><span class="line"><span class="comment"> * @param xTimerPeriodInTicks: 软件定时器的周期，单位为系统节拍周期(即 tick)，</span></span><br><span class="line"><span class="comment"> *                             使用 pdMS_TO_TICKS()可以把时间单位从ms转换为系统节拍周期</span></span><br><span class="line"><span class="comment"> * @param uxAutoReload: pdTRUE: 周期模式; pdFALSE: 单次模式，运行一次后就进去休眠态</span></span><br><span class="line"><span class="comment"> * @param pvTimerID: 软件定时器ID，数字形式。该ID典型的用法是当一个回调函数分配给一个或多个软件定时器时，</span></span><br><span class="line"><span class="comment"> *                   在回调函数中根据 ID 号来处理不同的软件定时器</span></span><br><span class="line"><span class="comment"> * @param pxCallbackFunction: 软件定时器的回调函数，时间到时会调用这个函数</span></span><br><span class="line"><span class="comment"> * @return 成功: 定时器句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> TickType_t   xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> UBaseType_t  uxAutoReload,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> * <span class="type">const</span>       pvTimerID,</span></span><br><span class="line"><span class="params">                           TimerCallbackFunction_t pxCallbackFunction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器启动</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @note: 宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 用户指定超时阻塞时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                      如果该值不为0，则调用该函数的任务将被锁定在阻塞态，阻塞时间为用户指定的时间，</span></span><br><span class="line"><span class="comment"> *                      直到指定的时间过去后，系统才会将启动软件定时器的命令发送出去。</span></span><br><span class="line"><span class="comment"> *                      如果在 FreeRTOS 调度器开启之前调用此函数，此参将不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: 定时器句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">(TimerHandle_t    xTimer,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器启动（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中启动一个软件定时器</span></span><br><span class="line"><span class="comment"> * @note: 宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 定时器守护任务的大部分时间都在阻塞态等待定时器命令队列的命令。</span></span><br><span class="line"><span class="comment"> *                                   调用此函数将会向定时器的命令队列发送一个启动命令，这很可能会将定时器从阻塞态移除。</span></span><br><span class="line"><span class="comment"> *                                   如果调用此函数让定时器任务脱离阻塞态，且定时器守护任务的优先级大于等于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   那么此参数的值会在函数内部设置为 pdTRUE，然后在中断退出之前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStartFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                              BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器停止</span></span><br><span class="line"><span class="comment"> * @brief: 停止一个软件定时器，让其进入休眠态</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 用户指定的超时时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                    如果在 FreeRTOS 调度器开启之前调用此函数，则此参数不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                      TickType_t    xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器停止(中断)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中停止一个软件定时器，让其进入休眠态</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 定时器守护任务的大部分时间都在阻塞态等待定时器命令队列的命令。</span></span><br><span class="line"><span class="comment"> *                                   调用此函数将会向定时器的命令队列发送一个启动命令，这很可能会将定时器从阻塞态移除。</span></span><br><span class="line"><span class="comment"> *                                   如果调用此函数让定时器任务脱离阻塞态，且定时器守护任务的优先级大于等于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   那么此参数的值会在函数内部设置为 pdTRUE，然后在中断退出之前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStopFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                             BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器删除</span></span><br><span class="line"><span class="comment"> * @brief: 删除一个已经被创建成功的软件定时器</span></span><br><span class="line"><span class="comment"> * @note: 为宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 用户指定的超时时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                    如果在 FreeRTOS 调度器开启之前调用此函数，则此参数不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                        TickType_t    xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第20章-任务通知"><a href="#第20章-任务通知" class="headerlink" title="第20章 - 任务通知 "></a><a href="#context.27">第20章 - 任务通知</a><a name="section.27"> </a></h2><p>​		<code>FreeRTOS</code> 从 <code>V8.2.0</code> 版本开始提供任务通知功能，每个任务都有一个32位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列（可以保存一个32位整数或指针值）。</p>
<p>​		使用任务通知比通过信号量等ICP通信方式接触阻塞的任务速度要快45%，并且更加省RAM内存空间（使用GCC编译器，-o2优化级别），任务通知的使用无需创建队列。</p>
<p><code>FreeRTOS</code> 提供以下几种方式发送通知给任务：</p>
<ol>
<li>如果有通知未读，则不覆盖通知值</li>
<li>直接覆盖通知值</li>
<li>设置通知值的一个或者多个位，可以当作事件组来使用</li>
<li>递增通知值，可以当作计数信号量使用</li>
</ol>
<p>注意有以下限制：</p>
<ol>
<li>只能有一个任务接收任务通知消息，因为必须指定接受通知的任务</li>
<li>只有等待通知的任务可以被阻塞，发送通知的任务在任何情况下都不会因为发送失败而进入阻塞态</li>
</ol>
<h3 id="任务通知函数"><a href="#任务通知函数" class="headerlink" title="任务通知函数 "></a><a href="#context.28">任务通知函数</a><a name="section.28"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于在任务中向指定任务发送任务通知，并更新对方的任务通知值（加1操作）</span></span><br><span class="line"><span class="comment"> * @note: 为宏函数，用于二值信号量和计数信号量</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄，并让其自身的任务通知值加一</span></span><br><span class="line"><span class="comment"> * @return 总是返回 pdPASS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">(TaskHandle_t xTaskToNotify)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中，用于在任务中向指定任务发送任务通知，并更新对方的任务通知值（加1操作）</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄，并让其自身的任务通知值加一</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskNotifyGiveFromISR</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                            BaseType_t   *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 向指定的任务发送一个任务通知，带有通知值并且用户可以指定通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @note: 指定一个通知值，和此通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见下表</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(TaskHandle_t  xTaskToNotify,</span></span><br><span class="line"><span class="params">                       <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                       eNotifyAction eAction)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>eAction取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>eNoAction</td>
<td>对象任务接受任务通知，但是任务自身的任务通知值不更新，即形参 ulValue没有用</td>
</tr>
<tr>
<td>eSetBits</td>
<td>对象任务接收任务通知，同时任务自身的任务通知值与ulValue按位或。<br />如果 ulValue 为 0x01，那么任务的通知值的位0将被置1</td>
</tr>
<tr>
<td>eIncrement</td>
<td>对象任务接受任务通知。任务自身的任务通知值加1，即形参 ulValue 没用，<br />这时调用 xTaskNotify 相当于调用 xTaskNotifyGive</td>
</tr>
<tr>
<td>eSetValueWithOverwrite</td>
<td>对象任务接收任务通知，且任务自身的任务通知值会无条件的被设置为 ulValue</td>
</tr>
<tr>
<td>eSetValueWithoutOverwrite</td>
<td>对象任务接收任务通知，且对象任务没有通知值，那么通知值就会被设置为 ulValue<br />若上次通知值没有被取走，则不更新，同时返回 pdFALSE</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向指定的任务发送一个任务通知</span></span><br><span class="line"><span class="comment"> * @note: 指定一个通知值，和此通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">(TaskHandle_t  xTaskToNotify,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                              eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                              BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 向指定的任务发送一个任务通知，并返回对象任务的上一个通知值</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pulPreviousNotifyValue: 对象任务的上一个任务通知值，如果为 NULL ，则不需要回传，这时等价于 xTaskNotify</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                              eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      *pulPreviousNotifyValue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 中断中向指定的任务发送一个任务通知，并返回对象任务的上一个通知值</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pulPreviousNotifyValue: 对象任务的上一个任务通知值，如果为 NULL ，则不需要回传，这时等价于 xTaskNotify</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryFromISR</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span>      *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                                      BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于获取一个任务通知，如获取二值信号量、计数信号量类型的任务通知</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xClearCountOnExit: 为 pdFALSE 时，此函数退出前，将任务的通知值减1，可以用来实现计数信号量</span></span><br><span class="line"><span class="comment"> *                           为 pdTRUE 时，退出前将任务通知值清0，可用来实现二值信号量</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 超时时间，单位为系统节拍周期，宏 pdMS_TO_TICKS 用于将毫秒转化为系统节拍数</span></span><br><span class="line"><span class="comment"> * @return 在任务通知值减1或者清零之前，返回任务的当前通知值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">(BaseType_t xClearCountOnExit,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全功能等待任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于等待一个任务通知，并带有超时等待</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnEntry: 表在使用通知前，将任务通知值的哪些位清零，实现是按位取反后位与</span></span><br><span class="line"><span class="comment"> *                              如果设置为 0x01，那么在进入函数前，位1会被清零</span></span><br><span class="line"><span class="comment"> *                              如果设置为 0xFFFFFFFF（ULONG_MAX），那么在进入函数前，所有位清零，表清空通知值</span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnExit: 表在函数退出前，决定任务接收到的通知值的哪些位会被清零，实现同上</span></span><br><span class="line"><span class="comment"> *                             在清零前，接收到的任务通知值会先保存到形参 *pulNotificationValue 中</span></span><br><span class="line"><span class="comment"> *                             比如为 0x03，那么在退出前，接收到的任务通知值的位0-1会被清零</span></span><br><span class="line"><span class="comment"> *                             如果设置为 0xFFFFFFFF（ULONG_MAX），那么所有位清零，表清空通知值</span></span><br><span class="line"><span class="comment"> * @param pulNotificationValue: 用于保存接收到的任务通知值，不用则设为 NULL</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 超时时间，单位为系统节拍周期，宏 pdMS_TO_TICKS 用于将毫秒转化为系统节拍数</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(<span class="type">uint32_t</span>   ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span>   ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span>   *pulNotificationValue,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第21章-内存管理"><a href="#第21章-内存管理" class="headerlink" title="第21章 - 内存管理 "></a><a href="#context.29">第21章 - 内存管理</a><a name="section.29"> </a></h2><p>​		在计算机系统中，变量、中间数据一般存放在系统存储空间中，只有在实际使用时才将它们从存储空间调入中央处理器内部进行运算。通常存储空间分为两种：1.内部存储空间（RAM）；2.外部存储空间</p>
<p>​		内部存储空间访问速度比较快，能够按照变量地址随机地访问。外部存储空间内所保存的内容相对来说比较固定，即使掉电后数据也不会丢失，可以把它理解为计算机的硬盘。</p>
<p>​		一些可靠性要求非常高的系统应该选择使用静态分配；普通业务系统可以使用动态分配，来提高内存的使用率。</p>
<p><strong>注意：嵌入式实时操作系统中，一般不调用计算机中的 <code>malloc()</code> 和 <code>free()</code></strong></p>
<p>原因如下：</p>
<ol>
<li>这些函数在小型嵌入式系统中并不总是可用的，小型嵌入式设备中的RAM不足</li>
<li>实现可能需要占用相当大的一块代码空间</li>
<li>几乎都不是安全的</li>
<li>不是确定的，每次调用这些函数执行的时间可能都不一样</li>
<li>有可能产生碎片</li>
<li>会使链接器配置的更复杂</li>
<li>如果允许堆空间的生长方向覆盖其他变量占据的内存，那么它们会成为 debug 的灾难</li>
</ol>
<h3 id="内存管理接口"><a href="#内存管理接口" class="headerlink" title="内存管理接口 "></a><a href="#context.30">内存管理接口</a><a name="section.30"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">(<span class="type">size_t</span> xSize)</span>;              <span class="comment">///&lt; 内存申请函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">(<span class="type">void</span> *pv)</span>;                      <span class="comment">///&lt; 内存释放函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortInitialiseBlocks</span><span class="params">(<span class="type">void</span>)</span>;              <span class="comment">///&lt; 初始化内存堆函数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">(<span class="type">void</span>)</span>;             <span class="comment">///&lt; 获取当前未分配的内存堆大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">///&lt; 获取未分配的内存堆历史最小值</span></span><br></pre></td></tr></table></figure>



<p><code>FreeRTOS</code> 的 <code>V 9.0.0</code> 版本提供了5中内存管理算法：</p>
<ol>
<li><p><code>heap_1.c</code></p>
<p>最简单的一个，只能申请，不能释放，申请时间是常量</p>
<p>特点：</p>
<p>（1）用于从不删除任务、队列、信号量、互斥量等的应用程序（实际上大多数使用FreeRTOS的应用程序都符合这个条件）</p>
<p>（2）函数的执行时间是确定的，并且不会产生内存碎片</p>
</li>
<li><p><code>heap_2.c</code><br>采用一种最佳匹配算法<br>特点：<br>（1）可以用于那些反复删除任务、队列、信号量等内核对象且不担心内存碎片的应用程序<br>（2）如果我们的应用程序中的队列、任务、信号量等的顺序不可预测，也有可能导致内存碎片<br>（3）具有不确定性，但是效率比标准C库中的 <code>malloc()</code> 函数高得多<br>（4）不能用于内存分配和释放是随机大小的应用程序</p>
</li>
<li><p><code>heap_3.c</code></p>
<p>简单的封装了标准C库的 <code>malloc()</code> 和 <code>free()</code> ，但具有保护功能，即操作内存前挂起调度器，完成后再恢复调度器</p>
<p>特点：</p>
<p>（1）需要链接器设置一个堆，<code>malloc()</code> 和 <code>free()</code> 由编译器提供</p>
<p>（2）具有不确定性</p>
<p>（3）很可能增大 RTOS 内核的代码大小</p>
</li>
<li><p><code>heap_4.c</code></p>
<p>与2一样，均采用最佳匹配算法来实现动态的内存分配，不一样的是此方法包含了一种合并算法，能把相邻的空闲内存块合并成一个更大的块，减少内存碎片<br>特点：</p>
<p>（1）可用于重复删除任务、队列、信号量、互斥量等的应用程序</p>
<p>（2）可用于分配和释放随机字节内存的应用程序，但并不像2那样产生严重的内存碎片</p>
<p>（3）具有不确定性，但是效率比标准C库中的 <code>malloc()</code> 函数高得多</p>
</li>
<li><p><code>heap_5.c</code><br>和4一样，但允许内存堆跨越多个非连续的内存区，也就是允许在不连续的内存堆中实现内存分配，比如在片内RAM中定义一个内存堆，还可以在外部SDRAM中再定义一个或多个内存堆，这些内存都归系统管理</p>
</li>
</ol>
<h2 id="第22章-中断管理"><a href="#第22章-中断管理" class="headerlink" title="第22章 - 中断管理 "></a><a href="#context.31">第22章 - 中断管理</a><a name="section.31"> </a></h2><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类 "></a><a href="#context.32">异常分类</a><a name="section.32"> </a></h3><ol>
<li><p>同步异常</p>
<p>由内部事件（像处理器指令运行产生的事件）引起的异常称为同步异常，例如，造成被零除的算术运算引发一个异常。</p>
</li>
<li><p>异步异常</p>
<p>主要指由外部异常源产生的异常，事件来源是外部硬件装置。例如，按下按键。</p>
</li>
</ol>
<p>区别：</p>
<p>同步异常触发后，系统必须立刻进行处理而不能依然执行原有的程序指令步骤</p>
<p>异步异常触发后，可以延缓处理甚至是忽略</p>
<p><strong>中断属于异步异常</strong></p>
<p><code>FreeRTOS</code> 的中断管理支持：</p>
<ol>
<li>开&#x2F;关中断</li>
<li>恢复中断</li>
<li>中断屏蔽</li>
<li>可选择系统管理的中断优先级</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断 "></a><a href="#context.33">中断</a><a name="section.33"> </a></h3><p>与中断相关的硬件可以划分为3类：外设、中断控制器、CPU本身</p>
<ol>
<li><p>外设</p>
<p>当外设需要请求CPU时，产生一个中断信号，该信号连接至中断控制器</p>
</li>
<li><p>中断控制器</p>
<p>是CPU众多外设中的一个，一方面接收其他外设中断信号的输入，另一方面会发出中断信号给CPU。可以通过对中断控制器编程实现对中断源的优先级、触发方式、打开和关闭源等设置操作。在 <code>Cortex-M</code> 系列控制器中，常用的中断控制器是 <code>NVIC (Nested Vectored Interrupt Controller)</code> 内嵌向量中断控制器</p>
</li>
<li><p>CPU</p>
<p>CPU 会响应中断源的请求、中断当前正在执行的任务，转而执行中断处理程序。NVIC最多支持240个中断，每个中断最多有256个优先级</p>
</li>
</ol>
<p><strong>中断管理的运作机制</strong></p>
<ol>
<li>保存当前处理器状态信息</li>
<li>载入异常或中断处理函数到PC寄存器</li>
<li>把控制权转交给处理函数并开始执行</li>
<li>当处理函数执行完成时，恢复处理器状态信息</li>
<li>从异常或中断中返回到前一个程序执行点</li>
</ol>
<p><strong>注：FreeRTOS允许中断嵌套！！</strong></p>
<h2 id="第23章-CPU利用率"><a href="#第23章-CPU利用率" class="headerlink" title="第23章 - CPU利用率 "></a><a href="#context.34">第23章 - CPU利用率</a><a name="section.34"> </a></h2><h2 id="FreeRTOS操作系统调度方式有哪些？"><a href="#FreeRTOS操作系统调度方式有哪些？" class="headerlink" title="FreeRTOS操作系统调度方式有哪些？ "></a><a href="#context.35">FreeRTOS操作系统调度方式有哪些？</a><a name="section.35"> </a></h2><p>FreeRTOS操作系统支持三种调度方式：</p>
<ol>
<li>抢占式调度（Pre-emptive）</li>
<li>时间片调度（time slice）</li>
<li>合作式调度（co-operative）</li>
</ol>
<p>实际应用主要是抢占式调度和时间片调度结合的调度方法，合作式调度用到的很少。</p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCodeTop100</title>
    <url>/2023/07/26/LeetCodeTop100/</url>
    <content><![CDATA[<h1 id="力扣TOP100"><a href="#力扣TOP100" class="headerlink" title="力扣TOP100"></a>力扣TOP100</h1><span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">哈希</a><a name="context.1"> </a></li>
<li><a href="#section.2">双指针</a><a name="context.2"> </a></li>
<li><a href="#section.3">滑动窗口</a><a name="context.3"> </a></li>
<li><a href="#section.4">子串</a><a name="context.4"> </a></li>
<li><a href="#section.5">数组</a><a name="context.5"> </a></li>
<li><a href="#section.6">矩阵</a><a name="context.6"> </a></li>
<li><a href="#section.7">链表</a><a name="context.7"> </a></li>
</ul>
<hr>
<p><a href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希 "></a><a href="#context.1">哈希</a><a name="section.1"> </a></h2><p><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment">你可以按任意顺序返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment">输出：[1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,3], target = 6</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">只会存在一个有效答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (it != um.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = &#123;it-&gt;second, i&#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                um[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= strs.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= strs[i].length &lt;= 100</span></span><br><span class="line"><span class="comment">strs[i] 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">string <span class="title">s</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c: str)</span><br><span class="line">                    ++s[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                </span><br><span class="line">                um[s].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it: um)</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [100,4,200,1,3,2]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(num - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cur = num;</span><br><span class="line">                    <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (us.<span class="built_in">count</span>(++cur))</span><br><span class="line">                        ++size;</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针 "></a><a href="#context.2">双指针</a><a name="section.2"> </a></h2><p><a href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0,1,0,3,12]</span></span><br><span class="line"><span class="comment">输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0]</span></span><br><span class="line"><span class="comment">输出: [0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; nums.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230808221705531.png" alt="image-20230808221705531"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment">返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment">说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：[1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="comment">输出：49 </span></span><br><span class="line"><span class="comment">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [1,1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">2 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                len = right - left;</span><br><span class="line">                ret = height[left] &gt; height[right]</span><br><span class="line">                      ? <span class="built_in">max</span>(ret, len * height[right--])</span><br><span class="line">                      : <span class="built_in">max</span>(ret, len * height[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked">15. 3Sum - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,1,1]</span></span><br><span class="line"><span class="comment">输出：[]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和不为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,0,0]</span></span><br><span class="line"><span class="comment">输出：[[0,0,0]]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 &lt;= nums.length &lt;= 3000</span></span><br><span class="line"><span class="comment">-105 &lt;= nums[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>, e = nums.<span class="built_in">size</span>() - <span class="number">2</span>; s &lt; e; ++s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[s] &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; <span class="number">0</span> &amp;&amp; nums[s] == nums[s - <span class="number">1</span>])</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> left = s + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> sum;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum = nums[s] + nums[left] + nums[right];</span><br><span class="line">                        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                            --right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                            ++left;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ret.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[s], nums[left], nums[right]&#125;);</span><br><span class="line">                            <span class="keyword">while</span> (++left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">while</span> (left &lt; --right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230808221849426.png" alt="image-20230808221849426"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [4,2,0,3,2,5]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, hl = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>, hr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                hl = <span class="built_in">max</span>(hl, height[left]);</span><br><span class="line">                hr = <span class="built_in">max</span>(hr, height[right]);</span><br><span class="line">                ret += height[left] &gt; height[right] ? hr - height[right--] : hl - height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口 "></a><a href="#context.3">滑动窗口</a><a name="section.3"> </a></h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment">输出: 3 </span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment">输出: 1</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="comment">输出: 3</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">0 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">s 由英文字母、数字、符号和空格组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</span></span><br><span class="line"><span class="comment">异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">输出: [0,6]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span></span><br><span class="line"><span class="comment">输出: [0,1,2]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length, p.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">s 和 p 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tar</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: p)</span><br><span class="line">            ++tar[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">        &#123;</span><br><span class="line">            --tar[s[fast] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">while</span> (tar[s[fast] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                ++tar[s[slow++] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast - slow + <span class="number">1</span> == p.<span class="built_in">size</span>())</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="子串"><a href="#子串" class="headerlink" title="子串 "></a><a href="#context.4">子串</a><a name="section.4"> </a></h2><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,1,1], k = 2</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3], k = 3</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">-1000 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">-107 &lt;= k &lt;= 107</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 前缀 + 哈希 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            um[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                pre += n;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(pre - k))</span><br><span class="line">                    ret += um[pre - k];</span><br><span class="line"></span><br><span class="line">                ++um[pre];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment">返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span><br><span class="line"><span class="comment">输出：[3,3,5,5,6,7]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">滑动窗口的位置                最大值</span></span><br><span class="line"><span class="comment">---------------               -----</span></span><br><span class="line"><span class="comment">[1  3  -1] -3  5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1 [3  -1  -3] 5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1  3 [-1  -3  5] 3  6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1 [-3  5  3] 6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3 [5  3  6] 7       6</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3  5 [3  6  7]      7</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输入：nums = [1], k = 1</span></span><br><span class="line"><span class="comment">输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= nums.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 采用堆结构 priority_queue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">                <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt;= i - k)</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log⁡n)，因此总时间复杂度为 O(nlog⁡n)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 单调栈 deque</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                </span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">空间复杂度：O(k)，与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment">如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;BANC&quot;</span></span><br><span class="line"><span class="comment">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;a&quot;, t = &quot;a&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;a&quot;</span></span><br><span class="line"><span class="comment">解释：整个字符串 s 是最小覆盖子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span></span><br><span class="line"><span class="comment">输出: &quot;&quot;</span></span><br><span class="line"><span class="comment">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span></span><br><span class="line"><span class="comment">因此没有符合条件的子字符串，返回空字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == s.length</span></span><br><span class="line"><span class="comment">n == t.length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 105</span></span><br><span class="line"><span class="comment">s 和 t 由英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: t)</span><br><span class="line">            &#123;</span><br><span class="line">                --um[c];</span><br><span class="line">                ++need;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>, fast, start;</span><br><span class="line">            <span class="type">int</span> min_size = INT_MAX;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; s.<span class="built_in">size</span>() &amp;&amp; !um.<span class="built_in">count</span>(s[slow])) ++slow;</span><br><span class="line">            <span class="keyword">for</span> (fast = slow; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(s[fast]))</span><br><span class="line">                &#123;</span><br><span class="line">                    need -= ++um[s[fast]] &lt;= <span class="number">0</span>;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(fast);</span><br><span class="line">                    <span class="keyword">while</span> (need == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; min_size)</span><br><span class="line">                        &#123;</span><br><span class="line">                            start = slow;</span><br><span class="line">                            min_size = fast - slow + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (--um[s[slow]] &lt; <span class="number">0</span>)</span><br><span class="line">                            ++need;</span><br><span class="line"></span><br><span class="line">                        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                        slow = dq.<span class="built_in">front</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min_size != INT_MAX)</span><br><span class="line">                ret = s.<span class="built_in">substr</span>(start, min_size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组 "></a><a href="#context.5">数组</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment">子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [5,4,-1,7,8]</span></span><br><span class="line"><span class="comment">输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 动规（无后效性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">                pre = <span class="built_in">max</span>(pre + num, num);</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/first-missing-positive/description/">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,0]</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,4,-1,1]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [7,8,9,11,12]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 5 * 105</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 在元素组上哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    nums[i] = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= nums.<span class="built_in">size</span>()) <span class="comment">///&lt; num [1, N]</span></span><br><span class="line">                    nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵 "></a><a href="#context.6">矩阵</a><a name="section.6"> </a></h2><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked">54. 螺旋矩阵 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 10</span></span><br><span class="line"><span class="comment">-100 &lt;= matrix[i][j] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) ret.<span class="built_in">emplace_back</span>(matrix[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (++u &gt; d)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;= d; ++i) ret.<span class="built_in">emplace_back</span>(matrix[i][r]);</span><br><span class="line">                <span class="keyword">if</span> (--r &lt; l)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; --i) ret.<span class="built_in">emplace_back</span>(matrix[d][i]);</span><br><span class="line">                <span class="keyword">if</span> (--d &lt; u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = d; i &gt;= u; --i) ret.<span class="built_in">emplace_back</span>(matrix[i][l]);</span><br><span class="line">                <span class="keyword">if</span> (++l &gt; r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment">你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[[7,4,1],[8,5,2],[9,6,3]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span></span><br><span class="line"><span class="comment">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == matrix.length == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">-1000 &lt;= matrix[i][j] &lt;= 1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = u; i &lt; r; ++i, ++j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][r]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = r; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[d][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = d; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][l]);</span><br><span class="line"></span><br><span class="line">                ++u;</span><br><span class="line">                --d;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</span></span><br><span class="line"><span class="comment">每行的元素从左到右升序排列。</span></span><br><span class="line"><span class="comment">每列的元素从上到下升序排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n, m &lt;= 300</span></span><br><span class="line"><span class="comment">-109 &lt;= matrix[i][j] &lt;= 109</span></span><br><span class="line"><span class="comment">每行的所有元素从左到右升序排列</span></span><br><span class="line"><span class="comment">每列的所有元素从上到下升序排列</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 矩阵向左旋转45度，转换为BST树(二叉搜索树)，左树小，右树大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>() &amp;&amp; matrix[<span class="number">0</span>][<span class="number">0</span>] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">///&lt; 列</span></span><br><span class="line">            <span class="type">int</span> row = <span class="number">0</span>;  <span class="comment">///&lt; 行</span></span><br><span class="line">            <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt; matrix.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">                    ++row;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target)</span><br><span class="line">                    --col;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表 "></a><a href="#context.7">链表</a><a name="section.7"> </a></h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listA 中节点数目为 m</span></span><br><span class="line"><span class="comment">listB 中节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">1 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= skipA &lt;= m</span></span><br><span class="line"><span class="comment">0 &lt;= skipB &lt;= n</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 没有交点，intersectVal 为 0</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 双指针，两条路各走一遍</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA &amp;&amp; headB)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pa = headA, *pb = headB;</span><br><span class="line">            <span class="keyword">while</span> (pa != pb)</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa == <span class="literal">nullptr</span> ? headB : pa-&gt;next;</span><br><span class="line">                pb = pb == <span class="literal">nullptr</span> ? headA : pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = pa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">206. 反转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：head = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">输出：[5,4,3,2,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 三指针赋值 pre cur next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span>  (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中节点数目在范围[1, 105] 内</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 存vector转用双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head != <span class="literal">nullptr</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] == arr[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ret = l &gt;= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针 + 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已知非空，故不做判断</span></span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode *temp = fast-&gt;next ? fast-&gt;next : fast;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == temp-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == temp-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ret = temp == <span class="literal">nullptr</span>;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能用 O(1)（即，常量）内存解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head-&gt;next;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow &amp;&amp; fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = fast != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">不允许修改 链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你是否可以使用 O(1) 空间解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(head))</span><br><span class="line">                &#123;</span><br><span class="line">                    us.<span class="built_in">emplace</span>(head);</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = head;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != fast)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两个链表的节点数目范围是 [0, 50]</span></span><br><span class="line"><span class="comment">-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">l1 和 l2 均按 非递减顺序 排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力(略)</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 循环迭代 + 智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_ptr&lt;ListNode&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> ListNode())</span></span>;</span><br><span class="line">        ListNode *pre = ptr.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = list1 ? list1 : list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><a href="https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked">2. 两数相加 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked">25. K 个一组翻转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span></span><br><span class="line"><span class="comment">k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"><span class="comment">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中的节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 直接模拟，注意细节就好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">ReverseNode</span><span class="params">(ListNode *begin, ListNode *end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre = end, *next;</span><br><span class="line">        <span class="keyword">do</span>  <span class="comment">///&lt; begin 已在外部判断非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            next = begin-&gt;next;</span><br><span class="line">            begin-&gt;next = pre;</span><br><span class="line">            pre = begin;</span><br><span class="line">            begin = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (begin != end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = head;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">            ListNode *begin = head, *end = begin;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; k &amp;&amp; end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = end-&gt;next;</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n == k)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = begin;</span><br><span class="line">                ret = <span class="built_in">ReverseNode</span>(begin, end);</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    n = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (n &lt; k &amp;&amp; end)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end = end-&gt;next;</span><br><span class="line">                        ++n;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (n == k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin = begin-&gt;next;</span><br><span class="line">                        pre-&gt;next = <span class="built_in">ReverseNode</span>(begin, end);</span><br><span class="line">                        pre = begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked">138. 复制带随机指针的链表 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(c++)</title>
    <url>/2023/07/26/algorithm/</url>
    <content><![CDATA[<p>这是测试</p>
<span id="more"></span>

<h1 id="算法（c-）"><a href="#算法（c-）" class="headerlink" title="算法（c++）"></a>算法（c++）</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">字符串</a><a name="context.1"> </a><ul>
<li><a href="#section.2">KMP算法</a><a name="context.2"> </a></li>
<li><a href="#section.3">Manacher算法（马拉车）</a><a name="context.3"> </a></li>
<li><a href="#section.4">不重复最长子串</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">排序算法</a><a name="context.5"> </a><ul>
<li><a href="#section.6">快排</a><a name="context.6"> </a></li>
</ul>
</li>
<li><a href="#section.7">回溯</a><a name="context.7"> </a></li>
<li><a href="#section.8">递归法</a><a name="context.8"> </a></li>
<li><a href="#section.9">贪心</a><a name="context.9"> </a></li>
</ul>
<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串 "></a><a href="#context.1">字符串</a><a name="section.1"> </a></h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法 "></a><a href="#context.2">KMP算法</a><a name="section.2"> </a></h3><p>用于字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。</p>
<p><strong>求前缀表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 求前缀表（最长公共子串） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>相关例题：</p>
<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">KMP 459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 */</span></span><br><span class="line"><span class="comment">/** 字符串 459 重复的子字符串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string &amp;s, <span class="type">int</span> *next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">///&lt; j 为前缀末尾, i 为后缀末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="built_in">GetNext</span>(s, next);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">            ret = next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; (len % (len - (next[len - <span class="number">1</span>]))) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: arr)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!haystack.<span class="built_in">empty</span>() &amp;&amp; !needle.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; needle.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needle[i] == needle[j])</span><br><span class="line">                    ++j;</span><br><span class="line"></span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (haystack[i] == needle[j] &amp;&amp; ++j == needle.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i - j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manacher算法（马拉车）"><a href="#Manacher算法（马拉车）" class="headerlink" title="Manacher算法（马拉车） "></a><a href="#context.3">Manacher算法（马拉车）</a><a name="section.3"> </a></h3><p>一个高效匹配回文子串长度的算法，他可以在o(n)的时间复杂度中计算出一个字符串的回文子串的长度</p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 5 最长回文子串 马拉车算法 Manacher */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;  <span class="comment">///&lt; p 用来记录各点的回文半径</span></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;           <span class="comment">///&lt; 某个回文串延伸到的最右边下标</span></span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;         <span class="comment">///&lt; r 所属回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_mid = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_rad = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文半径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, end = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 i 还在区间内, 则此处半径为 i 关于 mid 对称点 j 处的半径(不超过左边界)</span></span><br><span class="line">            p[i] = i &lt; r ? <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i) : <span class="number">1</span>;  <span class="comment">///&lt; 重要!!! 需理解!!!</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴力计算回文串长度</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]])</span><br><span class="line">                ++p[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 i 处的回文字符串长度超过右边界 r 时  更新 mid 和 r</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                r = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max_rad 记录最大的半径 max_mid 记录最大半径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; max_rad) &#123;</span><br><span class="line">                max_rad = p[i];</span><br><span class="line">                max_mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>((max_mid - max_rad) &gt;&gt; <span class="number">1</span>, max_rad - <span class="number">1</span>);  <span class="comment">///&lt; 注意起始点需 / 2, 长度需 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 647 回文子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">            &#123;</span><br><span class="line">                t += c;</span><br><span class="line">                t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size())</span></span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, e = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">                p[i] = i &lt; r ? <span class="built_in">min</span>(r - i, p[<span class="number">2</span> * mid - i]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i + p[i] &gt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = i + p[i];</span><br><span class="line">                    mid = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret += (p[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>总结马拉车</strong></p>
<p>步骤如下</p>
<ol>
<li><code>p[i] = i &lt; r ? min(p[2 * mid - i], r - i) : 1;</code></li>
<li>暴力外扩</li>
<li>外扩后判断<strong>半径</strong>是否超右边界，如果是，则更新右边界和中心点</li>
<li>更新最大半径和最大半径的中心点</li>
</ol>
<h3 id="不重复最长子串"><a href="#不重复最长子串" class="headerlink" title="不重复最长子串 "></a><a href="#context.4">不重复最长子串</a><a name="section.4"> </a></h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 */</span></span><br><span class="line"><span class="comment">/** 字符串 3 无重复字符的最长子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法 "></a><a href="#context.5">排序算法</a><a name="section.5"> </a></h2><table>
<thead>
<tr>
<th>名称</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔</td>
<td>O(n log n)</td>
<td>O(n log² n)</td>
<td>O(n log² n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="#%E5%BF%AB%E6%8E%92">快速</a></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n²)</td>
<td>O(n + k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n + k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排 "></a><a href="#context.6">快排</a><a name="section.6"> </a></h3><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecurQS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, temp;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            left = start;</span><br><span class="line">            right = end;</span><br><span class="line"></span><br><span class="line">            mid = nums[<span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start];  <span class="comment">// 随机效率比中位数高将近10倍</span></span><br><span class="line"><span class="comment">//            mid = nums[start + ((end - start) &gt;&gt; 1)];</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(nums[left], mid))</span><br><span class="line">                    ++left;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(mid, nums[right]))</span><br><span class="line">                    --right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = nums[left];</span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    nums[right] = temp;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; right)</span><br><span class="line">                <span class="built_in">RecurQS</span>(nums, start, right);</span><br><span class="line"></span><br><span class="line">            start = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RecurQS</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯 "></a><a href="#context.7">回溯</a><a name="section.7"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码模板 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法 "></a><a href="#context.8">递归法</a><a name="section.8"> </a></h2><p>三部曲：</p>
<ol>
<li><p><strong>确定递归函数的参数和返回值</strong></p>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>确定终止条件</strong><br>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。<br>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
</li>
<li></li>
<li><p><strong>确定单层递归的逻辑</strong></p>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心 "></a><a href="#context.9">贪心</a><a name="section.9"> </a></h2><p>如果找到局部最优，然后推出整体最优，那么就是贪心</p>
<p>局部最优 → 总体最优</p>
<p><a href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 贪心 53 最大子数组和 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">///&lt; 1. 贪心</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = INT32_MIN;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 2. 优化空间后的动态规划</span></span><br><span class="line"><span class="comment">//            ret = nums[0];</span></span><br><span class="line"><span class="comment">//            int pre = 0;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                pre = max(pre + nums[i], nums[i]);</span></span><br><span class="line"><span class="comment">//                ret = max(ret, pre);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 3. 未优化空间的动态规划</span></span><br><span class="line"><span class="comment">//            vector&lt;int&gt; dp(nums.size(), 0);</span></span><br><span class="line"><span class="comment">//            dp[0] = nums[0];</span></span><br><span class="line"><span class="comment">//            ret = dp[0];</span></span><br><span class="line"><span class="comment">//            for (int i = 1; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                if (dp[i - 1] &gt; 0)</span></span><br><span class="line"><span class="comment">//                    dp[i] = dp[i - 1] + nums[i];</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    dp[i] = nums[i];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                ret = max(ret, dp[i]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2023/08/18/python/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><span id="more"></span>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">os库</a><a name="context.1"> </a><ul>
<li><a href="#section.2">总览</a><a name="context.2"> </a></li>
<li><a href="#section.3">os.chdir(path)</a><a name="context.3"> </a></li>
<li><a href="#section.4">os.getcwd()</a><a name="context.4"> </a></li>
<li><a href="#section.5">os.listdir(path)</a><a name="context.5"> </a></li>
<li><a href="#section.6">os.path.exists(path)</a><a name="context.6"> </a></li>
<li><a href="#section.7">os.mkdir(path)</a><a name="context.7"> </a></li>
<li><a href="#section.8">os.path.join(path1, path2)</a><a name="context.8"> </a></li>
<li><a href="#section.9">os.path.split(path)</a><a name="context.9"> </a></li>
<li><a href="#section.10">os.path.dirname(path)</a><a name="context.10"> </a></li>
<li><a href="#section.11">os.path.basename(path)</a><a name="context.11"> </a></li>
<li><a href="#section.12">os.path.isdir(path)</a><a name="context.12"> </a></li>
<li><a href="#section.13">os.path.isfile(path)</a><a name="context.13"> </a></li>
<li><a href="#section.14">os.path.sep</a><a name="context.14"> </a></li>
<li><a href="#section.15">os.path.getsize(path)</a><a name="context.15"> </a></li>
<li><a href="#section.16">os.remove(path)</a><a name="context.16"> </a></li>
<li><a href="#section.17">os.rmdir(path)</a><a name="context.17"> </a></li>
<li><a href="#section.18">os.removedirs()</a><a name="context.18"> </a></li>
<li><a href="#section.19">os.rename(old,new)</a><a name="context.19"> </a></li>
<li><a href="#section.20">os.curdir</a><a name="context.20"> </a></li>
<li><a href="#section.21">os.pardir</a><a name="context.21"> </a></li>
<li><a href="#section.22">os.path.abspath(path)</a><a name="context.22"> </a></li>
<li><a href="#section.23">os.chmod(file, mode)</a><a name="context.23"> </a></li>
<li><a href="#section.24">os.system()</a><a name="context.24"> </a></li>
<li><a href="#section.25">os.stat(path)</a><a name="context.25"> </a></li>
</ul>
</li>
<li><a href="#section.26">判断当前系统</a><a name="context.26"> </a></li>
<li><a href="#section.27">Json文件处理</a><a name="context.27"> </a></li>
<li><a href="#section.28">镜像源</a><a name="context.28"> </a><ul>
<li><a href="#section.29">一、直接使用镜像源下载</a><a name="context.29"> </a></li>
</ul>
</li>
<li><a href="#section.30">Jinja2</a><a name="context.30"> </a></li>
</ul>
<hr>
<p>在 linux 下</p>
<p># 查看当前环境下的所有安装包</p>
<p>pip freeze &gt; requirements.txt</p>
<p># 安装库查看项目依赖库 ( 只查看项目用到了哪些包 )</p>
<p>pip install pipreqs</p>
<p># 在当前项目目录下，导出项目依赖包，自动生成 requirements.txt</p>
<p>pipreqs .&#x2F;</p>
<p># 如果遇到编码错误UnicodeDecodeError，则将指定编码为utf8：</p>
<p>pipreqs .&#x2F; –encoding&#x3D;utf-8</p>
<p># 安装 requirements.txt 中所有的库</p>
<p>pip install -r requirements.txt</p>
<p># 跳过输入 [y\n]</p>
<p>sudo apt-get install -y xxx</p>
<p># 安装虚拟环境依赖包</p>
<p>pip install virtualenv</p>
<p># 在当前目录下创建 xxx 虚拟环境</p>
<p>virtualenv xxx</p>
<p># 进入虚拟环境</p>
<p>source xxx&#x2F;bin&#x2F;activate</p>
<p># 退出虚拟环境</p>
<p>deactivate</p>
<p>Python3.6+</p>
<table>
<thead>
<tr>
<th><strong>and</strong></th>
<th><strong>as</strong></th>
<th><strong>assert</strong></th>
<th><strong>break</strong></th>
<th><strong>class</strong></th>
<th><strong>continue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>def</strong></td>
<td><strong>del</strong></td>
<td><strong>elif</strong></td>
<td><strong>else</strong></td>
<td><strong>except</strong></td>
<td><strong>finally</strong></td>
</tr>
<tr>
<td><strong>for</strong></td>
<td><strong>from</strong></td>
<td><strong>False</strong></td>
<td><strong>global</strong></td>
<td><strong>if</strong></td>
<td><strong>import</strong></td>
</tr>
<tr>
<td><strong>in</strong></td>
<td><strong>is</strong></td>
<td><strong>lambda</strong></td>
<td><strong>nonlocal</strong></td>
<td><strong>not</strong></td>
<td><strong>None</strong></td>
</tr>
<tr>
<td><strong>or</strong></td>
<td><strong>pass</strong></td>
<td><strong>raise</strong></td>
<td><strong>return</strong></td>
<td><strong>try</strong></td>
<td><strong>True</strong></td>
</tr>
<tr>
<td><strong>while</strong></td>
<td><strong>with</strong></td>
<td><strong>yield</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>槽：</strong></p>
<p>​	<strong>#</strong> <strong>槽内格式配置方式</strong></p>
<p>​	<strong>：</strong><strong>&lt;****填充****&gt;</strong> <strong>&lt;****对齐****&gt;</strong> <strong>&lt;宽度&gt;</strong> <strong>&lt;****，****&gt;</strong> <strong>&lt;** **.精度****&gt;</strong> <strong>&lt;类型&gt;</strong></p>
<p>​	# &lt;填充&gt;：用于填充的单个字符</p>
<p>​	# &lt;对齐&gt;：左对齐&lt;   右对齐&gt;   居中^</p>
<p># &lt;宽度&gt;：槽的输出宽度</p>
<p># &lt;，&gt;：数字的千位分隔符</p>
<p># &lt; .精度&gt;：浮点数小数精度或字符串最大输出长度</p>
<p># &lt;类型&gt;：整数类型 b, c ,d, o, x, X</p>
<p>​		：浮点数类型 e, E, f, %</p>
<p>​		# c表Unicode的编码形式，xX大小写区别十六进制，Ee科学计数法表示</p>
<p><strong>方法</strong></p>
<p>enumerate(sequence, [start&#x3D;0])		# 返回下标和内容</p>
<p>例：seq &#x3D; [‘one’, ‘two’, ‘three’]</p>
<p>for i, element in enumerate(seq):</p>
<p>print i, element</p>
<p>.title()			首字母大写</p>
<p>.upper()			全部大写</p>
<p>.lower()			全部小写</p>
<p>f’{x}’				3.6版本的用法，把x替换为对应值，对应3.5版本的format()方法</p>
<p>.rstrip()			删除字符串末尾空格</p>
<p>.lstrip()			删除字符串开头空格</p>
<p>.strip()			删除字符串两边空格</p>
<p>.append()			末尾附加，例，向列表x末尾添加元素a：x.append(‘a’)</p>
<p>.insert()			索引插入，例，向列表x索引1处插入a：x.insert(1,’a’)</p>
<p>x.extend(x2)		列表插入，在x列表后插入x2列	#也可用+号合并</p>
<p>.pop()			默认删除列表末尾元素，并接着使用删除的值，可索引，术语：弹出（栈）</p>
<p>​				例：a &#x3D; [‘1’,’2’,’3’]	print(a.pop())	&gt;&gt;3</p>
<p>.remove()			删除特定值，例，删除列表x中元素a：x.remove(‘a’)</p>
<p>.sort()			永久改变排序，按照字母顺序排序，逆序则：x.sort(reverse&#x3D;True)</p>
<p>.reverse()			永久反转列表排序</p>
<p>.get(‘x’,’y’)		x指定键（必填），y指定键不存在时返回的值（选）</p>
<p>.items()			返回键值对列表</p>
<p>.keys()			返回键</p>
<p>.values()			返回值</p>
<p>.read()			读取文件所有内容为一个长字符串，读到末尾会返回一个空字符串</p>
<p>.rstrip()			删除末尾的空行</p>
<p>.strip()			去掉两边空格</p>
<p>.readlines()		读取文件每一行并存在一个列表中</p>
<p>​				问：如何删除字符串中间空格？</p>
<p>​				答：1.	a.replace(‘ ’, ‘’)</p>
<p>​					2.	a &#x3D; ‘’.join(a.split())</p>
<p>str.split(sep&#x3D;None)	返回一个列表，由str按sep步分隔组成</p>
<p>‘<em>’.join(str)		将str除最后一位外，其余每位后面加</em></p>
<p>str.count(‘a’)		返回str中a出现的次数</p>
<p>str.replace(old,new)	将str中old替换成new</p>
<p>定义函数：	def(<em>args)		<em>表接受任意数量的实参，name为**元组</em></em></p>
<p>​			def(**kwargs)		**表示创建字典</p>
<p>类定义：	手写字母大写的是指<strong>类</strong>，例：		class Car:</p>
<p>​			<strong>类</strong>中的函数称为<strong>方法</strong></p>
<p>​			<strong>init</strong>(self, name1, name2, …)		是一个特殊的方法，self必不可少</p>
<p>子类定义：	class son_name(父类):</p>
<p>​				super().<strong>init</strong>(n1, n2, …)		super()	能够让子类调用父类的init()</p>
<p>​				#父类也称<strong>超类</strong>(superclass)</p>
<p><strong>查看函数运行时间</strong></p>
<p>import time</p>
<p>​	start &#x3D; time.perf_counter()</p>
<p>  ai_module()</p>
<p>  end &#x3D; time.perf_counter()</p>
<p>  print(end - start)</p>
<p><strong>语句</strong><strong>&amp;others</strong></p>
<p>del  &lt;&gt;[]		例，删除列表x索引3处元素：del x[3]</p>
<p>1000 与 10_00无区别</p>
<p>全部大写赋值  表常量</p>
<p>\t	制表符，Tab</p>
<p>\n	换行符</p>
<p><strong>列表</strong>		list()</p>
<p><strong>列表解析</strong>：			s &#x3D; [x**2 for x in range(1,6)]</p>
<p>​					print(s)						&gt;&gt;[1, 4, 9, 16, 25]</p>
<p>[]			空列表</p>
<p>[-1]			列表倒数第一个元素，以此类推</p>
<p>[0:3]			列表切片，输出前3个元素</p>
<p>[-3:]			列表最后3个元素</p>
<p>[::x]			第三个值表示间隔</p>
<p><strong>元组</strong><strong>:</strong>		tuple()</p>
<p>例，&gt;&gt;(200,5)		&gt;&gt;	(5,)		其他操作同列表</p>
<p><strong>字典</strong>		dict()		</p>
<p><strong>可变集合</strong>set()			#去重，集合中的元素是无序的，因此不能用下标表示</p>
<p><strong>不可变集合</strong>frozenset()	</p>
<p>{}			空字典，注意与集合区分：{1,2,3,4} 花括号里没有顿号为<strong>集合</strong></p>
<p>{‘x’:’a’,…}		字典内容用‘键值对’表示，输入带[ ]方括号</p>
<p>​			例：a &#x3D; {‘x’:’y’}	pirnt(a[‘x’])	&gt;&gt;y</p>
<p>添加键值对：	a[‘#name’] &#x3D; ‘value’		(多行的话每行结束要加逗号)</p>
<p>修改值则在上直接改 ‘value’ 即可</p>
<p>删除键值对：	del a[‘name’]	删除键即可	#也可用.pop(‘name’)删除</p>
<p>遍历键值对：		for k,v in a.items()</p>
<p>遍历键：		用方法 .keys()</p>
<p>遍历值：		用方法	.values()</p>
<p>清空字典：		.clear()</p>
<p>from operator import itemgetter  # 字典排序</p>
<p>dir &#x3D; sorted(dir, key&#x3D;itemgetter(‘area’))  # 根据字典dir中area大小排序</p>
<p><strong>函数</strong></p>
<p>type()				查看类型</p>
<p>sorted()				不改变原始排序，其余同方法 .sort()</p>
<p>len()					获取长度</p>
<p>list()					转为列表,例，list(range(1,5))	&gt;&gt;[1,2,3,4]</p>
<p>min()				返回最小值</p>
<p>max()				返回最大值</p>
<p>sum()				返回总和</p>
<p>open(‘name.py’, encoding&#x3D;’utf-8’)		打开文件,以utf-8格式</p>
<p>round(x, k)			x为要处理的浮点数，k指要保留的位数</p>
<p>divmod(a,b)			返回a除以b的商和余数	#元组类型</p>
<p><strong>关键字</strong></p>
<p>with					不需要访问文件后将其关闭，与open一起用，例：with open(‘a.py’)</p>
<p>​	open(name, ?)		打开方式?	默认只读	</p>
<p>‘r’ 读取模式</p>
<p>‘w’ 写入模式 没有文件则创建，若有则会清空文件，得小心</p>
<p>‘a’ <strong>附加模式</strong>&#x2F;读写模式’r+’</p>
<p><strong>库</strong></p>
<p>random.choice(name)			choice随机返回<strong>列表</strong>或<strong>元组</strong>中的一个元素</p>
<p><strong>JSON</strong></p>
<p>.dump(data, f)					将数据data储存到文件f里（文件必须为json格式）</p>
<p>.load(f)						读文件数据到内存</p>
<p><strong>测试</strong></p>
<p>import unittest, name			导入待测试的函数</p>
<p>class NameTestCase(unittest.TestCase):		继承类</p>
<p>​	def test_namex					须以test_开头，才会自动运行所有test_开头方法</p>
<p>测试.方法（只能在继承类unittest.TestCase中使用这些方法）</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>assertEqual(a, b)</td>
<td>核实 a&#x3D;&#x3D;b</td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>核实 a!&#x3D;b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>核实x为True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>核实x为False</td>
</tr>
<tr>
<td>assertIn(item, list)</td>
<td>核实item在list中</td>
</tr>
<tr>
<td>assertNotIn(item, list)</td>
<td>核实item不在list中</td>
</tr>
</tbody></table>
<p>模块datetime</p>
<table>
<thead>
<tr>
<th>实参</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%A</td>
<td>星期几，如Monday</td>
</tr>
<tr>
<td>%B</td>
<td>月份名，如January</td>
</tr>
<tr>
<td>%m</td>
<td>用数表示的月份（01~12）</td>
</tr>
<tr>
<td>%d</td>
<td>用数表示的月份中的一天（01~31）</td>
</tr>
<tr>
<td>%Y</td>
<td>四位的年份。如2021</td>
</tr>
<tr>
<td>%y</td>
<td>两位的年份，如21</td>
</tr>
<tr>
<td>%H</td>
<td>24小时制的小时数（00~23）</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制的小时数（01~12）</td>
</tr>
<tr>
<td>%p</td>
<td>am或pm</td>
</tr>
<tr>
<td>%M</td>
<td>分钟数（00~59）</td>
</tr>
<tr>
<td>%S</td>
<td>秒数（00~59）</td>
</tr>
</tbody></table>
<p><strong>数据可视化</strong> <strong>-&gt; Matplotlib</strong></p>
<p>查看内置样式</p>
<p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p>
<p>&gt;&gt;&gt; plt.style.available</p>
<p>fig, ax &#x3D; plt.subplots()</p>
<p>ax.plot(x, y ,linewidth&#x3D;n)			# 绘制线</p>
<p>ax.scatter(x, y, c&#x3D;’color’, s&#x3D;n)			# 绘制散点图，n为点的大小,x,y可为列表，c为颜色</p>
<p>颜色映射：	Matploylib主页，单击Examples，向下滚动到Color，再点击Colormaps reference</p>
<p>for i, j in enumerate(next(csv.reader(f)))	# next(f)返回文件下一行</p>
<p>​									# csv.reader(f)以列表格式读文件数据</p>
<p>​									# enumerate() 枚举列表&#x2F;others，返回序号+内容</p>
<p><strong>关于</strong>**@**<strong>：</strong></p>
<p>@a<br>@b<br>def c():<br>…<br>python会按照自下而上的顺序把各自的函数结果作为下一个函数（上面的函数）的输入，也就是a(b(c()))</p>
<p><strong>关于</strong> <strong>-****&gt;:</strong></p>
<p>def add(x, y) -&gt; int:</p>
<p> return x+y</p>
<p>表为数据添加元数据，表明函数返回值的类型</p>
<p><strong>Python面向对象</strong></p>
<p>à静态方法和类方法</p>
<p>1.类方法：</p>
<p>class xxx:</p>
<p>@classmethod</p>
<p>def xxx(cls,…):</p>
<p>  …</p>
<p>可以通过类名或对象名调用，不能访问实例属性，但可以访问类属性</p>
<p>2.静态方法：</p>
<p>class xxx:</p>
<p>@staticmethod</p>
<p>def xxx(…):</p>
<p>  …</p>
<p>可以通过类名或对象名调用，不能访问实例属性，也不能直接访问类属性，但可以通过类名引用类属性</p>
<p>à公有变量和私有变量</p>
<p>共有：</p>
<p>可以在类的外部访问</p>
<p>保护：_xxx</p>
<p>只能允许其本身和子类进行访问</p>
<p>私有：# __xxx</p>
<p>不允许在类的外部访问</p>
<p># <strong>xxx</strong>	表专有变量，方法	</p>
<p>如：	# <strong>init</strong>	# <strong>del</strong>		# <strong>name</strong>	# <strong>doc</strong></p>
<p>​		# <strong>bases</strong>	# <strong>dict</strong>	# <strong>module</strong>	#<strong>class</strong></p>
<p><strong>继承</strong></p>
<p>子类能够继承父类中所有非私有的成员变量和成员函数</p>
<p>例：	class Person():</p>
<p>​			m &#x3D; 10</p>
<p>​			def say_hello(self):</p>
<p>​				print(“hello!”)</p>
<p>​		calss Teacher(Person):</p>
<p>​			pass</p>
<p>​		amy &#x3D; Teacher()</p>
<p>​		print(amy.m)</p>
<p>​		amy.say_hello</p>
<p><strong>文件</strong></p>
<p>1.获取当前路径：</p>
<p>import os</p>
<p>print(os.getcwd())</p>
<p>2.打开文件</p>
<p>X &#x3D; open(文件名, 访问模式)</p>
<p>à访问模式</p>
<p>r：只读	</p>
<p>w：写入#会覆盖已存在的文件	</p>
<p>a：写入#在末尾追加写入</p>
<p>+：可读写</p>
<p>b：以二进制模式打开</p>
<p>t：以文本模式打开#默认模式</p>
<p>打开文件后记得关闭文件	xxx.close()</p>
<p>xxx.read(字符数)			#读文件</p>
<p>xxx.readline(字符数)		#读一行</p>
<p>xxx.write(写入内容)		#写内容</p>
<p><strong>异常处理</strong></p>
<p>try:</p>
<p>​	…</p>
<p>except 异常(Exception):		#Exception表所有异常</p>
<p>​	…</p>
<p>finally:</p>
<p>​	…</p>
<p>上面对文件打开后的清除工作来说太复杂了，所以可以用下述语句</p>
<p>with open(“text.txt”) as f:</p>
<p>​	print(f.read())</p>
<p># 上下文管理器</p>
<p>à实现__enter__()方法和__exit__()方法</p>
<p>class File():</p>
<p>​	def <strong>init</strong>(self, filename, mode):</p>
<p>​		print(“执行__init__()方法”)</p>
<p>​		self.filename &#x3D; filename</p>
<p>​		self.mode &#x3D; mode</p>
<p>​	def <strong>enter</strong>(self):</p>
<p>​		print(“执行__enter__()方法”)</p>
<p>​		self.f &#x3D; open(self.filename, self.mode)</p>
<p>​		return self.f</p>
<p>​	def <strong>exit</strong>(self, *args):</p>
<p>​		print(“执行__exit__()方法”)</p>
<p>​		self.f.close()</p>
<p>with File(‘demo.txt’, ‘r’) as f:</p>
<p>​	print(f.read())</p>
<p><strong>N<strong><strong>umpy</strong></strong>数组（优先选择）</strong></p>
<p>à数组用元组（）表示</p>
<p>à二纬数组（2,3）表2行3列</p>
<p>​		如：a &#x3D; [ [1,2,3], [4,5,6] ]</p>
<p>à三维数组( i, x, y )     4.3,5</p>
<p>​		如：a &#x3D; [ [ [0,1,2,3] ,</p>
<p>​					[4,5,6,7] ,</p>
<p>​					[8,9,10,11] ],</p>
<p>​				[[12,13,14,15] ,</p>
<p>​				[16,17,18,19] ,</p>
<p>​				[20,21,22,23] ] ]	#三维数组（2,3,4）</p>
<p>à创建数组</p>
<p>​	array([0,1,2,3])</p>
<p>np.amax(xxx, axis&#x3D;0)		# 查找0轴最大的值</p>
<p>np.amin(xxx[:, 0])		# 查找0列的最小值</p>
<p>np.average(data, axis&#x3D;0)	# 计算axis轴的均值</p>
<p>np.array([[]])[:, [1, 0]]	# 交换数组的第一列第二列</p>
<p>np.argsort(x, axis&#x3D;-1, kind&#x3D;’quicksort’, order&#x3D;None)	# 返回排序后的索引，axis&#x3D;0按列</p>
<p>例：a &#x3D; np.array([[0, 3, 5], [2, 2, 2]])</p>
<p>​	b &#x3D; np.argsort(a, axis&#x3D;1)         # 对a按行进行排序        </p>
<p>​	[ [0 1 2]</p>
<p> [0 1 2] ]</p>
<p>à数组的属性</p>
<p>​	.ndim		数组的维数</p>
<p>​	.shape		数组的形状</p>
<p>​	.size			数组元素的总个数</p>
<p>​	.dtype		数组中元素的数据类型</p>
<p>​	.itemsize		数组中每个元素的字节数</p>
<p>à数组元素的数据类型</p>
<p>​	array([列表]&#x2F;(元组),dtype&#x3D;数据类型)		# int64 &#x2F; ’int64’ &#x2F; np.int64</p>
<p>à创建特殊的数组</p>
<p>​	np.arange(起始数字, 结束数字, 步长, dtype&#x3D;数据类型)			创建数字序列数组</p>
<p>​	np.ones(shape, dtype&#x3D;数据类型)								创建全1数组</p>
<p>​	np.zeros(shape, dtype&#x3D;数据类型)								创建全0数组</p>
<p>​	np.eye(shape)											创建单位矩阵</p>
<p>​	np.linspace(start, stop, num&#x3D;xxx)	# 这里包括stop的数字		创建等差数列</p>
<p>​	np.logspace(start, stop, num&#x3D;xxx, base&#x3D;x)	# base^start			创建等比数列</p>
<p>​	np.diag(V, K)   # k&#x3D;0为对角，k&gt;0为对角往上				创建对角矩阵</p>
<p>​	xxx.tolist()		# np数组转成list</p>
<p>​	asarray()			将列表或元组转化为数组对象		</p>
<p>#跟array一样为复制操作，不影响原来的值</p>
<p>#若数据源本身为ndarray对象时，array()为复制，asarray()引用原来</p>
<p>​	np.reshape(shape)	不改变当前数组，按照shape创建新的数组</p>
<p>​	np.resize(shape)	改变当前数组，按照shape创建数组</p>
<p>## shape(-1, 1)   -1表不知道，将根据其他纬度自动计算出值</p>
<p>à数组元素的切片</p>
<p>​	b[0]			第一行</p>
<p>​	b[0:2] &#x2F; b[:2]		前两行</p>
<p>​	b[0:2, 0:2]		前两行的前两列</p>
<p>​	b[:, 0]			第一列</p>
<p>​	</p>
<p>à数组运算</p>
<p>​	一维数组可与n纬数组相加，一维分别加到其他纬上</p>
<p>​	乘法：		A*B			#二维各位置元素相乘</p>
<p>​	矩阵乘法：	np.matmul(A, B)	或	np.dot(A, B)	或	A@B</p>
<p>​	转置：	np.transpose(A)</p>
<p>​	求逆：	np.linalg.inv(A)		# linalg莉娜老哥</p>
<p>​	秩：	与数学不同，这里指<strong>轴</strong>的个数（纬度）</p>
<p>​	np.sum(x, axis&#x3D;0)	计算所有元素的和# axis&#x3D;0表x轴消失,只剩一行n列#一维数组</p>
<p>​	np.prod()		计算所有元素的乘积</p>
<p>​	np.diff()		计算数组的相邻元素之间的差</p>
<p>​	np.sqrt()		计算各元素的平方根</p>
<p>​	np.exp()		计算各元素的指数值</p>
<p>​	np.abs()		取各元素的绝对值</p>
<p>à数组堆叠运算</p>
<p>​	np.stack((数组1,数组2,…), axis)</p>
<p>​	#在0轴堆叠，shape&#x3D;(2,3)</p>
<p>​	#在1轴堆叠，shape&#x3D;(3,2)</p>
<p>à<strong>矩阵</strong></p>
<p>​	np.matrix(字符串&#x2F;列表&#x2F;元组&#x2F;数组)	或	np.mat()</p>
<p>​	例：a &#x3D; np.mat(‘ 1 2 3 ; 4 5 6 ‘)</p>
<p>​	&gt;&gt;matrix([[1,2,3] , [4,5,6]])</p>
<p>​	矩阵的乘法同数学</p>
<p>​	.T	转置</p>
<p>​	.I	求逆</p>
<p>​	*<strong>优先选择数组*</strong></p>
<p><strong>随机数模块</strong>	<strong>à</strong>	<strong>np.random</strong> </p>
<p>np.random.rand(d0,d1,…,dn)</p>
<p>​	#元素在[0,1)区间均匀分布的数组</p>
<p>​	#返回值：浮点数</p>
<p>np.random.uniform(low, high, size)</p>
<p>​	#元素在[low,high)区间均匀分布的数组</p>
<p>​	#返回值：浮点数</p>
<p>np.random.randint(low,high,size)</p>
<p>​	#元素在[low,high)区间均匀分布的数组</p>
<p>​	#返回值：整数</p>
<p>np.random.randn(d0,d1,…,dn)</p>
<p>​	#产生标准正态分布的数组</p>
<p>​	#返回值：浮点数</p>
<p>np.random.normal(loc,scale,size)</p>
<p>​	#产生标准正态分布的数组</p>
<p>​	#返回值：浮点数</p>
<p>​	#loc：均值	scale：标准差</p>
<p>np.random.uniform( x, y, (1, n) )</p>
<p>​	#均匀分布x，y表范围</p>
<p>​	#</p>
<p>随机数种子：</p>
<p>​	seed(xxx)</p>
<p>​	例:	&gt;&gt;np.random.seed(600)</p>
<p>​		&gt;&gt;np.random.rand(2,3)</p>
<p>​		#2次结果一样</p>
<p>​		#seed()只生效一次</p>
<p>打乱顺序（洗牌）：</p>
<p>​	np.random.shuffle(序列)</p>
<p>à<strong>Matplotlib****绘图库</strong></p>
<p>​	import matplotlib.pyplot as plt			#导入库中的子库</p>
<p>​	plt.figure(num,figsize,dpi,facecolor,edgecolor,frameon)</p>
<p>​	#num：图形编号或名称，取值为数字&#x2F;字符串</p>
<p>​	#figsize：绘图对象的宽和高，单位为英寸</p>
<p>​	#dpi：绘图对象的分辨率，缺省值为80</p>
<p>​	#facecolor：背景颜色</p>
<p>​	#edgecolor：边框颜色</p>
<p>​	#frameon：表示是否显示边框</p>
<p>plt.plot()</p>
<p>plt.show()</p>
<p>·常用颜色：	#可用首字母</p>
<p>​	blue   black   green   white   red   cyan   yellow   magenta	</p>
<p>·划分子图：	#多个图，从左到右，从上到下</p>
<p>​	subplot(行数，列数，子图序号)</p>
<p>​    #创建几个图就需要几条语句</p>
<p>​	#当3个参数均小于10时，可省略逗号</p>
<p>·设置中文字体：</p>
<p>  plt.rcParams[‘font.sans-serif’] &#x3D; ‘SimHei’</p>
<p>​	#rcParams为全局变量，可直接修改&#x2F;&#x2F;run configuration Params</p>
<p>​	宋体：SimSun      			楷体：KaiTi</p>
<p>​	黑体：SimHei      			楷体：KaiTi</p>
<p>​	微软雅黑：MicrosoftYaHei			隶属：LiSu</p>
<p>​	微软正黑体：MicrosoftJhengHei		幼圆：YouYuan</p>
<p>​	恢复标准默认配置：plt.rcdefaults()</p>
<p>·添加标题</p>
<p>​	全局：	suptitle(标题文字)</p>
<p>​	子标题：	title(标题文字)</p>
<p>plt.tight_layout(rect&#x3D;[left,bottom,right,top])	</p>
<p>​	#自动消除重叠</p>
<p>​	#也即画布的四个点</p>
<p>·散点图</p>
<p>​	plt.scatter(x,y,s,c,marker,label)</p>
<p>​	# x, y不可省略</p>
<p>​	# scale：数据点的大小</p>
<p>​	# color：数据点的颜色</p>
<p>​	# marker：数据点的样式，’o’圆点		more↓</p>
<p>​	# label：图例文字</p>
<p><img src="/python.assets/wps1.jpg" alt="img"> </p>
<p>​	#用	legend(loc, fontsize)	显示图例</p>
<p><img src="/python.assets/wps2.jpg" alt="img"> </p>
<p>​	plt.text(x,y,s,fontsize,color)</p>
<p>​	# s：显示的文字，与x，y一样不可省略</p>
<p>​	# 若负号显示出错</p>
<p>​	plt.rcParams[‘axes.unicode_minus’] &#x3D; False</p>
<p>​	plt.xlabel(x,y,s,fontsize,color)			#设置x轴标签</p>
<p>​	plt.ylabel(x,y,s,fontsize,color)			#设置y轴标签</p>
<p>​	plt.xlim(xmin,xmax)			#设置x轴坐标的范围</p>
<p>​	plt.ylim(ymin,ymax)			#设置y轴坐标的范围</p>
<p>​	plt.tick_params(labelsize)			#设置刻度文字的字号</p>
<p>à折线图和柱状图</p>
<p>​	#折线图</p>
<p>​	plot(x,y,color,marker,label,linewidth,markersize)</p>
<p><img src="/python.assets/wps3.jpg" alt="img"> </p>
<p>​	#柱状图</p>
<p>​	plt.bar(left,height,width,facecolor,edgecolor,label)</p>
<p>##	Gallery页面	à 图库</p>
<p><a href="https://matplotlib.org/gallery.html">https://matplotlib.org/gallery.html</a></p>
<p>##	Matplotlib官网</p>
<p>​	<a href="http://matplotlib.org/">http://matplotlib.org</a></p>
<p>np.meshgrid()     # 生成坐标矩阵</p>
<p>plt.pccolormesh(x, y, z, cmap&#x3D;’rainbow’)   	# 填充网格</p>
<p>plt.contour(x, y, z, cmap&#x3D;’rainbow’)	# 绘制轮廓线</p>
<p>plt.contourf(x, y, z, cmap&#x3D;’rainbow’)	# 填充颜色</p>
<p>è <strong>tf.keras下载数据集</strong></p>
<p>tf.keras.utils.get_file( fname, origin, cache_dir )</p>
<p># fname：下载后的文件名</p>
<p># origin：文件的URL地址</p>
<p># cache_dir：下载后文件的存储位置</p>
<p># return 文件的绝对路径</p>
<p><strong>Pandas****二维数据基本操作</strong></p>
<p>import pandas as pd</p>
<p>xxx &#x3D; pd.read_csv( filepath_or_buffer, header, names )</p>
<p>.head(n)		#读取前n行数据，默认5</p>
<p>.tail(n)		#读取后n行数据，默认 5</p>
<p>xxx[10:16]		#读10-15行数据</p>
<p>.describe()		#显示二维数据的统计信息，如平均值，标准差…</p>
<p>.ndim</p>
<p>.shape</p>
<p>.size</p>
<p>à转换为numpy数组	# 3种方法</p>
<p>np.array(xxx)</p>
<p>xxx.values</p>
<p>xxx.as_matrix()</p>
<p><strong>数字图像基础</strong></p>
<p>像素（Pixel）：是图像中的一个最小单位</p>
<p>位图（bitmap）：通过记录每一个像素值来存储和表达的图像</p>
<p>色彩深度&#x2F;位深度：位图中每个像素点要用多少个二进制位来表示</p>
<p>BMP格式：Windows系统的标准位图格式</p>
<p>·二值图像（Binary Image）</p>
<p>#每个像素只有2种可能的取值，使用1位二进制来表示，位深度为1</p>
<p>#只有2种颜色的都可称为二值图</p>
<p>·灰度图像（Gray Image）</p>
<p>#每个像素使用1个字节表示，位深度为8，可以表示256种级别的灰度</p>
<p># 0表示黑色，255表示白色</p>
<p>·彩色图像（RGB）</p>
<p># 1个像素点使用3个字节，位深度为24位</p>
<p>#可表示256<em>256</em>256&#x3D;16777216种色彩</p>
<p># 24位真彩色</p>
<p>·RGBA图像</p>
<p># RGB图像+8位透明度信息Alpha</p>
<p># 255不透，0为完全透明</p>
<p># 32位真彩色：1个像素点使用4个字节，位深度为32位</p>
<p>·256色彩色图像</p>
<p>#每个像素用8位二进制表示，是调色板中的索引值</p>
<p>·图像格式</p>
<p># BMP格式：占用存储空间大，不支持文件压缩，不适用于网页</p>
<p>·JPEG格式</p>
<p>#有损压缩</p>
<p>#压缩率高，所占空间小</p>
<p>#适用于色彩丰富、细节清晰细腻的大图像</p>
<p>#不适合所含颜色较少，具有大块颜色相近的区域，或亮度差异十分明显的简单图片</p>
<p>#每次编辑都会降低图像质量，不适合需要进行多次编辑的情况</p>
<p>·PNG格式（Portable Network Graphics, PNG）</p>
<p>#无损压缩</p>
<p>#适用于有规律渐变色彩的图像</p>
<p>·GIF格式（Graphics Interchange Format）</p>
<p>#支持静态格式和动态格式</p>
<p>#动态图片由多幅图片保存为一个图片，循环显示，形成动画效果</p>
<p>#只支持256色，适用于色彩简单、颜色较少的小图像</p>
<p>·TIFF格式（Tag Image File Format）</p>
<p>#定义了4类不同类型的格式</p>
<p>  二值图像（TIFF-B）</p>
<p>  黑白灰度图像（TIFF-G）</p>
<p>  带调色板的彩色图像（TIFF-P）</p>
<p>  RGB真彩图像（TIFF-R）</p>
<p>#支持RGB、JPEG等多种编码方法</p>
<p>#具有非常好的扩展性、方便性、可改性，是印刷行业中最常用的格式</p>
<p>·色彩模式</p>
<p>二值图像、灰度图像、RGB图像、RGBA图像</p>
<p>CMYK—–印刷四分色</p>
<p>  C：Cyan&#x3D;青色</p>
<p>  M：Magenta&#x3D;洋红色</p>
<p>  Y：Yellow&#x3D;黄色</p>
<p>  K：Black&#x3D;黑色</p>
<p>YCbCr（DVD、摄像机，数字电视等）</p>
<p>  Y：亮度</p>
<p>  Cb：蓝色色度</p>
<p>  Cr：红色色度</p>
<p>HIS</p>
<p>  H：色调</p>
<p>  S：饱和度</p>
<p>  I：亮度</p>
<p>·图像类型</p>
<p>#序列图像：时间上有一定顺序间隔、内容上相关的一组图像</p>
<p>#深度图像（Depth Map）：</p>
<p>  是一种三维场景信息的表达方式</p>
<p>  每个像素点的取值，代表这个点离摄像机的距离</p>
<p>  采用灰度图表示，每个像素点由一个字节表示</p>
<p>  深度图像中，像素点的取值并不代表实际的距离，颜色的深浅只是代表相对距离的远近</p>
<p><strong>à****Python图像处理库</strong></p>
<p>·matplotlib.image</p>
<p>  仅支持导入PNG格式的图像，且功能有限</p>
<p>·PIL（Python Imaging Library）</p>
<p>  功能丰富，简单易用</p>
<p>  仅支持Python2.X版本，且已经停止更新</p>
<p>·Pillow（推荐）</p>
<p>  在PIL的基础上发展而成</p>
<p>  支持Python 3</p>
<p>à Pillow库</p>
<p>  from PIL import Image</p>
<p>  import matplotlib.pyplot as plt</p>
<p>  Image.open(路径)	#返回image对象</p>
<p>  img.save(“xxx.tiff”)</p>
<p>  Image.Image.show(xxx)	#显示图像</p>
<p>  .format		#返回图像格式</p>
<p>  .size		#图像尺寸</p>
<p>  .mode		#彩色模式</p>
<p>à显示图像</p>
<p>  plt.imshow(image对象&#x2F;Numpy数组)</p>
<p>  plt.show()</p>
<p>à转换图像的色彩模式（Pillow）</p>
<p>图像对象.convert(色彩模式)</p>
<p>  1		二值图像</p>
<p>  L		灰度图像</p>
<p>  P		8位彩色图像</p>
<p>  RGB		24位彩色图像</p>
<p>  RGBA		32位彩色图像</p>
<p>  CMYK		CMYK彩色图像</p>
<p>  YCbCr		YCbCr彩色图像</p>
<p>  I		32位整型灰度图像</p>
<p>  F		32位浮点型灰度图像</p>
<p>à颜色通道的分离与合并</p>
<p>  图像对象.split()					#分离通道</p>
<p>  图像对象.merge(色彩模式,图像列表)		#合并</p>
<p>·转换为数组</p>
<p>  np.array(图像对象)</p>
<p>  # 例：arr &#x3D; np.array(xxx)</p>
<p>​	shape：（512,512,3）</p>
<p>·缩放图像</p>
<p>  图像对象.resize((width,height))</p>
<p>  图像对象.thumbnail((width,height))		#原地操作，返回None</p>
<p>·旋转、镜像</p>
<p>  图像对象.transpose(旋转方式)</p>
<p>  Image.FLIP_LEFT_RIGHT：					#水平翻转</p>
<p>  Image.FLIP_TOP_BOTTOM：				#上下翻转</p>
<p>  Image.ROTATE_90：					#逆时针旋转90°</p>
<p>  Image.ROTATE_180：					#逆时针旋转180°</p>
<p>  Image.ROTATE_270：					#逆时针旋转270°</p>
<p>  Image.TRANSPOSE：					#将图像进行转置</p>
<p>  Image.TRANSVERSE：					#将图像进行转置，再水平翻转</p>
<p>·裁剪图像：</p>
<p>  图像对象.crop((x0, y0, x1, y1))			#x0y0左上角，返回图像对象</p>
<p><strong>Tensorflow2.0</strong></p>
<p>·TensorFlow1.x	#静态图机制&#x2F;延迟执行机制</p>
<p># 分构建和执行阶段</p>
<p>#构建阶段不进行计算</p>
<p>#执行阶段进行</p>
<p>#如：sess &#x3D; tf.Session()</p>
<p>   print(sess.run(c))</p>
<p>   sess.close()</p>
<p>·TensorFlow2.0	#动态图机制</p>
<p>#无需首先创建静态图，可以立刻执行计算，并返回结果</p>
<p>#能够快速的建立和调试模型</p>
<p>·创建张量</p>
<p>  tf.constant( [1, 2], [3, 4] )			#创建张量</p>
<p>​	# tf.constant( np.arange(6), shape&#x3D;(3, 2) )		创建3*2的张量</p>
<p>​	# print( xxx.numpy() )		# numpy()只显示数值</p>
<p>  tf.where( condition, a, b )			# 根据布尔c，真返a，假反b</p>
<p>  tf.cast(x, dtype)			#改变张量中元素的数据类型</p>
<p>​    #例：tf.cast(x, tf.bool)		#改变为布尔型，整数均为True</p>
<p>  tf.convert_to_tensor(数组&#x2F;列表&#x2F;数字&#x2F;布尔型&#x2F;字符串)</p>
<p>  tf.is_tensor(x)			#判断是否为张量</p>
<p>  isinstance(ta, tf.tensor)			#判断是否为tensor对象</p>
<p>isinstance(na, np.ndarray)				#判断是否为ndarray对象</p>
<p>tf.zeros(shape, dtype&#x3D;tf.float32)		#创建全0张量，默认32位浮点</p>
<p>tf.ones(shape, dtype&#x3D;tf.float32)		#创建全1张量，默认同上</p>
<p>tf.fill(dims, value)				#创建元素值都相同的张量，自动判断类型</p>
<p>tf.random.normal(shape, mean, stddev, dtype)</p>
<p>  # mean：（概率）均值		#期望</p>
<p>  # stddev：标准差			#方差</p>
<p>  #若以上二者均省略时，默认为标准正态分布</p>
<p>tf.random.truncated_normal(shape,mean,stddev,dtype)</p>
<p>  #返回一个截断的正态分布</p>
<p>  #截断的标准是2倍的标准差</p>
<p>tf.random.set_seed()			#设置随机种子</p>
<p>tf.random.uniform(shape,minval,maxval,dtype)</p>
<p>#创建均匀分布张量</p>
<p>​    tf.random.shuffle()				#只在第一维随机打乱</p>
<p>​    tf.range(start,limit,delta&#x3D;1,dtype)</p>
<p>​      #开始，结束，步长，类型</p>
<p><img src="/python.assets/wps4.jpg" alt="img"> </p>
<p>​    tf.shape(x)		#获取形状</p>
<p>​    tf.size(x)			#获取元素总数</p>
<p>​    tf.rank(x)			#获取维度</p>
<p>·维度变换</p>
<p>  tf.reshape(tensor, shape)		# 改变张量的形状</p>
<p>​							# shape(4, -1)		-1表自动推导出长度</p>
<p>  tf.expand_dims(input, axis)		#增加维度</p>
<p>  tf.squeeze( input, axis )			#删除维度：只能删除长度为1的维度</p>
<p>​    # axis也可以指定删除特定轴</p>
<p>  tf.transpose( a, perm )			#交换维度</p>
<p>  tf.concat( tensors, axis )			#张量拼接</p>
<p># tensors：列表，所有要拼接的张量</p>
<p># axis：在哪个轴拼接</p>
<p>tf.split( value, num_or_size_splits, axis&#x3D;0 )		#分割</p>
<p>#若num_or_size_splits为单个数值时，表平均切割n个张量</p>
<p>#若为列表，表不等长切割</p>
<p>#如 [1:2:1] 表分割成三个张量，长度分别是1,2,1</p>
<p>​    tf.stack( values, axis )			#张量堆叠</p>
<p>​		tf.unstack( values, axis )			#分解张量</p>
<p>​		gather( params, axis, indices )		#数据提取</p>
<p>​			#用一个索引列表，将给定张量中，对应索引值的元素提取出来</p>
<p>​			#例：gather(xxx, indices&#x3D;[0, 2, 3]		提取0,2,3索引值的数据</p>
<p>​			# axis：默认0</p>
<p>​		gather_nd( xxx , [[], [], []] )</p>
<p>​	·张量运算</p>
<p><img src="/python.assets/wps5.jpg" alt="img"> </p>
<p>​	</p>
<p><img src="/python.assets/wps6.jpg" alt="img"> </p>
<p># 张量开根号必须是浮点数类型</p>
<p>​	#通过换底公式，实现任意对数运算，如：log2 256 &#x3D; loge 256 &#x2F; loge 2</p>
<p>​	# tf函数</p>
<p><img src="/python.assets/wps7.jpg" alt="img"> </p>
<p><img src="/python.assets/wps8.jpg" alt="img"> </p>
<p>​	# tf运算符</p>
<p><img src="/python.assets/wps9.jpg" alt="img"> </p>
<p>​	# 广播机制：shape(2, 3) +-*&#x2F; shape(1, 3) 每行都做运算，最后一个维度必须相等</p>
<p>​		# 同样适用于多维向量乘法</p>
<p>​		# 多维向量相乘，看后两位，其余不变</p>
<p>​	·张量和Numpy数组之间的相互转换</p>
<p>​	# Numpy数组转化为张量</p>
<p>​		# tf.constant()</p>
<p>​		# tf.convert_to_tensor</p>
<p>​	# 张量转换为Numpy数组</p>
<p>​		# tensor.numpy()</p>
<p>​	### 用什么操作时，会自动把异类转换为同类型</p>
<p>​	·张量的数据统计</p>
<p>tf.reduce_<img src="/python.assets/wps10.jpg" alt="img"></p>
<p>​	# axis&#x3D;0，表压缩行，即每行相加，若不赋值给axis，默认为全局</p>
<p>​	# reduce		表默认只降一维</p>
<p>​	tf.argmax()		# 最值索引，按轴方向判断，如(3, 2)，在axis&#x3D;0有2个最大值(看列)</p>
<p>​	tf.argmin()		# 求最小值的索引，axis默认为0</p>
<p>·可训练变量Variable</p>
<p><img src="/python.assets/wps11.jpg" alt="img"> </p>
<p>dtype		# 32位足够了，64位影响程序运行效率</p>
<p>还可将张量封装为可训练变量</p>
<p><img src="/python.assets/wps12.jpg" alt="img"> </p>
<p><img src="/python.assets/wps13.jpg" alt="img">判断类型<img src="/python.assets/wps14.jpg" alt="img"></p>
<p>自动求导</p>
<p><img src="/python.assets/wps15.jpg" alt="img"> </p>
<p>GradientTape( persistent, watch_accessed_variales )</p>
<p># persistent &#x3D; True	表可以多次求导，默认为False，表只能被调用一次</p>
<p># 若为True，则需要手动释放</p>
<p># del tape		# 手动释放</p>
<p># watch_accessed_variales默认为True，自动监视所有可训练对象</p>
<p><img src="/python.assets/wps16.jpg" alt="img"> </p>
<p><img src="/python.assets/wps17.jpg" alt="img"> </p>
<p>多元函数求偏导</p>
<p><img src="/python.assets/wps18.jpg" alt="img"> </p>
<p><img src="/python.assets/wps19.jpg" alt="img"> </p>
<p>单层神经网络的实现</p>
<p>​	Softmax函数：</p>
<p>tf.nn.softmax()</p>
<p>tf.nn.softmax( tf.matmul( X_train, W ) + b )</p>
<p>独热编码：</p>
<p>tf.one_hot( indices, depth )</p>
<p>例： tf.one_hot( tf.constant( y_test, dtype&#x3D;tf.int32 ), 3 )</p>
<p>交叉熵损失函数：</p>
<p>tf.keras.losses.categorical_crossentropy( y_true, y_pred )</p>
<p><img src="/python.assets/wps20.jpg" alt="img"> </p>
<p><img src="/python.assets/wps21.jpg" alt="img"> </p>
<p><img src="/python.assets/wps22.jpg" alt="img"> </p>
<p><img src="/python.assets/wps23.jpg" alt="img"> </p>
<p><img src="/python.assets/wps24.jpg" alt="img"> </p>
<p><img src="/python.assets/wps25.jpg" alt="img">误差反向传播算法</p>
<p><img src="/python.assets/wps26.jpg" alt="img"> </p>
<p><img src="/python.assets/wps27.jpg" alt="img">多层神经网络的训练</p>
<p><img src="/python.assets/wps28.jpg" alt="img"> </p>
<p>激活函数</p>
<p><img src="/python.assets/wps29.jpg" alt="img"> <img src="/python.assets/wps30.jpg" alt="img"> <img src="/python.assets/wps31.jpg" alt="img"><img src="/python.assets/wps32.jpg" alt="img"></p>
<p>常用ReLU <img src="/python.assets/wps33.jpg" alt="img"></p>
<p><img src="/python.assets/wps34.jpg" alt="img"> </p>
<p>小批量梯度下降算法</p>
<p><img src="/python.assets/wps35.jpg" alt="img"> </p>
<p>梯度下降法的优化</p>
<p><img src="/python.assets/wps36.jpg" alt="img"> </p>
<p><strong>Keras****人工神经网络库</strong></p>
<p>​	面向对象，完全模块</p>
<p>​	支持神经网络和深度学习的主流算法</p>
<p>​	支持多操作系统下的多GPU并行计算</p>
<p>​	作为深度学习库的前端</p>
<p>àSequential模型</p>
<p>​	神经网络框架</p>
<p>​	只有一组输入和一组输出</p>
<p>​	各层按照先后顺序堆叠</p>
<p>model &#x3D; tf.keras.Sequential()			# 建立Sequential模型</p>
<p>model.add( tf.keras.layers. )			# 添加层：全连接层，卷积层，池化层</p>
<p>例：	tf.keras.layers.Dense(</p>
<p>inputs		# 输入该网络层的数据</p>
<p>activation		# 激活函数</p>
<p>input_shape	# 输入数据的形状 )</p>
<p>model.summary()					# 查看摘要&#x2F;查看网络结构和参数信息</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="/python.assets/wps37.jpg" alt="img"></td>
</tr>
</tbody></table>
<p>例：创建多分类任务——三层神经网络</p>
<p>配置训练方法</p>
<p>​	Loss：损失函数</p>
<p>​	Optimizer：优化器</p>
<p>​	Metrics：模型训练时，我们希望输出的评测指标</p>
<p><img src="/python.assets/wps38.jpg" alt="img"> </p>
<p>From_logits&#x3D;False		表神经网络在输出前，已经用softmax函数将预测结果变换为概率分布，所有的输出结果为1；若没经过变换，则为True</p>
<p>优化器：<img src="/python.assets/wps39.jpg" alt="img"></p>
<p><img src="/python.assets/wps40.jpg" alt="img"> <img src="/python.assets/wps41.jpg" alt="img"></p>
<p>例：鸢尾花</p>
<p><img src="/python.assets/wps42.jpg" alt="img"> </p>
<p>训练模型：</p>
<p><img src="/python.assets/wps43.jpg" alt="img"> </p>
<p>例：手写数字识别</p>
<p><img src="/python.assets/wps44.jpg" alt="img"> </p>
<p>模型评估：</p>
<p><img src="/python.assets/wps45.jpg" alt="img"> </p>
<p>搭建模型6步：</p>
<p><img src="/python.assets/wps46.jpg" alt="img"> </p>
<p>例：<img src="/python.assets/wps47.jpg" alt="img"></p>
<p>保存神经网络模型参数</p>
<p><img src="/python.assets/wps48.jpg" alt="img"> </p>
<p><img src="/python.assets/wps49.jpg" alt="img"> </p>
<p>保存整个神经网络模型</p>
<p><img src="/python.assets/wps50.jpg" alt="img"> </p>
<p>CNN卷积神经网络</p>
<p><img src="/python.assets/wps51.jpg" alt="img"> </p>
<p>池化层<img src="/python.assets/wps52.jpg" alt="img"><img src="/python.assets/wps53.jpg" alt="img"><img src="/python.assets/wps54.jpg" alt="img"><img src="/python.assets/wps55.jpg" alt="img"></p>
<p><strong>Shapely****库</strong></p>
<p>object.distance(other)		# 返回两点距离</p>
<p>print(poly1.overlaps(poly2))     # 判断两个图形是否重叠，返回bool类型</p>
<p>print(poly1.exterior.coords[:])    # 打印图形坐标点</p>
<p># 旋转函数  origin：选择转心 1.center 中心# 默认  2.centroid 重心  3.(x, y)自定义坐标</p>
<p>a1 &#x3D; affinity.rotate(poly1, 90, origin&#x3D;’center’, use_radians&#x3D;False)</p>
<p>print(f’外部\n{poly3.exterior.coords[:]}’)    # 打印外部图形坐标点</p>
<p>print(f’内部\n{poly3.interiors[0]}’)       # 打印内部点坐标  interiors</p>
<p>print(a1.centroid.coords[:])    # 打印图形重心坐标点</p>
<p>print(poly1.area)        # 打印面积</p>
<p>print(poly1.bounds)       # 打印最大边界矩形坐标</p>
<p>object.convex_hull			# 返回包含对象中所有点的最小凸多边形的表示</p>
<p><strong>re**<strong>库</strong></strong>&lt;**<strong>正则表达式****&gt;</strong></p>
<p>总结</p>
<p>^ 匹配字符串的开始。</p>
<p>$ 匹配字符串的结尾。</p>
<p>\b 匹配一个单词的边界。</p>
<p>\d 匹配任意数字。</p>
<p>\D 匹配任意非数字字符。</p>
<p>x? 匹配一个可选的 x 字符 (换言之，它匹配 1 次或者 0 次 x 字符)。</p>
<p>x* 匹配0次或者多次 x 字符。</p>
<p>x+ 匹配1次或者多次 x 字符。</p>
<p>x{n,m} 匹配 x 字符，至少 n 次，至多 m 次。</p>
<p>(a|b|c) 要么匹配 a，要么匹配 b，要么匹配 c。</p>
<p>(x) 一般情况下表示一个记忆组 (remembered group)。你可以利用 re.search 函数返回对象的 groups() 函数获取它的值。</p>
<p>正则表达式中的点号通常意味着 “匹配任意单字符”</p>
<p><strong>例：</strong></p>
<p>string &#x3D; ‘tensorflow:Final best valid  0 loss&#x3D;0.20478513836860657 norm_loss&#x3D;0.767241849151384 roc&#x3D;0.8262403011322021 pr&#x3D;0.39401692152023315 calibration&#x3D;0.9863265752792358 rate&#x3D;0.0’</p>
<p># 提取 calibration&#x3D;0.9863265752792358 .</p>
<p># 匹配“calibration&#x3D;”后面的数字</p>
<p>pattern &#x3D; re.compile(r’(?&lt;&#x3D;calibration&#x3D;)\d+.?\d*’)</p>
<p>pattern.findall(string)</p>
<p># [‘0.9863265752792358’]</p>
<p>既然是提取数字，那么数字的形式一般是：整数，小数，整数加小数；</p>
<p>所以一般是形如：—-.—–；</p>
<p>根据上述正则表达式的含义，可写出如下的表达式：”\d+.?\d*”；</p>
<p>\d+匹配1次或者多次数字，注意这里不要写成<em>，因为即便是小数，小数点之前也得有一个数字；.?这个是匹配小数点的，可能有，也可能没有；\d</em>这个是匹配小数点之后的数字的，所以是0个或者多个；</p>
<h2 id="os库"><a href="#os库" class="headerlink" title="os库 "></a><a href="#context.1">os库</a><a name="section.1"> </a></h2><p>需 <code>import os</code></p>
<h3 id="总览"><a href="#总览" class="headerlink" title="总览 "></a><a href="#context.2">总览</a><a name="section.2"> </a></h3><table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#os.chdir(path)">os.chdir(path)</a></td>
<td>改变工作目录</td>
</tr>
<tr>
<td><a href="#os.getcwd()">os.getcwd()</a></td>
<td>获取当前的工作路径</td>
</tr>
<tr>
<td><a href="#os.listdir(path)">os.listdir(path)</a></td>
<td>传入任意一个path路径，返回的是该路径下所有<strong>文件</strong>和<strong>目录</strong>组成的列表</td>
</tr>
<tr>
<td><a href="#os.path.exists(path)">os.path.exists(path)</a></td>
<td>传入一个path路径，判断指定路径下的目录是否存在</td>
</tr>
<tr>
<td><a href="#os.mkdir(path)">os.mkdir(path)</a></td>
<td>传入一个path路径，创建单层(单个)文件夹</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="os-chdir-path"><a href="#os-chdir-path" class="headerlink" title="os.chdir(path) "></a><a href="#context.3">os.chdir(path)</a><a name="section.3"> </a></h3><p>改变工作目录</p>
<h3 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd() "></a><a href="#context.4">os.getcwd()</a><a name="section.4"> </a></h3><p>获取当前的工作路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">temp = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path) "></a><a href="#context.5">os.listdir(path)</a><a name="section.5"> </a></h3><p>传入任意一个path路径，返回的是该路径下所有<strong>文件</strong>和<strong>目录</strong>组成的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.listdir(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; [<span class="string">&#x27;test.sh&#x27;</span>, <span class="string">&#x27;demo.py&#x27;</span>, <span class="string">&#x27;main.py&#x27;</span>]</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path) "></a><a href="#context.6">os.path.exists(path)</a><a name="section.6"> </a></h3><p>传入一个path路径，判断指定路径下的目录是否存在。存在返回True，否则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.exists(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-mkdir-path"><a href="#os-mkdir-path" class="headerlink" title="os.mkdir(path) "></a><a href="#context.7">os.mkdir(path)</a><a name="section.7"> </a></h3><p>传入一个path路径，创建单层(单个)文件夹</p>
<p>注：如果文件夹已经存在，就会报错。因此创建文件夹之前，需要使用 <code>os.path.exists(path)</code> 函数判断文件夹是否存在</p>
<h3 id="os-path-join-path1-path2"><a href="#os-path-join-path1-path2" class="headerlink" title="os.path.join(path1, path2) "></a><a href="#context.8">os.path.join(path1, path2)</a><a name="section.8"> </a></h3><p>传入两个path路径，将该路径拼接起来，形成一个新的完整路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path1 = <span class="string">&quot;/home/hq&quot;</span></span><br><span class="line">path2 = <span class="string">&quot;wyh&quot;</span></span><br><span class="line">temp = os.path.join(path1,path2)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; /home/hq/wyh</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path) "></a><a href="#context.9">os.path.split(path)</a><a name="section.9"> </a></h3><p>传入一个完整的path路径，将其拆分为绝对路径和文件名2部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.split(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(temp[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(temp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; (<span class="string">&#x27;/home/hq&#x27;</span>, <span class="string">&#x27;wyh&#x27;</span>)</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; /home/hq</span><br><span class="line">&gt;&gt; wyh</span><br></pre></td></tr></table></figure>



<h3 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path) "></a><a href="#context.10">os.path.dirname(path)</a><a name="section.10"> </a></h3><p>传入一个完整的文件路径，只获取其绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.dirname(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; /home/hq</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path) "></a><a href="#context.11">os.path.basename(path)</a><a name="section.11"> </a></h3><p>传入一个完整的文件路径，只获取其文件名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.basename(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; wyh</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path) "></a><a href="#context.12">os.path.isdir(path)</a><a name="section.12"> </a></h3><p>传入一个完整的文件路径，判断它是否是文件夹</p>
<h3 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path) "></a><a href="#context.13">os.path.isfile(path)</a><a name="section.13"> </a></h3><p>传入一个完整的文件路径，判断它是否是文件</p>
<h3 id="os-path-sep"><a href="#os-path-sep" class="headerlink" title="os.path.sep "></a><a href="#context.14">os.path.sep</a><a name="section.14"> </a></h3><p>返回当前操作系统的路径分隔符</p>
<h3 id="os-path-getsize-path"><a href="#os-path-getsize-path" class="headerlink" title="os.path.getsize(path) "></a><a href="#context.15">os.path.getsize(path)</a><a name="section.15"> </a></h3><p>传入一个完整的文件路径，返回该文件的大小</p>
<h3 id="os-remove-path"><a href="#os-remove-path" class="headerlink" title="os.remove(path) "></a><a href="#context.16">os.remove(path)</a><a name="section.16"> </a></h3><p>删除文件</p>
<h3 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path) "></a><a href="#context.17">os.rmdir(path)</a><a name="section.17"> </a></h3><p>删除单层目录，非空抛出异常</p>
<h3 id="os-removedirs"><a href="#os-removedirs" class="headerlink" title="os.removedirs() "></a><a href="#context.18">os.removedirs()</a><a name="section.18"> </a></h3><p>递归删除目录，删除到非空文件为止</p>
<h3 id="os-rename-old-new"><a href="#os-rename-old-new" class="headerlink" title="os.rename(old,new) "></a><a href="#context.19">os.rename(old,new)</a><a name="section.19"> </a></h3><p>文件重命名</p>
<h3 id="os-curdir"><a href="#os-curdir" class="headerlink" title="os.curdir "></a><a href="#context.20">os.curdir</a><a name="section.20"> </a></h3><p>当前目录，相当于 <code>.</code></p>
<h3 id="os-pardir"><a href="#os-pardir" class="headerlink" title="os.pardir "></a><a href="#context.21">os.pardir</a><a name="section.21"> </a></h3><p>上级目录，相当于 <code>..</code></p>
<p>一般配合 [os.path.join(path1, path2)](#os.path.join(path1, path2)) 使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(path)</span><br><span class="line">temp = os.path.join(path, os.pardir)</span><br><span class="line">temp = os.path.abspath(temp)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path) "></a><a href="#context.22">os.path.abspath(path)</a><a name="section.22"> </a></h3><p>返回绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(os.curdir)) <span class="comment">#当前目录的绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(os.pardir)) <span class="comment">#上级目录的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj</span><br></pre></td></tr></table></figure>



<h3 id="os-chmod-file-mode"><a href="#os-chmod-file-mode" class="headerlink" title="os.chmod(file, mode) "></a><a href="#context.23">os.chmod(file, mode)</a><a name="section.23"> </a></h3><p>需 <code>import os, sys, stat</code></p>
<p>mode: ( 同linux )</p>
<ul>
<li><strong>stat.S_IXOTH:</strong> 其他用户有执行权0o001</li>
<li><strong>stat.S_IWOTH:</strong> 其他用户有写权限0o002</li>
<li><strong>stat.S_IROTH:</strong> 其他用户有读权限0o004</li>
<li><strong>stat.S_IRWXO:</strong> 其他用户有全部权限(权限掩码)0o007</li>
<li><strong>stat.S_IXGRP:</strong> 组用户有执行权限0o010</li>
<li><strong>stat.S_IWGRP:</strong> 组用户有写权限0o020</li>
<li><strong>stat.S_IRGRP:</strong> 组用户有读权限0o040</li>
<li><strong>stat.S_IRWXG:</strong> 组用户有全部权限(权限掩码)0o070</li>
<li><strong>stat.S_IXUSR:</strong> 拥有者具有执行权限0o100</li>
<li><strong>stat.S_IWUSR:</strong> 拥有者具有写权限0o200</li>
<li><strong>stat.S_IRUSR:</strong> 拥有者具有读权限0o400</li>
<li><strong>stat.S_IRWXU:</strong> 拥有者有全部权限(权限掩码)0o700</li>
<li><strong>stat.S_ISVTX:</strong> 目录里文件目录只有拥有者才可删除更改0o1000</li>
<li><strong>stat.S_ISGID:</strong> 执行此文件其进程有效组为文件所在组0o2000</li>
<li><strong>stat.S_ISUID:</strong> 执行此文件其进程有效用户为文件所有者0o4000</li>
<li><strong>stat.S_IREAD:</strong> windows下设为只读</li>
<li><strong>stat.S_IWRITE:</strong> windows下取消只读</li>
</ul>
<h3 id="os-system"><a href="#os-system" class="headerlink" title="os.system() "></a><a href="#context.24">os.system()</a><a name="section.24"> </a></h3><p>system函数可以将字符串转化成命令在服务器上运行；其原理是每一条system函数执行时，其会创建一个子进程在系统上执行命令行，子进程的执行结果无法影响主进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行多条指令</span></span><br><span class="line">os.system(<span class="string">&#x27;cd /usr/local &amp;&amp; mkdir aaa.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">os.system(<span class="string">&#x27;cd /usr/local ; mkdir aaa.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除文件夹以及内部文件</span></span><br><span class="line"><span class="keyword">if</span> os.sep == <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">    os.system(<span class="string">&quot;rd/s/q test&quot;</span>)	<span class="comment"># 删除test文件夹</span></span><br></pre></td></tr></table></figure>



<h3 id="os-stat-path"><a href="#os-stat-path" class="headerlink" title="os.stat(path) "></a><a href="#context.25">os.stat(path)</a><a name="section.25"> </a></h3><p>os.stat() 方法用于在给定的路径上执行一个系统 stat 的调用</p>
<p>参数</p>
<ul>
<li><strong>path</strong> – 指定路径</li>
</ul>
<p>返回值</p>
<p>stat 结构:</p>
<ul>
<li>st_mode: inode 保护模式</li>
<li>st_ino: inode 节点号。</li>
<li>st_dev: inode 驻留的设备。</li>
<li>st_nlink: inode 的链接数。</li>
<li>st_uid: 所有者的用户ID。</li>
<li>st_gid:** 所有者的组ID。</li>
<li>st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</li>
<li>st_atime: 上次访问的时间。</li>
<li>st_mtime:** 最后一次修改的时间。</li>
<li>st_ctime: 由操作系统报告的”ctime”。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">g_path_json = <span class="string">r&quot;D:\wyh\Work\Prj\book1\config.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件创建时间&quot;</span>, os.stat(g_path_json).st_ctime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最后一次修改时间&quot;</span>, os.stat(g_path_json).st_mtime)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(os.stat(g_path_json)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; 文件创建时间 <span class="number">1666941712.8650272</span></span><br><span class="line">&gt;&gt; 最后一次修改时间 <span class="number">1666947179.2710688</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;os.stat_result&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>















<h2 id="判断当前系统"><a href="#判断当前系统" class="headerlink" title="判断当前系统 "></a><a href="#context.26">判断当前系统</a><a name="section.26"> </a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line">plat = platform.system().lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> plat == <span class="string">&#x27;windows&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;windows系统&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> plat == <span class="string">&#x27;linux&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;linux系统&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 或者用 os.path.sep 判断文件分隔符</span></span><br><span class="line"><span class="comment"># linux 是 / (除号)</span></span><br><span class="line"><span class="comment"># windows 是 \</span></span><br></pre></td></tr></table></figure>



<h2 id="Json文件处理"><a href="#Json文件处理" class="headerlink" title="Json文件处理 "></a><a href="#context.27">Json文件处理</a><a name="section.27"> </a></h2><p>从 json 文件中读取数据（返回字典类型）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_data = json.load(<span class="built_in">open</span>(‘xxx.json’))</span><br></pre></td></tr></table></figure>



<p>python 类型数据写入 json 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dump(python_data, <span class="built_in">open</span>(‘xxx.json’, “w”))</span><br></pre></td></tr></table></figure>



<p><strong>注：建议用 with open() as xx</strong></p>
<h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源 "></a><a href="#context.28">镜像源</a><a name="section.28"> </a></h2><p>改为国内镜像源下载</p>
<p>常用国内源：</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<p>以清华大学镜像源下载为例：</p>
<h3 id="一、直接使用镜像源下载"><a href="#一、直接使用镜像源下载" class="headerlink" title="一、直接使用镜像源下载 "></a><a href="#context.29">一、直接使用镜像源下载</a><a name="section.29"> </a></h3><p>安装指令：pip install xxx(包名) -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> –trusted-host pypi.tuna.tsinghua.edu.cn</p>
<p>-i ：后为镜像源地址</p>
<p>–trusted-host ：后边指的是host,例清华大学镜像源地址为 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/%EF%BC%8Chost%E5%B0%B1%E6%98%AF%E6%8C%87http://%E5%92%8C/%E4%B9%8B%E9%97%B4%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%8D%B3pypi.tuna.tsinghua.edu.cn">https://pypi.tuna.tsinghua.edu.cn/simple/，host就是指http://和/之间的部分，即pypi.tuna.tsinghua.edu.cn</a></p>
<h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2 "></a><a href="#context.30">Jinja2</a><a name="section.30"> </a></h2><p>自定义过滤器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个示例 Python 脚本。</span></span><br><span class="line"><span class="comment"># 自定义ord过滤器，将字符变量转换为对应的ASCII码值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ord_filter</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ord</span>(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;创建要在模板文件中使用的对象&#x27;&#x27;&#x27;</span></span><br><span class="line">value1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter1</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成要引用的字典&#x27;&#x27;&#x27;</span></span><br><span class="line">var = &#123;<span class="string">&#x27;key1&#x27;</span>: value1, <span class="string">&#x27;iter1&#x27;</span>: iter1()&#125;</span><br><span class="line"></span><br><span class="line">string = <span class="built_in">open</span>(<span class="string">&#x27;test.template&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>).read()  <span class="comment"># 打开模板文件</span></span><br><span class="line">template = Template(string)</span><br><span class="line"></span><br><span class="line">ret = template.render(var, <span class="built_in">ord</span>=ord_filter)</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;test_case.robot&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>).write(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># test.template</span></span><br><span class="line"><span class="comment"># *** Test Cases ***</span></span><br><span class="line"><span class="comment"># &#123;%- for x in iter1 %&#125;</span></span><br><span class="line"><span class="comment"># &#123;% if x == &#x27;a&#x27; %&#125;</span></span><br><span class="line"><span class="comment"># 列表里有：&#123;&#123; x &#125;&#125;</span></span><br><span class="line"><span class="comment">#     [转换成int型的值为：]  &#123;&#123; ord(x) &#125;&#125;</span></span><br><span class="line"><span class="comment">#     [记录-符号的效果]   &#123;&#123; x -&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;% else %&#125;</span></span><br><span class="line"><span class="comment">#     &#123;&#123; x &#125;&#125;　　&#123;&#123; key1 &#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;%- endif %&#125;</span></span><br><span class="line"><span class="comment"># &#123;%- endfor %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_case.robot</span></span><br><span class="line"><span class="comment"># *** Test Cases ***</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 列表里有：a</span></span><br><span class="line"><span class="comment">#     [转换成int型的值为：]  97</span></span><br><span class="line"><span class="comment">#     [记录-符号的效果]   a</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     b　　[1, 2, 3]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     c　　[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2023/08/18/shell/</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><span id="more"></span>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">shell基本语句</a><a name="context.1"> </a></li>
<li><a href="#section.2">shell脚本实现ssh文件拷贝（自动输入密码）</a><a name="context.2"> </a></li>
<li><a href="#section.3">获取当前主机IPv4</a><a name="context.3"> </a></li>
<li><a href="#section.4">判断是否安装软件</a><a name="context.4"> </a></li>
<li><a href="#section.5">重定向输出</a><a name="context.5"> </a></li>
<li><a href="#section.6">一、shell介绍</a><a name="context.6"> </a></li>
<li><a href="#section.7">二、shell脚本规范</a><a name="context.7"> </a></li>
<li><a href="#section.8">三、shell脚本基本操作流程</a><a name="context.8"> </a></li>
<li><a href="#section.9">四、变量</a><a name="context.9"> </a><ul>
<li><a href="#section.10">格式</a><a name="context.10"> </a></li>
<li><a href="#section.11"><strong>变量命名规范</strong></a><a name="context.11"> </a></li>
<li><a href="#section.12">输出变量内容</a><a name="context.12"> </a></li>
<li><a href="#section.13">变量的释放</a><a name="context.13"> </a></li>
<li><a href="#section.14">设置变量为只读变量</a><a name="context.14"> </a></li>
<li><a href="#section.15">特殊的变量</a><a name="context.15"> </a></li>
</ul>
</li>
<li><a href="#section.16">五、read键盘获取单个变量&#x2F;多个变量值</a><a name="context.16"> </a><ul>
<li><a href="#section.17">获取单变量值</a><a name="context.17"> </a></li>
<li><a href="#section.18">获取多变量值</a><a name="context.18"> </a></li>
</ul>
</li>
<li><a href="#section.19">六 、参数传递</a><a name="context.19"> </a><ul>
<li><a href="#section.20">作用</a><a name="context.20"> </a></li>
<li><a href="#section.21">格式</a><a name="context.21"> </a></li>
<li><a href="#section.22">文件中接收参数的方式</a><a name="context.22"> </a></li>
</ul>
</li>
<li><a href="#section.23">七、if - 分支结构</a><a name="context.23"> </a><ul>
<li><a href="#section.24">格式1</a><a name="context.24"> </a></li>
<li><a href="#section.25">格式2</a><a name="context.25"> </a></li>
</ul>
</li>
<li><a href="#section.26">八、运算符</a><a name="context.26"> </a><ul>
<li><a href="#section.27">逻辑运算符</a><a name="context.27"> </a></li>
<li><a href="#section.28">比较运算符</a><a name="context.28"> </a></li>
<li><a href="#section.29">变量值递增操作</a><a name="context.29"> </a></li>
<li><a href="#section.30">变量递增赋值操作</a><a name="context.30"> </a></li>
</ul>
</li>
<li><a href="#section.31">九、case分支</a><a name="context.31"> </a></li>
<li><a href="#section.32">十、for循环结构</a><a name="context.32"> </a></li>
<li><a href="#section.33">十一、while循环结构</a><a name="context.33"> </a></li>
<li><a href="#section.34">十二、函数</a><a name="context.34"> </a><ul>
<li><a href="#section.35"><strong>查看返回值内容 $?</strong></a><a name="context.35"> </a></li>
</ul>
</li>
<li><a href="#section.36">十三、测试文件的状态方式1</a><a name="context.36"> </a></li>
<li><a href="#section.37">十四、文件状态判断2（去掉前面test）</a><a name="context.37"> </a></li>
<li><a href="#section.38">十五、字符串其他操作</a><a name="context.38"> </a><ul>
<li><a href="#section.39">获取字符串长度</a><a name="context.39"> </a></li>
<li><a href="#section.40">拼接字符串</a><a name="context.40"> </a></li>
<li><a href="#section.41">截取字符串</a><a name="context.41"> </a></li>
<li><a href="#section.42">查找字符串中的指定字符的索引</a><a name="context.42"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="shell基本语句"><a href="#shell基本语句" class="headerlink" title="shell基本语句 "></a><a href="#context.1">shell基本语句</a><a name="section.1"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取某一个文件或目录的上一级目录</span><br><span class="line">dirname 文件或目录</span><br><span class="line"># exp</span><br><span class="line">SCRIPT_FN=`realpath $0`</span><br><span class="line">SCRIPT_DIR=`dirname $SCRIPT_FN`</span><br><span class="line">echo $SCRIPT_DIR</span><br><span class="line">&gt;&gt; /home/users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取指定目录或文件的绝对路径</span><br><span class="line">realpath 文件或目录</span><br><span class="line"># exp</span><br><span class="line">SCRIPT_FN=`realpath $0`</span><br><span class="line">echo $SCRIPT_FN</span><br><span class="line">&gt;&gt; /d/wyh/Work/Prj/wiki_doc_build/build/test.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断目录是否存在</span><br><span class="line">if [ ! -d &quot;hubs_doc&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断文件是否存在</span><br><span class="line">if [ ! -f &quot;test.txt&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 判断返回值</span><br><span class="line">ret=`python3 demo.py`</span><br><span class="line">if [ &quot;$ret&quot; == 1 ]		# &quot;&quot;: 双引号表示保留一个参数</span><br><span class="line">then</span><br><span class="line">    echo &quot;Is 1!&quot;</span><br><span class="line">else</span><br><span class="line">    echo $ret</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup Command [ Arg … ] [　&amp; ]</span><br></pre></td></tr></table></figure>



<p><strong>nohup</strong> 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p>
<p><strong>nohup</strong> 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 <strong>$HOME&#x2F;nohup.out</strong> 文件中。</p>
<h2 id="shell脚本实现ssh文件拷贝（自动输入密码）"><a href="#shell脚本实现ssh文件拷贝（自动输入密码）" class="headerlink" title="shell脚本实现ssh文件拷贝（自动输入密码） "></a><a href="#context.2">shell脚本实现ssh文件拷贝（自动输入密码）</a><a name="section.2"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖 expect</span><br><span class="line">sudo apt-get install expect</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># xxx.sh 内容如下</span><br><span class="line"></span><br><span class="line">#!/usr/bin/expect -f 		# 指定使用此路径下的 expect</span><br><span class="line">set timeout 30				# 设置超时时间</span><br><span class="line">spawn scp TcrController james@192.168.1.119:/home/james/ws</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect eof</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># scp 命令介绍</span><br><span class="line"># 复制文件到目标</span><br><span class="line"># scp 文件 目标地址</span><br><span class="line"></span><br><span class="line"># -r 表示复制当前路径下的xxx整个文件到远端的wyh目录下[重命名为123]</span><br><span class="line">scp [-r] xxx user@xxx.xxx.xxx.xxx:/home/wyh[/123]</span><br></pre></td></tr></table></figure>





<h2 id="获取当前主机IPv4"><a href="#获取当前主机IPv4" class="headerlink" title="获取当前主机IPv4 "></a><a href="#context.3">获取当前主机IPv4</a><a name="section.3"> </a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地 ipv4</span></span><br><span class="line">ipv4_loc=`ifconfig -a | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk &#x27;&#123;print $2&#125;&#x27; | tr -d &quot;addr:&quot;`</span><br></pre></td></tr></table></figure>





<h2 id="判断是否安装软件"><a href="#判断是否安装软件" class="headerlink" title="判断是否安装软件 "></a><a href="#context.4">判断是否安装软件</a><a name="section.4"> </a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if ! [ -x &quot;$(command -v git)&quot; ]; then</span><br><span class="line">  echo &#x27;Error: git is not installed.&#x27; &gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出 "></a><a href="#context.5">重定向输出</a><a name="section.5"> </a></h2><p><a href="https://blog.csdn.net/icandoit_2014/article/details/121178276">(24条消息) shell中 ＞&amp; 的含义解释_wufeng_asia的博客-CSDN博客_shell中&amp;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">末尾的 &amp; 表示后台执行，终端不打印信息</span></span><br><span class="line">teedoc build &gt; build_log.txt &amp;</span><br></pre></td></tr></table></figure>







<h2 id="一、shell介绍"><a href="#一、shell介绍" class="headerlink" title="一、shell介绍 "></a><a href="#context.6">一、shell介绍</a><a name="section.6"> </a></h2><ol>
<li>shell 是一段应用程序，是用户和操作系统交互的一个桥梁，shell 通常就是 .sh 脚本</li>
<li>shell 是弱类型语言，定义变量不需要指定变量的类型</li>
</ol>
<h2 id="二、shell脚本规范"><a href="#二、shell脚本规范" class="headerlink" title="二、shell脚本规范 "></a><a href="#context.7">二、shell脚本规范</a><a name="section.7"> </a></h2><p>shell 脚本是以 .sh 结尾的文件<br>sh 文件的第一行内容为 <code>#!/bin/bash</code>    表示使用shell进行编程(不写也不会报错)<br>shell 中的注释：#</p>
<h2 id="三、shell脚本基本操作流程"><a href="#三、shell脚本基本操作流程" class="headerlink" title="三、shell脚本基本操作流程 "></a><a href="#context.8">三、shell脚本基本操作流程</a><a name="section.8"> </a></h2><p>建立 shell 脚本（使用vim编辑器)<br>vim 脚本名.sh</p>
<p>编写 shell 脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p><strong>运行shell脚本</strong></p>
<p>方式一:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh 脚本名.sh</span><br></pre></td></tr></table></figure>



<p>方式二:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x 脚本名.sh</span><br><span class="line"></span><br><span class="line">./脚本名.sh</span><br></pre></td></tr></table></figure>



<h2 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量 "></a><a href="#context.9">四、变量</a><a name="section.9"> </a></h2><h4 id="格式"><a href="#格式" class="headerlink" title="格式 "></a><a href="#context.10">格式</a><a name="section.10"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 变量名=变量值    (等于号两边没有空格)</span><br><span class="line">name=chengliang</span><br></pre></td></tr></table></figure>



<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范 "></a><a href="#context.11"><strong>变量命名规范</strong></a><a name="section.11"> </a></h4><p>(1)命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>(2)中间不能有空格，可以使用下划线（_）。<br>(3)不能使用标点符号。<br>(4)不能使用bash里的关键字（可用help命令查看保留关键字）</p>
<h4 id="输出变量内容"><a href="#输出变量内容" class="headerlink" title="输出变量内容 "></a><a href="#context.12">输出变量内容</a><a name="section.12"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo $变量名</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>



<h4 id="变量的释放"><a href="#变量的释放" class="headerlink" title="变量的释放 "></a><a href="#context.13">变量的释放</a><a name="section.13"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># unset 变量名</span><br><span class="line">unset name </span><br></pre></td></tr></table></figure>



<h4 id="设置变量为只读变量"><a href="#设置变量为只读变量" class="headerlink" title="设置变量为只读变量 "></a><a href="#context.14">设置变量为只读变量</a><a name="section.14"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># readonly 变量名</span><br><span class="line"># 注:只读变量的值不能被改变，也不能使用unset删除</span><br><span class="line">readonly name</span><br></pre></td></tr></table></figure>



<h4 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量 "></a><a href="#context.15">特殊的变量</a><a name="section.15"> </a></h4><p>(1)双引号 “<br>如果双引号中存在 $变量名的话，那么输出结果将会是变量名对应的变量值<br>(2)单引号 ’<br>如果变量值中存在**$变量名**，那么将原样输出<br>(3)反单引号&#96;&#96;(Tab上面的键)<br>反单引号中可以存放的是linux命令，运行脚本时相当于运行linux命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1=world</span><br><span class="line">name2=”hello$name1”</span><br><span class="line">name3=’hello$name1’</span><br><span class="line">echo $name2      	# 输出---&gt;helloworld</span><br><span class="line">echo $name3      	# 输出---&gt;hello$name1</span><br></pre></td></tr></table></figure>



<h2 id="五、read键盘获取单个变量-多个变量值"><a href="#五、read键盘获取单个变量-多个变量值" class="headerlink" title="五、read键盘获取单个变量&#x2F;多个变量值 "></a><a href="#context.16">五、read键盘获取单个变量&#x2F;多个变量值</a><a name="section.16"> </a></h2><h4 id="获取单变量值"><a href="#获取单变量值" class="headerlink" title="获取单变量值 "></a><a href="#context.17">获取单变量值</a><a name="section.17"> </a></h4><ul>
<li>不带提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read 变量名</span><br></pre></td></tr></table></figure>

<ul>
<li>带有提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “提示文字” 变量名</span><br></pre></td></tr></table></figure>

<h4 id="获取多变量值"><a href="#获取多变量值" class="headerlink" title="获取多变量值 "></a><a href="#context.18">获取多变量值</a><a name="section.18"> </a></h4><ul>
<li>不带提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read 变量1名 变量2名</span><br></pre></td></tr></table></figure>



<ul>
<li>带有提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “提示文字” 变量1名 变量2名</span><br></pre></td></tr></table></figure>



<p>注:终端输入值时也要用空格隔开</p>
<p><img src="/shell.assets/image-20220921203404445.png" alt="image-20220921203404445"></p>
<h2 id="六-、参数传递"><a href="#六-、参数传递" class="headerlink" title="六 、参数传递 "></a><a href="#context.19">六 、参数传递</a><a name="section.19"> </a></h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用 "></a><a href="#context.20">作用</a><a name="section.20"> </a></h4><p>向shell脚本文件中传递数据，在运行脚本时一起传递</p>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式 "></a><a href="#context.21">格式</a><a name="section.21"> </a></h4><p>命令 文件名 参数（运行文件时的命令，脚本中使用$1表示参数值）</p>
<h4 id="文件中接收参数的方式"><a href="#文件中接收参数的方式" class="headerlink" title="文件中接收参数的方式 "></a><a href="#context.22">文件中接收参数的方式</a><a name="section.22"> </a></h4><p>$1—&gt;表示第一个参数<br>$2—&gt;表示第二个参数<br>$3—&gt;第三个参数<br>$n—&gt;表示第n个参数<br>$0—&gt;代表文件名<br>$@ : 显示全部参数<br>$#:  显示参数的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.sh</span><br><span class="line">    #!/bin/bash</span><br><span class="line">  1 echo this is $2</span><br><span class="line">  2 </span><br><span class="line">  3 echo this is $1</span><br><span class="line">  4 </span><br><span class="line">  5 echo this is $2</span><br></pre></td></tr></table></figure>


<p>运行结果</p>
<p><img src="/shell.assets/image-20220921203533180.png" alt="image-20220921203533180"></p>
<h2 id="七、if-分支结构"><a href="#七、if-分支结构" class="headerlink" title="七、if - 分支结构 "></a><a href="#context.23">七、if - 分支结构</a><a name="section.23"> </a></h2><h4 id="格式1"><a href="#格式1" class="headerlink" title="格式1 "></a><a href="#context.24">格式1</a><a name="section.24"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># exp 两个变量判断是否相等</span><br><span class="line">if [ &quot;$var1&quot; = &quot;$var2&quot; ]; then</span><br><span class="line">　　echo &#x27;$var1 eq $var2&#x27;</span><br><span class="line">else</span><br><span class="line">　　echo &#x27;$var1 not eq $var2&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># exp 判断普通文件$doiido是否存，若不存在，则新建一个</span><br><span class="line">if [ ! -f &quot;$doiido&quot; ]; then</span><br><span class="line">　　touch &quot;$doiido&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="格式2"><a href="#格式2" class="headerlink" title="格式2 "></a><a href="#context.25">格式2</a><a name="section.25"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">elif [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">else</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 判断学生的成绩，范围在90-100提示优秀，80-90之间提示良好,70-80之间则提示一般，60-70之间提示及格。其他则提示不及格</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入成绩:&quot; score</span><br><span class="line">if [ &quot;$score&quot; -ge 90 -a &quot;$score&quot; -le 100 ];then</span><br><span class="line">        echo &quot;优秀&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 80 -a &quot;$score&quot; -lt 90 ];then</span><br><span class="line">        echo &quot;良好&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 70 -a &quot;$score&quot; -lt 80 ];then</span><br><span class="line">        echo &quot;一般&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 60 -a &quot;$score&quot; -lt 70 ];then</span><br><span class="line">        echo &quot;及格&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;不及格&quot;</span><br><span class="line">fi</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小小的圈圈」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36334897/article/details/105222836</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<ol>
<li>条件两边要有空格</li>
<li>多个条件间要有空格</li>
<li>if后面要有空格</li>
<li>条件中如果存在变量，那么变量的两边要有双引号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断任意一个目录是否为空</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入需要判断的目录:&quot; dir</span><br><span class="line">m=`ls $dir`</span><br><span class="line">if [ &quot;$m&quot; == &quot;&quot; ];then</span><br><span class="line">        echo &quot;$dir目录为空&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;$dir目录不为空&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：echo语句不缩进也不会报错，缩进只是格式上看着清楚</p>
<h2 id="八、运算符"><a href="#八、运算符" class="headerlink" title="八、运算符 "></a><a href="#context.26">八、运算符</a><a name="section.26"> </a></h2><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符 "></a><a href="#context.27">逻辑运算符</a><a name="section.27"> </a></h4><p>且：-a<br>或: -o<br>非: !</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断用户输入的用户名和密码是否为admin 123456,如果是则提示登录成功，否则提示失败</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入用户名和密码:&quot; username passward</span><br><span class="line">if [ &quot;$username&quot; == &quot;admin&quot; -a  &quot;$passward&quot; == &quot;123456&quot; ];then</span><br><span class="line">        echo &quot;登录成功&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;登录失败&quot;</span><br></pre></td></tr></table></figure>



<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符 "></a><a href="#context.28">比较运算符</a><a name="section.28"> </a></h4><p>（1）数值间的比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-eq    # 判断是否相等(equal)</span><br><span class="line">-ne    # 判断是否不相等(not equal)</span><br><span class="line">-gt    # 判断是否大于(greater than)</span><br><span class="line">-ge    # 判断是否大于等于(greater equal)</span><br><span class="line">-lt    # 判断是否小于(less than)</span><br><span class="line">-le    # 判断是否小于等于(less than equal)</span><br></pre></td></tr></table></figure>



<p>（2）字符串之间的比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==    # 判断两个字符串是否相等</span><br><span class="line">!=    # 判断两个字符串是否不相等</span><br><span class="line">-z    # 检查字符串长度是否为0</span><br><span class="line">-n    # 检查字符串长度是否不为0</span><br><span class="line">-$    # 检查字符串是否不为空</span><br></pre></td></tr></table></figure>



<h4 id="变量值递增操作"><a href="#变量值递增操作" class="headerlink" title="变量值递增操作 "></a><a href="#context.29">变量值递增操作</a><a name="section.29"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((i++))</span><br><span class="line">((i+=1))</span><br><span class="line">i=[i+1]</span><br><span class="line">let i=i+1</span><br><span class="line">i=$(($i+1))</span><br></pre></td></tr></table></figure>



<h4 id="变量递增赋值操作"><a href="#变量递增赋值操作" class="headerlink" title="变量递增赋值操作 "></a><a href="#context.30">变量递增赋值操作</a><a name="section.30"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=$(($s+$i))</span><br><span class="line">s=$[$s+$i]</span><br><span class="line">((s=$s+$i))</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输入数字，判断是否大于0，如果大于0则将该数字-1并输出，否则+1输出</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入一个数值:&quot; num</span><br><span class="line">if [ &quot;$num&quot; -gt 0 ];then</span><br><span class="line">        ((num-=1))</span><br><span class="line">        echo &quot;$num&quot;</span><br><span class="line">else</span><br><span class="line">        ((num+=1))</span><br><span class="line">        echo &quot;$num&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="九、case分支"><a href="#九、case分支" class="headerlink" title="九、case分支 "></a><a href="#context.31">九、case分支</a><a name="section.31"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">…</span><br><span class="line">*) # 上面条件均不满足，默认语句</span><br><span class="line">语句;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<ol>
<li><p>case这一行最后必须为in</p>
</li>
<li><p>;;    结束语句</p>
</li>
<li><p>*为默认</p>
</li>
<li><p>esac—&gt;case语句的结束</p>
</li>
<li><p>值可以是字符串也可以是数字</p>
</li>
<li><p>“值”还可以是区间范围,范围[0-9]</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输入一个字母，判断该用户选择哪款产品，A：笔记本 B：电饭煲 C：小台灯</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入:&quot; data</span><br><span class="line">case $data in</span><br><span class="line">&quot;A&quot;)</span><br><span class="line">        echo &quot;笔记本&quot;;;</span><br><span class="line">&quot;B&quot;)</span><br><span class="line">        echo &quot;电饭煲&quot;;;</span><br><span class="line">&quot;C&quot;)</span><br><span class="line">        echo &quot;小台灯&quot;;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># 请输入对客服的满意度，【0-3】不满意，【4-6】满意，【7-9】非常满意</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入您的满意度:&quot; scr</span><br><span class="line">case $scr in</span><br><span class="line">[0-3])</span><br><span class="line">        echo &quot;不满意&quot;;;</span><br><span class="line">[4-6])</span><br><span class="line">        echo &quot;一般满意&quot;;;</span><br><span class="line">[7-9])</span><br><span class="line">        echo &quot;非常满意&quot;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h2 id="十、for循环结构"><a href="#十、for循环结构" class="headerlink" title="十、for循环结构 "></a><a href="#context.32">十、for循环结构</a><a name="section.32"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量名 in 列表</span><br><span class="line">do 语句</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 输出1-10之间的数</span><br><span class="line">#!/bin/bash</span><br><span class="line">for i in 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>seq 数列生成式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq start step max</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 使用seq生成1-10并序列输出1-10之间的数</span><br><span class="line">#!/bin/bash</span><br><span class="line">for i in `seq 1 1 10` (也可为1 10,省略步长）   </span><br><span class="line"># seq为命令，所以要加反单引号，</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h2 id="十一、while循环结构"><a href="#十一、while循环结构" class="headerlink" title="十一、while循环结构 "></a><a href="#context.33">十一、while循环结构</a><a name="section.33"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ 条件 ]</span><br><span class="line">do</span><br><span class="line">命令</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 求1-100之间的和</span><br><span class="line">#!/bin/bash</span><br><span class="line">i=1</span><br><span class="line">sum=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">  sum=$(($sum+$i))</span><br><span class="line">  ((i++))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数 "></a><a href="#context.34">十二、函数</a><a name="section.34"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名()</span><br><span class="line">&#123; 代码 &#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数中的参数</strong></p>
<p>使用$n来接收数据</p>
<p><strong>返回值</strong></p>
<p>函数中默认的存在返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确时返回0 # 函数执行没有错误</span><br><span class="line">错误时返回1 # 函数执行出错</span><br></pre></td></tr></table></figure>



<h4 id="查看返回值内容"><a href="#查看返回值内容" class="headerlink" title="查看返回值内容 $? "></a><a href="#context.35"><strong>查看返回值内容 $?</strong></a><a name="section.35"> </a></h4><p><strong>函数调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名</span><br></pre></td></tr></table></figure>

<p><strong>注</strong><br>必须先定义再调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exp 1</span><br><span class="line"># 定义一个打印hello world函数并调用</span><br><span class="line">#!/bin/bash</span><br><span class="line">hello()&#123;      # 定义函数</span><br><span class="line">  echo &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello  #调用函数 </span><br><span class="line"></span><br><span class="line"># exp 2</span><br><span class="line"># 输入任意两个整数进行求和运算，并打印结果</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入第一个数:&quot; num1</span><br><span class="line">read -p &quot;请输入第二个数:&quot; num2</span><br><span class="line">add()&#123;         # 定义函数</span><br><span class="line">        s=$(($1+$2))     # 数值运算</span><br><span class="line">        echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add $num1 $num2    # 调用函数及传参</span><br></pre></td></tr></table></figure>



<h2 id="十三、测试文件的状态方式1"><a href="#十三、测试文件的状态方式1" class="headerlink" title="十三、测试文件的状态方式1 "></a><a href="#context.36">十三、测试文件的状态方式1</a><a name="section.36"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test 参数 $目录名</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e表示文件是否存在</span><br><span class="line">-f 表示文件是否存在且为文件</span><br><span class="line">-d 表示文件名是否存在且为目录</span><br><span class="line">-r 可读</span><br><span class="line">-w 可写</span><br><span class="line">-x 可执行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exp</span><br><span class="line"># 判断用户输入的目录是否存在，如果存在则统计目录下的文件个数，否则提示用户该目录不存在</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入目录:&quot; dir</span><br><span class="line">if test -d $dir      # if后面的条件不加中括号</span><br><span class="line">then</span><br><span class="line">        num=`ls -l | wc -l`</span><br><span class="line">        echo &quot;该目录下的文件个数为:$num个&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;该目录不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="十四、文件状态判断2（去掉前面test）"><a href="#十四、文件状态判断2（去掉前面test）" class="headerlink" title="十四、文件状态判断2（去掉前面test） "></a><a href="#context.37">十四、文件状态判断2（去掉前面test）</a><a name="section.37"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r　　　　文件是否存在且可读</span><br><span class="line">-w　　　　文件是否存在且可写</span><br><span class="line">-x 文件是否存在且可执行</span><br><span class="line">-f　　　　文件是否存在且是普通文件</span><br><span class="line">-d　　　　文件是否存在且是一个目录</span><br><span class="line">-e 文件是否存在</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断用户输入的内容是否为空，为空则提示，不为空则判断是否为目录，不为目录则判断是否为文件，否则提示错误信息</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入信息&quot; data</span><br><span class="line">if [ $data == &quot;&quot; ];then</span><br><span class="line">        echo &quot;输入为空&quot;</span><br><span class="line">elif [ -d $data ](也可以用[ -d“$data”]);then</span><br><span class="line">        echo &quot;输入为一个目录&quot;</span><br><span class="line">elif [ -f $data ];then</span><br><span class="line">        echo &quot;输入为一个文件&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;输入错误&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="十五、字符串其他操作"><a href="#十五、字符串其他操作" class="headerlink" title="十五、字符串其他操作 "></a><a href="#context.38">十五、字符串其他操作</a><a name="section.38"> </a></h2><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度 "></a><a href="#context.39">获取字符串长度</a><a name="section.39"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#字符串名&#125;</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line">a=hello</span><br><span class="line">echo $&#123;#a&#125;   ---&gt;5</span><br></pre></td></tr></table></figure>



<h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串 "></a><a href="#context.40">拼接字符串</a><a name="section.40"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">echo hello,&#x27;$str&#x27;   # 单引号拼接  &gt; hello,$str</span><br><span class="line">echo hello,”$str”   # 双引号拼接  &gt; hello,world</span><br></pre></td></tr></table></figure>



<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串 "></a><a href="#context.41">截取字符串</a><a name="section.41"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;字符串名:start:end&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong><br>①索引从0开始<br>②截取的字符串包括start和end位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">echo $&#123;str:1:3&#125; ---&gt;ell</span><br></pre></td></tr></table></figure>



<h4 id="查找字符串中的指定字符的索引"><a href="#查找字符串中的指定字符的索引" class="headerlink" title="查找字符串中的指定字符的索引 "></a><a href="#context.42">查找字符串中的指定字符的索引</a><a name="section.42"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr index “$字符串名” 字符</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">expr index &quot;$str&quot; e  &gt;&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
</search>
