<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++</title>
    <url>/2023/07/26/C++/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">重载</a><a name="context.1"> </a></li>
<li><a href="#section.2">STL</a><a name="context.2"> </a></li>
<li><a href="#section.3">pair容器</a><a name="context.3"> </a></li>
<li><a href="#section.4">list（链表）</a><a name="context.4"> </a></li>
<li><a href="#section.5">vector和list的区别</a><a name="context.5"> </a></li>
<li><a href="#section.6">deque（双端数组）</a><a name="context.6"> </a></li>
<li><a href="#section.7">stack &#x2F; queue</a><a name="context.7"> </a></li>
<li><a href="#section.8">priority_queue</a><a name="context.8"> </a></li>
<li><a href="#section.9">map &#x2F; set</a><a name="context.9"> </a></li>
<li><a href="#section.10">map &#x2F; unordered_map</a><a name="context.10"> </a></li>
<li><a href="#section.11">multimap</a><a name="context.11"> </a></li>
<li><a href="#section.12">C++模板全特化和偏特化</a><a name="context.12"> </a></li>
<li><a href="#section.13">lambda表达式</a><a name="context.13"> </a></li>
<li><a href="#section.14">智能指针</a><a name="context.14"> </a><ul>
<li><a href="#section.15">定义</a><a name="context.15"> </a></li>
<li><a href="#section.16">shared_ptr（常用）</a><a name="context.16"> </a></li>
<li><a href="#section.17">weak_ptr</a><a name="context.17"> </a></li>
<li><a href="#section.18">unique_ptr</a><a name="context.18"> </a></li>
<li><a href="#section.19">auto_ptr</a><a name="context.19"> </a></li>
</ul>
</li>
</ul>
<hr>
<span id="more"></span>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载 "></a><a href="#context.1">重载</a><a name="section.1"> </a></h2><p>形式：</p>
<p><strong>[返回值] operator[运算符] (参数…) { … }；</strong></p>
<p>例：重载类运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> _hour;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _sec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span> hour = <span class="number">0</span>, <span class="type">int</span> min = <span class="number">0</span>, <span class="type">int</span> sec = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_hour = hour;</span><br><span class="line">		_min = min;</span><br><span class="line">		_sec = sec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _sec &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为方便演示，让小时+1，但不再判断时间正确性</span></span><br><span class="line">	Time&amp; <span class="keyword">operator</span>++()<span class="comment">// ++A</span></span><br><span class="line">	&#123;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);<span class="comment">//因为自增直接返回this用引用接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	Time <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//A++，参数写int或int i都可以</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Time <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;<span class="comment">//需要返回this自增之前的结果，所以用临时变量返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「就要 宅在家」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/weixin_61857742/article/details/126010673</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 友元函数重载流提取 &lt;&lt; / &gt;&gt;</span></span><br><span class="line"><span class="comment">// 对于流而言，因为是双目运算符，this指针本应该指向左边的类，但左操作数是一个流，又与this的类型冲突。</span></span><br><span class="line"><span class="comment">// 这时，就需要用到友元函数friend。友元函数本身是一个普通函数，但是作为类的友元，能够调用类内的成员，包括private。而且参数不用被类限制为第一个必须是this所指的对象本身。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class &#123;</span></span><br><span class="line"><span class="comment">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Time&amp; t);//友元函数，声明</span></span><br><span class="line"><span class="comment">	friend istream&amp; operator&gt;&gt;(istream&amp; in, Time&amp; t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="STL"><a href="#STL" class="headerlink" title="STL "></a><a href="#context.2">STL</a><a name="section.2"> </a></h2><p>STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是：</p>
<ol>
<li><p><strong>容器</strong></p>
<p>各种数据结构，如vector、list、deque、set、map等，⽤来存放数据，从实现角度来看，STL 容器是⼀种 <code>class template</code></p>
</li>
<li><p><strong>算法</strong></p>
<p>各种常⽤的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是⼀种 <code>function template</code></p>
</li>
<li><p><strong>迭代器</strong></p>
<p>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是⼀种将 operator* , operator-&gt; , operator++, operator– 等指针相关操作予以重载的 <code>class template</code>。  </p>
<p>所有STL容器都附带有⾃⼰专属的迭代器，只有容器的设计者才知道如何遍历⾃⼰的元素。  </p>
<p>原⽣指针(native pointer)也是⼀种迭代器。</p>
</li>
<li><p><strong>仿函数</strong></p>
<p>⾏为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是⼀种重载了operator() 的 class 或者 class template</p>
</li>
<li><p><strong>适配器（配接器）</strong></p>
<p>⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东西。  </p>
<p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应</p>
</li>
<li><p><strong>空间配置器</strong></p>
<p>负责空间的配置与管理。从实现角度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的 class template</p>
<p>⼀般的分配器的 std:alloctor 都含有两个函数 allocate 与 deallocte，这两个函数分别调⽤ operator new() 与 delete()，这两个函数的底层⼜分别是malloc() and free(); 但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p>
</li>
</ol>
<p><strong>容器之间的实现关系以及分类：</strong></p>
<p><img src="/C++.assets/image-20230615150413812.png" alt="image-20230615150413812"></p>
<p><strong>STL六⼤组件的交互关系：</strong></p>
<ol>
<li>容器通过空间配置器取得数据存储空间  </li>
<li>算法通过迭代器存储容器中的内容  </li>
<li>仿函数可以协助算法完成不同的策略的变化 </li>
<li>适配器可以修饰仿函数</li>
</ol>
<p><strong>STL的优点</strong></p>
<p>STL 具有⾼可重⽤性，⾼性能，⾼移植性，跨平台的优点</p>
<ol>
<li>⾼可重⽤性<br>STL 中几乎所有的代码都采⽤了模板类和模版函数的⽅式实现，这相⽐于传统的由函数和类组成的库来说提供了更好的代码重⽤机会</li>
<li>⾼性能<br>如 map 可以⾼效地从⼗万条记录⾥⾯查找出指定的记录，因为 map 是采⽤红黑树的变体实现的</li>
<li>⾼移植性<br>如在项⽬ A 上⽤ STL 编写的模块，可以直接移植到项⽬ B 上</li>
</ol>
<p><strong>STL 的⼀个重要特性是将数据和操作分离</strong></p>
<p>数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当 “粘合剂” 以使算法可以和容器交互运作</p>
<h2 id="pair容器"><a href="#pair容器" class="headerlink" title="pair容器 "></a><a href="#context.3">pair容器</a><a name="section.3"> </a></h2><p>保存两个数据成员，⽤来⽣成特定类型的模板</p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line"><span class="comment">///&lt; 数据成员是public，两个成员分别是first和second</span></span><br></pre></td></tr></table></figure>



<p>vector 容器</p>
<p><strong>底层：</strong></p>
<p>Vector在堆中分配了⼀段连续的内存空间来存放元素</p>
<p>底层为动态数组</p>
<p>扩容：</p>
<ol>
<li>固定扩容</li>
<li>加倍扩容</li>
</ol>
<h2 id="list（链表）"><a href="#list（链表）" class="headerlink" title="list（链表） "></a><a href="#context.4">list（链表）</a><a name="section.4"> </a></h2><p><strong>中间位置的插入与删除是 O(1)</strong></p>
<p><strong>实现方式：</strong>双向链表</p>
<h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别 "></a><a href="#context.5">vector和list的区别</a><a name="section.5"> </a></h2><ol>
<li>vector 底层实现是数组；list 是双向链表 </li>
<li>vector 是顺序内存，⽀持随机访问，list 不⾏ </li>
<li>vector 在中间节点进⾏插⼊删除会导致内存拷⻉，list不会 </li>
<li>vector ⼀次性分配好内存，不够时才进⾏翻倍扩容；list 每次插⼊新节点都会进⾏内存申请 </li>
<li>vector 随机访问性能好，插⼊删除性能差；list 随机访问性能差，插⼊删除性能好</li>
</ol>
<h2 id="deque（双端数组）"><a href="#deque（双端数组）" class="headerlink" title="deque（双端数组） "></a><a href="#context.6">deque（双端数组）</a><a name="section.6"> </a></h2><p><strong>在头&#x2F;尾部插入&#x2F;删除时间复杂度为 O(1)</strong></p>
<p><strong>致命缺陷：</strong>不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下</p>
<p>因此，需要线性结构时，大多数情况下优先考虑<code>vector</code>和<code>list</code>，<code>deque</code>的应用并不多，而目前能看到的一个应用就是，STL用其作为<code>stack</code>和<code>queue</code>的底层数据结构。</p>
<p>⽀持快速随机访问，由于 deque 需要处理内部跳转，因此速度上没有 vector 快</p>
<p>deque 是⼀个<strong>双端开口</strong>的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接</p>
<p><strong>注意：</strong></p>
<p>由于deque的迭代器⽐vector要复杂，这影响了各个运算层面，所以除⾮必要尽量使⽤ vector；<br>为了提⾼效率，在对deque进⾏排序操作的时候，我们可以先把 deque 复制到 vector 中再进⾏排序最后在复制回 deque</p>
<p><img src="/C++.assets/image-20230615153051799.png" alt="image-20230615153051799"></p>
<p>deque采⽤⼀块map作为主控，其中的每个元素都是指针，指向另⼀⽚连续线性空间，称之为 缓存区，这个区才是⽤来储存数据的</p>
<h2 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack &#x2F; queue "></a><a href="#context.7">stack &#x2F; queue</a><a name="section.7"> </a></h2><p>概述：栈与队列被称之为 deque 的配接器，其底层是以 deque 为底部架构。通过 deque 执⾏具体操作</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue "></a><a href="#context.8">priority_queue</a><a name="section.8"> </a></h2><pre><code>     优先队列是一种容器适配器，采用了堆这样的数据结构，保证了第一个元素总是整个优先队列中最大的(或最小的)元素。  优先队列默认使用vector作为底层存储数据的容器，在vector上使用了堆算法将vector中的元素构造成堆的结构，所以其实我们就可以把它当作堆，凡是需要用堆的位置，都可以考虑优先队列。
</code></pre>
<p>​		 默认情况下 <code>priority_queue</code> 是大堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="comment">///&lt; 优先队列底层使用的存储结构，可以看出来，默认采用vector</span></span><br><span class="line">          <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;  <span class="comment">///&lt; 定义优先队列中元素的比较方式的类，默认是按小于(less)的方式比较，</span></span><br><span class="line">                                                                <span class="comment">///&lt; 这种比较方式创建出来的就是大堆。所以优先队列默认就是大堆</span></span><br><span class="line">                                                                <span class="comment">///&lt; 如果需要创建小堆，就需要将less改为greater</span></span><br><span class="line">          &gt; <span class="keyword">class</span> priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载比较函数 Compare</span></span><br><span class="line"><span class="comment">class mycomparison &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;</span></span><br><span class="line"><span class="comment">        return lhs.second &gt; rhs.second;  ///&lt; 此处与快排的排序相反， &gt; 表从小到大</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：priority_queue 无迭代器！！</strong></p>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map &#x2F; set "></a><a href="#context.9">map &#x2F; set</a><a name="section.9"> </a></h2><p>有序（从小到大），底层为<strong>红黑树</strong></p>
<p><strong>共同点：</strong>都是C++的关联容器，只是通过它提供的接口对里面的元素进行访问，底层都是采⽤红黑树实现</p>
<p><strong>不同点：</strong></p>
<p>set：⽤来判断某⼀个元素是不是在⼀个组里面。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典</p>
<p><strong>优点：</strong></p>
<p>查找某⼀个数的时间为 <code>O(logn)</code>；遍历时采⽤ iterator，效果不错</p>
<p><strong>缺点：</strong></p>
<p>每次插⼊值的时候，都需要调整红黑树，效率有⼀定影响</p>
<p><strong>重载 &lt; 排序方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age):<span class="built_in">name_</span>(name),<span class="built_in">age_</span>(age)&#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Student &amp;s) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(name_ != s.name_)&#123;</span><br><span class="line">            <span class="keyword">return</span> name_ &lt; s.name_;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age_ &lt; s.age_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::string <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name_ + <span class="string">&quot;, age:&quot;</span> + std::<span class="built_in">to_string</span>(age_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    set&lt;Student&gt; s;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;Danney&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        cout &lt;&lt; it.<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小梦_人生如戏」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/yu532164710/article/details/105194036</span></span><br></pre></td></tr></table></figure>



<p><strong>细节：</strong></p>
<ol>
<li><strong>为什么要成倍的扩容而不是⼀次增加⼀个固定⼤⼩的容量呢？</strong><br>采⽤成倍⽅式扩容，可以保证常数的时间复杂度，⽽增加指定⼤⼩的容量只能达到O(n)的时间复杂度</li>
<li><strong>为什么是以两倍的⽅式扩容而不是三倍四倍，或者其他⽅式呢？</strong><br>考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是 1.5 或 2；GCC 是 2；VS 是 1.5，k &#x3D; 2 每次扩展的新尺寸必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤ 1.5 倍的增⻓⽅式可以更好的实现对内存的重复利用</li>
</ol>
<p><strong>注：C++并没有规定扩容因子K，这是由标准库的实现者决定的</strong></p>
<h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map &#x2F; unordered_map "></a><a href="#context.10">map &#x2F; unordered_map</a><a name="section.10"> </a></h2><p>map中元素是⼀些 <code>key-value</code> 对，关键字起索引作⽤，值表示和索引相关的数据</p>
<p><strong>底层实现：</strong></p>
<p><code>map</code> 底层是基于<strong>红黑树</strong>实现的，因此map内部元素排列是有序的<br><code>unordered_map</code> 底层则是基于<strong>哈希表</strong>实现的，因此其元素的排列顺序是杂乱⽆序的</p>
<table>
<thead>
<tr>
<th></th>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>有序性，这是map结构最⼤的优点，<br />其元素的有序性在很多应⽤中都会简化很多的操作<br />map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为 O(logn)</td>
<td>查找、删除、添加的速度快，时间复杂度为常数级O(1）</td>
</tr>
<tr>
<td>缺点</td>
<td>查找、删除、增加等操作平均时间复杂度较慢，与 n 相关</td>
<td>因为unordered_map内部基于哈希表，<br />以（key,value）对的形式存储，因此空间占⽤率⾼<br />unordered_map的查找、删除、添加的时间复杂度不稳定<br />平均为O(1)，取决于哈希函数，极端情况下可能为O(n)</td>
</tr>
</tbody></table>
<p><strong>问题：</strong></p>
<ol>
<li><strong>为什么 <code>insert</code> 之后，以前保存的 <code>iterator</code> 不会失效？</strong><br><strong>答：</strong> 因为 map 和 set 存储的是结点，不需要内存拷⻉和内存移动。但是像 vector 在插入数据时如果内存不够会重新开辟一块内存。 map 和 set 的 iterator 指向的是节点的指针，vector 指向的是内存的某个位置</li>
<li><strong>为何 map 和 set 的插入删除效率比其他序列容器高？</strong><br><strong>答：</strong> 因为 map 和 set 底部使用红黑树实现，插入和删除的时间复杂度是 <code>O(logn)</code>，而像 vector 这样的序列容器插入和删除的时间复杂度是 <code>O(N)</code></li>
</ol>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap "></a><a href="#context.11">multimap</a><a name="section.11"> </a></h2><p>multimap是C++ STL中的一个关联容器，它与map类似，但可以存储多个具有相同键值的元素。</p>
<p>multimap使用红黑树实现，因此它的插入、查找、删除操作的时间复杂度为O(log n)，其中n为multimap中元素的数量。由于multimap允许重复的键值，因此对于某些操作，如查找、删除等，复杂度可能会更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.构造函数</span></span><br><span class="line"><span class="built_in">multimap</span>();                             <span class="comment">///&lt; 创建一个空的multimap。</span></span><br><span class="line"><span class="built_in">multimap</span>(InputIt first, InputIt last);  <span class="comment">///&lt; 创建一个包含[first, last)区间内所有元素的新multimap，要求这些元素必须支持拷贝构造函数。</span></span><br><span class="line"><span class="built_in">multimap</span>(<span class="type">const</span> multimap&amp; other);        <span class="comment">///&lt; 拷贝构造函数，创建一个新的multimap，它与另一个multimap中的元素相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.迭代器</span></span><br><span class="line"><span class="built_in">begin</span>();   <span class="comment">///&lt; 返回指向multimap第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>();     <span class="comment">///&lt; 返回指向multimap最后一个元素之后位置的迭代器。</span></span><br><span class="line"><span class="built_in">rbegin</span>();  <span class="comment">///&lt; 返回指向multimap最后一个元素的反向迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>();    <span class="comment">///&lt; 返回指向multimap第一个元素之前位置的反向迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.容量</span></span><br><span class="line"><span class="built_in">empty</span>();     <span class="comment">///&lt; 如果multimap为空，则返回true，否则返回false。</span></span><br><span class="line"><span class="built_in">size</span>();      <span class="comment">///&lt; 返回multimap中元素的数量。</span></span><br><span class="line"><span class="built_in">max_size</span>();  <span class="comment">///&lt; 返回multimap可以包含的最大元素数量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.插入与删除</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; val);                     <span class="comment">///&lt; 将val插入到multimap中。如果multimap中已经存在一个键值与val相等的元素，</span></span><br><span class="line">                                                   <span class="comment">///&lt; 则新的val将会被插入到该键值所对应的元素序列的尾部。</span></span><br><span class="line"><span class="built_in">insert</span>(InputIt first, InputIt last);               <span class="comment">///&lt; 将[first, last)区间内的所有元素插入到multimap中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* m.emplace(key, value) */</span></span><br><span class="line"><span class="built_in">emplace</span>(key, value);                               <span class="comment">///&lt; 在当前multimap容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key);                        <span class="comment">///&lt; 删除multimap中所有键值为key的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator position);                    <span class="comment">///&lt; 删除迭代器position所指向的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator first, const_iterator last);  <span class="comment">///&lt; 删除[first, last)区间内的所有元素。</span></span><br><span class="line"><span class="built_in">clear</span>();                                           <span class="comment">///&lt; 清空multimap中的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.查找</span></span><br><span class="line"><span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key);        <span class="comment">///&lt; 返回multimap中键值为key的元素数量。</span></span><br><span class="line"><span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key);         <span class="comment">///&lt; 查找并返回multimap中第一个键值为key的元素的迭代器。如果找不到，则返回end()。</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; key);  <span class="comment">///&lt; 返回一个pair，包含两个迭代器，第一个迭代器指向multimap中第一个键值为key的元素，</span></span><br><span class="line">                                   <span class="comment">///&lt; 第二个迭代器指向multimap中第一个键值大于key的元素。如果找不到任何元素，则两个迭代器都等于end()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 除了以上方法，multimap还继承了map类的其他方法，如key_comp()、value_comp()等。 **********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义排序 demo */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，对键进行降序排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string, Compare&gt; myMultimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 insert() 函数插入键值对</span></span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">3</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : myMultimap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key = &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, Value = &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-模板全特化和偏特化"><a href="#C-模板全特化和偏特化" class="headerlink" title="C++模板全特化和偏特化 "></a><a href="#context.12">C++模板全特化和偏特化</a><a name="section.12"> </a></h2><p><strong>模板分为：</strong>1. 类模板  2. 函数模板</p>
<p><strong>特化分为：</strong>1. 特例化（全特化）  2. 部分特例化（偏特化）</p>
<p>对模板特例化是因为对特定类型，可以利⽤某些特定知识来提⾼效率，⽽不是使⽤通⽤模板</p>
<p><strong>对函数模板：</strong></p>
<ol>
<li>模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本</li>
<li>⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化</li>
</ol>
<p><strong>模板函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;模板函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span> , <span class="type">char</span> &gt;(<span class="type">int</span> a, <span class="type">char</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///&lt; 函数模板，只有全特化，偏特化的功能可以通过函数的重载完成</span></span><br></pre></td></tr></table></figure>



<p><strong>对类模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span> , <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i, <span class="type">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">char</span>, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">char</span> i, T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类&gt;偏特化类&gt;主版本模板类</span></span><br></pre></td></tr></table></figure>





<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式 "></a><a href="#context.13">lambda表达式</a><a name="section.13"> </a></h2><p>lambda表达式<strong>表示⼀个可调⽤的代码单元</strong>，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤它，不需要其他地⽅调⽤它</p>
<p>表达式语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; [捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span></span><br><span class="line"><span class="comment">///&lt; 只有 [capture list] 捕获列表和 &#123; function body &#125; 函数体是必选的</span></span><br><span class="line"><span class="comment">///&lt; 其中 -&gt; return type 可省略，单行函数自动判断返回类型</span></span><br><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;function body &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 例：</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [&amp;count](<span class="type">int</span> x) &#123;</span><br><span class="line">    count += x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; count == 0;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">///&lt; count == 1;</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>不捕获任何变量，这种情况下 <code>lambda</code> 表达式内部不能访问外部的变量</td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>以引用方式捕获所有变量（保证 <code>lambda</code> 执行时变量存在）</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>用值的方式捕获所有变量（创建时拷贝，修改对 <code>lambda</code> 内对象无影响）</td>
</tr>
<tr>
<td><code>[=, &amp;foo]</code></td>
<td>以引用捕获变量 <code>foo</code>，但其余变量都靠值捕获</td>
</tr>
<tr>
<td><code>[&amp;, foo]</code></td>
<td>以值捕获 <code>foo</code> ，但其余变量都靠引用捕获</td>
</tr>
<tr>
<td><code>[bar]</code></td>
<td>以值方式捕获 <code>bar</code>，不捕获其他变量</td>
</tr>
<tr>
<td><code>[this]</code></td>
<td>捕获所在类的 <code>this</code> 指针</td>
</tr>
</tbody></table>
<p><strong>lambda最大的⼀个优势是在使⽤STL中的算法(algorithms)库</strong></p>
<p>如数组排序：</p>
<p><img src="/C++.assets/image-20230616102708669.png" alt="image-20230616102708669"></p>
<p>set&lt;&gt;</p>
<p>deque</p>
<p>vector&lt;&gt;</p>
<p>map&lt;&gt;</p>
<p>list&lt;&gt;</p>
<p>stack&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 小端模式，高位存内存高地址，地位存低</span><br><span class="line">浮点数最好用double类型(默认)而不是float</span><br><span class="line"></span><br><span class="line">const int c = 12;			# 同c的 #define，声明常量，c++中应使用const</span><br><span class="line"></span><br><span class="line">int xxx[3] = &#123; 20, 1, 16 &#125;		# 花括号直接给数组赋值</span><br><span class="line"></span><br><span class="line">sizeof xx				# 显示xx变量长度字节，（int）加括号为类型</span><br><span class="line"># char为1bytes</span><br><span class="line"># 整形: char (1), short (2), int (4), long (4), long long (8)</span><br><span class="line"># 浮点型: float (4), double (8), long double (80,96,128位&lt;16字节&gt;  /8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示个数则  xx/xx[0]</span><br><span class="line"># 数组默认表示地址，不能像python一样直接打印数组</span><br><span class="line"></span><br><span class="line">strlen()		# 显示字符串长度，需要include cstring</span><br><span class="line">		# 同python的len()，只针对字符串</span><br><span class="line">.size()		# 同上，需要include string</span><br><span class="line"></span><br><span class="line">--&gt; 字符串以空字符结尾 &#x27;\0&#x27;</span><br><span class="line">--&gt; 字符数组相反</span><br><span class="line">char fish[] = &quot;Bubbles&quot;;		</span><br><span class="line"># 字符串常量直接用双引号，末尾会自动加\0，且表地址</span><br><span class="line"># 字符常量用单引号，如：&#x27;s&#x27; , 且与字符串常量不能互换</span><br><span class="line"></span><br><span class="line">面向行的输入：getline(1, 2)</span><br><span class="line"># 不保存换行符！</span><br><span class="line"># 1.用来存储的数组名称 2.读取的字符数(需要-1)</span><br><span class="line"># 例：getline(name, 20)  读19个存到name</span><br><span class="line"></span><br><span class="line">面向行的输入：get(1, 2)		# 保留回车</span><br><span class="line"># 可用get()来读取一个字符（包括回车）</span><br><span class="line"># 可用 cin.get(name, 10).get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string类</span><br><span class="line"># 可以赋值给变量</span><br><span class="line"></span><br><span class="line">struct	结构体 --&gt; c需要关键字struct xx  ， c++ 不需要struct</span><br><span class="line"># 注意结构体赋值是加花括号 &#123; &#125;</span><br><span class="line"></span><br><span class="line">union	共用体 --&gt; 只能存int,lomg,double</span><br><span class="line"></span><br><span class="line">enum xxx &#123;a, b, c&#125;		# 此时xxx为枚举</span><br><span class="line"># xxx ban			# 定义ban为枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针 "></a><a href="#context.14">智能指针</a><a name="section.14"> </a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.15">定义</a><a name="section.15"> </a></h3><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<h3 id="shared-ptr（常用）"><a href="#shared-ptr（常用）" class="headerlink" title="shared_ptr（常用） "></a><a href="#context.16">shared_ptr（常用）</a><a name="section.16"> </a></h3><p>采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p>
<p><strong>注：</strong></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr "></a><a href="#context.17">weak_ptr</a><a name="section.17"> </a></h3><p>弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr "></a><a href="#context.18">unique_ptr</a><a name="section.18"> </a></h3><p>unique_ptr采用的是独享资源所有权，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr "></a><a href="#context.19">auto_ptr</a><a name="section.19"> </a></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。</p>
<p><code>auto_ptr</code> 是一个失败设计，很多公司明确要求不能使用 <code>auto_ptr</code></p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>算法(c++)</title>
    <url>/2023/07/26/algorithm/</url>
    <content><![CDATA[<h1 id="算法（c-）"><a href="#算法（c-）" class="headerlink" title="算法（c++）"></a>算法（c++）</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">字符串</a><a name="context.1"> </a><ul>
<li><a href="#section.2">KMP算法</a><a name="context.2"> </a></li>
<li><a href="#section.3">Manacher算法（马拉车）</a><a name="context.3"> </a></li>
<li><a href="#section.4">不重复最长子串</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">快排</a><a name="context.5"> </a></li>
<li><a href="#section.6">回溯</a><a name="context.6"> </a></li>
<li><a href="#section.7">递归法</a><a name="context.7"> </a></li>
<li><a href="#section.8">贪心</a><a name="context.8"> </a></li>
</ul>
<hr>
<span id="more"></span>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串 "></a><a href="#context.1">字符串</a><a name="section.1"> </a></h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法 "></a><a href="#context.2">KMP算法</a><a name="section.2"> </a></h3><p>用于字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。</p>
<p><strong>求前缀表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 求前缀表（最长公共子串） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>相关例题：</p>
<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">KMP 459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 */</span></span><br><span class="line"><span class="comment">/** 字符串 459 重复的子字符串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string &amp;s, <span class="type">int</span> *next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">///&lt; j 为前缀末尾, i 为后缀末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="built_in">GetNext</span>(s, next);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">            ret = next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; (len % (len - (next[len - <span class="number">1</span>]))) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: arr)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!haystack.<span class="built_in">empty</span>() &amp;&amp; !needle.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; needle.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needle[i] == needle[j])</span><br><span class="line">                    ++j;</span><br><span class="line"></span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (haystack[i] == needle[j] &amp;&amp; ++j == needle.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i - j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manacher算法（马拉车）"><a href="#Manacher算法（马拉车）" class="headerlink" title="Manacher算法（马拉车） "></a><a href="#context.3">Manacher算法（马拉车）</a><a name="section.3"> </a></h3><p>一个高效匹配回文子串长度的算法，他可以在o(n)的时间复杂度中计算出一个字符串的回文子串的长度</p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 5 最长回文子串 马拉车算法 Manacher */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;  <span class="comment">///&lt; p 用来记录各点的回文半径</span></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;           <span class="comment">///&lt; 某个回文串延伸到的最右边下标</span></span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;         <span class="comment">///&lt; r 所属回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_mid = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_rad = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文半径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, end = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 i 还在区间内, 则此处半径为 i 关于 mid 对称点 j 处的半径(不超过左边界)</span></span><br><span class="line">            p[i] = i &lt; r ? <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i) : <span class="number">1</span>;  <span class="comment">///&lt; 重要!!! 需理解!!!</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴力计算回文串长度</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]])</span><br><span class="line">                ++p[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 i 处的回文字符串长度超过右边界 r 时  更新 mid 和 r</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                r = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max_rad 记录最大的半径 max_mid 记录最大半径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; max_rad) &#123;</span><br><span class="line">                max_rad = p[i];</span><br><span class="line">                max_mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>((max_mid - max_rad) &gt;&gt; <span class="number">1</span>, max_rad - <span class="number">1</span>);  <span class="comment">///&lt; 注意起始点需 / 2, 长度需 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 647 回文子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">            &#123;</span><br><span class="line">                t += c;</span><br><span class="line">                t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size())</span></span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, e = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">                p[i] = i &lt; r ? <span class="built_in">min</span>(r - i, p[<span class="number">2</span> * mid - i]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i + p[i] &gt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = i + p[i];</span><br><span class="line">                    mid = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret += (p[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>总结马拉车</strong></p>
<p>步骤如下</p>
<ol>
<li><code>p[i] = i &lt; r ? min(p[2 * mid - i], r - i) : 1;</code></li>
<li>暴力外扩</li>
<li>外扩后判断<strong>半径</strong>是否超右边界，如果是，则更新右边界和中心点</li>
<li>更新最大半径和最大半径的中心点</li>
</ol>
<h3 id="不重复最长子串"><a href="#不重复最长子串" class="headerlink" title="不重复最长子串 "></a><a href="#context.4">不重复最长子串</a><a name="section.4"> </a></h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 */</span></span><br><span class="line"><span class="comment">/** 字符串 3 无重复字符的最长子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="快排"><a href="#快排" class="headerlink" title="快排 "></a><a href="#context.5">快排</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecurQS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, temp;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            left = start;</span><br><span class="line">            right = end;</span><br><span class="line"></span><br><span class="line">            mid = nums[<span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start];  <span class="comment">// 随机效率比中位数高将近10倍</span></span><br><span class="line"><span class="comment">//            mid = nums[start + ((end - start) &gt;&gt; 1)];</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(nums[left], mid))</span><br><span class="line">                    ++left;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(mid, nums[right]))</span><br><span class="line">                    --right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = nums[left];</span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    nums[right] = temp;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; right)</span><br><span class="line">                <span class="built_in">RecurQS</span>(nums, start, right);</span><br><span class="line"></span><br><span class="line">            start = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RecurQS</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯 "></a><a href="#context.6">回溯</a><a name="section.6"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码模板 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法 "></a><a href="#context.7">递归法</a><a name="section.7"> </a></h2><p>三部曲：</p>
<ol>
<li><p><strong>确定递归函数的参数和返回值</strong></p>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>确定终止条件</strong><br>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。<br>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
</li>
<li></li>
<li><p><strong>确定单层递归的逻辑</strong></p>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心 "></a><a href="#context.8">贪心</a><a name="section.8"> </a></h2><p>如果找到局部最优，然后推出整体最优，那么就是贪心</p>
<p>局部最优 → 总体最优</p>
<p><a href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 贪心 53 最大子数组和 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">///&lt; 1. 贪心</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = INT32_MIN;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 2. 优化空间后的动态规划</span></span><br><span class="line"><span class="comment">//            ret = nums[0];</span></span><br><span class="line"><span class="comment">//            int pre = 0;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                pre = max(pre + nums[i], nums[i]);</span></span><br><span class="line"><span class="comment">//                ret = max(ret, pre);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 3. 未优化空间的动态规划</span></span><br><span class="line"><span class="comment">//            vector&lt;int&gt; dp(nums.size(), 0);</span></span><br><span class="line"><span class="comment">//            dp[0] = nums[0];</span></span><br><span class="line"><span class="comment">//            ret = dp[0];</span></span><br><span class="line"><span class="comment">//            for (int i = 1; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                if (dp[i - 1] &gt; 0)</span></span><br><span class="line"><span class="comment">//                    dp[i] = dp[i - 1] + nums[i];</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    dp[i] = nums[i];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                ret = max(ret, dp[i]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/26/hello-world/</url>
    <content><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>hhh</p>
<p>t1  555</p>
<p>？？</p>
]]></content>
  </entry>
</search>
