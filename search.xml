<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++</title>
    <url>/2023/07/26/C++/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">输入输出</a><a name="context.1"> </a><ul>
<li><a href="#section.2">getline</a><a name="context.2"> </a></li>
<li><a href="#section.3">cin</a><a name="context.3"> </a></li>
</ul>
</li>
<li><a href="#section.4">nullptr</a><a name="context.4"> </a></li>
<li><a href="#section.5">左值右值</a><a name="context.5"> </a></li>
<li><a href="#section.6">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="context.6"> </a></li>
<li><a href="#section.7">类</a><a name="context.7"> </a></li>
<li><a href="#section.8">友元</a><a name="context.8"> </a><ul>
<li><a href="#section.9">友元函数</a><a name="context.9"> </a></li>
<li><a href="#section.10">友元类</a><a name="context.10"> </a></li>
</ul>
</li>
<li><a href="#section.11">重载</a><a name="context.11"> </a></li>
<li><a href="#section.12">bitset（位库）</a><a name="context.12"> </a></li>
<li><a href="#section.13">STL</a><a name="context.13"> </a></li>
<li><a href="#section.14">unordered_set方法</a><a name="context.14"> </a></li>
<li><a href="#section.15">pair容器</a><a name="context.15"> </a></li>
<li><a href="#section.16">vector 容器</a><a name="context.16"> </a></li>
<li><a href="#section.17">list（链表）</a><a name="context.17"> </a></li>
<li><a href="#section.18">vector和list的区别</a><a name="context.18"> </a></li>
<li><a href="#section.19">deque（双端数组）</a><a name="context.19"> </a></li>
<li><a href="#section.20">stack &#x2F; queue</a><a name="context.20"> </a></li>
<li><a href="#section.21">priority_queue</a><a name="context.21"> </a></li>
<li><a href="#section.22">map &#x2F; set</a><a name="context.22"> </a></li>
<li><a href="#section.23">map &#x2F; unordered_map</a><a name="context.23"> </a></li>
<li><a href="#section.24">multimap</a><a name="context.24"> </a></li>
<li><a href="#section.25">C++模板全特化和偏特化</a><a name="context.25"> </a></li>
<li><a href="#section.26">lambda表达式</a><a name="context.26"> </a></li>
<li><a href="#section.27">智能指针</a><a name="context.27"> </a><ul>
<li><a href="#section.28">定义</a><a name="context.28"> </a></li>
<li><a href="#section.29">shared_ptr（常用）</a><a name="context.29"> </a></li>
<li><a href="#section.30">unique_ptr</a><a name="context.30"> </a></li>
<li><a href="#section.31">weak_ptr</a><a name="context.31"> </a></li>
<li><a href="#section.32">auto_ptr</a><a name="context.32"> </a></li>
</ul>
</li>
<li><a href="#section.33">function</a><a name="context.33"> </a></li>
<li><a href="#section.34">decltype &#x2F; auto</a><a name="context.34"> </a></li>
</ul>
<hr>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出 "></a><a href="#context.1">输入输出</a><a name="section.1"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; ++i &lt;&lt; i++ &lt;&lt; i &lt;&lt; i++ &lt;&lt; ++i &lt;&lt; endl;</span><br><span class="line"><span class="comment">///&lt; 输出为 &amp;5 3 &amp;5 2 &amp;5</span></span><br></pre></td></tr></table></figure>

<p>cout输出控制台过程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161641648.png" alt="img"></p>
<p>从 <code>endl</code> 开始，从右向左依次入栈，最后依次弹出</p>
<h3 id="getline"><a href="#getline" class="headerlink" title="getline "></a><a href="#context.2">getline</a><a name="section.2"> </a></h3><p>默认遇换行符或 <code>EOF</code> 结束，也可自定义结束符</p>
<p>上限字符数为 <code>1024</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare s: 字符串变量</span></span><br><span class="line"><span class="comment"> * @pare n: 字符个数 (第n个补&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;iostream&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">std::cin.<span class="built_in">getline</span>(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @pare is: 标准输入流函数 (常用 std::cin)</span></span><br><span class="line"><span class="comment"> * @pare str: 存字符的变量名</span></span><br><span class="line"><span class="comment"> * @pare delim: 输入终止条件 (可省略, 默认换行符 &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment"> * @note: #include &lt;string&gt;    ///&lt; 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">string::<span class="built_in">getline</span>(istream&amp; is, string&amp; str, <span class="type">char</span> delim);</span><br></pre></td></tr></table></figure>



<h3 id="cin"><a href="#cin" class="headerlink" title="cin "></a><a href="#context.3">cin</a><a name="section.3"> </a></h3><p>在上述的停止条件上，遇空格也会停止</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr "></a><a href="#context.4">nullptr</a><a name="section.4"> </a></h2><p>c++11引入 <code>nullptr</code> ，为 <strong>右值常量</strong></p>
<p>原因：</p>
<p>在函数重载的时候，如果还是用C语言的 <code>NULL</code> 则会出错，并且 <code>NULL</code> 只是单纯的宏定义替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;int\n&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;ptr\n&quot;</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">NULL</span>);  <span class="comment">///&lt; 不注释掉的话会报错</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 输出 &quot;ptr&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值 "></a><a href="#context.5">左值右值</a><a name="section.5"> </a></h2><p>首先区分一下什么是左值，什么是右值。<br>左值就是可以写在赋值号左边的，右值是写在赋值号右边的。<br>比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Stu <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Stu</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是左值</span></span><br><span class="line">Stu s = <span class="built_in">foo</span>(); <span class="comment">// s是左值，foo()的返回值是右值</span></span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// a + b 的结果是右值，c是左值</span></span><br></pre></td></tr></table></figure>

<p><code>foo()</code> 返回了一个没有名字的<code>Stu</code>对象，你不能写<code>foo() = s</code>，所以<code>foo()</code>就是个右值。<br>还有一种定义说是，无法取地址的就是右值，可以取地址的是左值。</p>
<h2 id="左值引用-和右值引用"><a href="#左值引用-和右值引用" class="headerlink" title="左值引用(&amp;)和右值引用(&amp;&amp;) "></a><a href="#context.6">左值引用(&amp;)和右值引用(&amp;&amp;)</a><a name="section.6"> </a></h2><p>首先要注意一点：<code>&amp;&amp;</code>不是“引用的引用”，这仅仅是一个记号，这个记号我改成<code>$</code>也没什么问题。不能像理解指针<code>**</code>是指针的指针这样去类比。<br>左值引用就是给左值变量起别名，右值引用就是给右值变量起别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;aa = a; <span class="comment">//左值引用</span></span><br><span class="line">Stu &amp;&amp;s = <span class="built_in">foo</span>(); <span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>Stu &amp;&amp;s &#x3D; foo()，就是给foo()返回的临时对象起了个别名，本来它在foo()返回后生存期就到了，就该析构了，但是由于s对她进行了引用，他的生存期被延长至和s相同。如果是Stu s &#x3D; foo()则会在赋值时发生一次拷贝构造。</p>
<p>附两篇写的很好的文章<br><a href="https://www.cnblogs.com/sunchaothu/p/11392116.html">C++ 11的移动语义 - 行者孙 - 博客园</a><br><a href="https://www.cnblogs.com/lidabo/p/3908681.html">C++11新特性：右值引用和转移构造函数 - DoubleLi - 博客园</a></p>
<p>作者：wangbingbing</p>
<p>出处：<a href="https://www.cnblogs.com/wangbingbing/p/15179675.html">https://www.cnblogs.com/wangbingbing/p/15179675.html</a></p>
<h2 id="类"><a href="#类" class="headerlink" title="类 "></a><a href="#context.7">类</a><a name="section.7"> </a></h2><p><strong>注意：</strong></p>
<ol>
<li>成员变量和成员函数分开存储</li>
<li>静态成员只能在类外初始化，<code>cosnt</code> 常量静态成员在类内初始化<br>静态成员变量，属于某个类，所有对象共享，无论建立了多少个对象，都只有一个静态数据的拷贝。是在编译阶段就分配好了空间，对象还没有创建时，就已经分配空间。</li>
<li>类的静态成员访问<br>用 <code>::</code> 或者 <code>.</code></li>
<li>类的静态函数只能访问类中的静态变量，其他函数则都可访问</li>
<li>静态函数没有 <code>this</code> 指针，同时静态变量也有访问级别限制（公有，私有，保护）</li>
</ol>
<p><strong>类中的虚函数占用为一个指针的大小</strong></p>
<p><strong>类的成员函数，实际上相当于普通函数，只不过把类对象隐式的传递进去罢了</strong></p>
<p><strong>空类的大小为？</strong></p>
<p>c++要求每个实例在内存中都有独一无二的地址。空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元 "></a><a href="#context.8">友元</a><a name="section.8"> </a></h2><p><strong>友元提供了一种突破封装的方式。</strong>友元函数提供了一种在需要时访问类的私有成员的机制，但应该慎重使用，因为过多的友元函数可能破坏类的封装性。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数 "></a><a href="#context.9">友元函数</a><a name="section.9"> </a></h3><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但是需要在类的内部声明，声明时需要加friend关键字。</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元函数可以访问类的所有成员，但此函数不是类的成员函数</li>
<li>友元函数不能用 <code>const</code> 修饰</li>
<li>友元函数可以在类定义的任何地方申明，不受类访问限定符限制</li>
<li>一个函数可以是多个类的友元函数</li>
<li>友元函数调用和普通函数的调用原理相同</li>
</ol>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类 "></a><a href="#context.10">友元类</a><a name="section.10"> </a></h3><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员</p>
<p><strong>注意：</strong></p>
<ol>
<li>友元关系是单向的，不具有交换性<br>比如Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行</li>
<li>友元关系不能传递<br>如果B是A的友元，C是A的友元，则不能说明C是A的友元</li>
</ol>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载 "></a><a href="#context.11">重载</a><a name="section.11"> </a></h2><p>形式：</p>
<p><strong>[返回值] operator[运算符] (参数…) { … }；</strong></p>
<p><strong>不能重载的5种运算符：</strong></p>
<ol>
<li><code>.*</code><br>任意字符出现零次或多次</li>
<li><code>::</code><br>域作用符  </li>
<li><code>sizeof</code><br>关键字 - 大小</li>
<li><code>?:</code><br>三目运算符</li>
<li><code>.</code><br>点运算符</li>
</ol>
<p>例：重载类运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> _hour;</span><br><span class="line">	<span class="type">int</span> _min;</span><br><span class="line">	<span class="type">int</span> _sec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span> hour = <span class="number">0</span>, <span class="type">int</span> min = <span class="number">0</span>, <span class="type">int</span> sec = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_hour = hour;</span><br><span class="line">		_min = min;</span><br><span class="line">		_sec = sec;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _sec &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为方便演示，让小时+1，但不再判断时间正确性</span></span><br><span class="line">	Time&amp; <span class="keyword">operator</span>++()<span class="comment">// ++A  不带参数为前置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">this</span>);<span class="comment">//因为自增直接返回this用引用接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	Time <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//A++，参数写int或int i都可以   带参数为后置++</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Time <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		_hour += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;<span class="comment">//需要返回this自增之前的结果，所以用临时变量返回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「就要 宅在家」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/weixin_61857742/article/details/126010673</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 友元函数重载流提取 &lt;&lt; / &gt;&gt;</span></span><br><span class="line"><span class="comment">// 对于流而言，因为是双目运算符，this指针本应该指向左边的类，但左操作数是一个流，又与this的类型冲突。</span></span><br><span class="line"><span class="comment">// 这时，就需要用到友元函数friend。友元函数本身是一个普通函数，但是作为类的友元，能够调用类内的成员，包括private。而且参数不用被类限制为第一个必须是this所指的对象本身。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class &#123;</span></span><br><span class="line"><span class="comment">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Time&amp; t);//友元函数，声明</span></span><br><span class="line"><span class="comment">	friend istream&amp; operator&gt;&gt;(istream&amp; in, Time&amp; t);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="bitset（位库）"><a href="#bitset（位库）" class="headerlink" title="bitset（位库） "></a><a href="#context.12">bitset（位库）</a><a name="section.12"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span>  <span class="comment">///&lt; 所在头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">///&lt; 命名空间std</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 默认无参构造</span></span><br><span class="line">    <span class="comment">// 初始化全部位为0</span></span><br><span class="line">    std::bitset&lt;8&gt; bs;</span><br><span class="line">    <span class="comment">//bs[0] = 1;            // 0000 0001</span></span><br><span class="line">    <span class="comment">//bs[7] = 1;            // 1000 0000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传值构造方式</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">0x07</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_string</span>()  <span class="comment">// 0000 0111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string 构造</span></span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;00000111&quot;</span>)</span></span>;</span><br><span class="line">    bs.<span class="built_in">to_ulong</span>();      <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.any()</td>
<td>是否存在值为1的二进制位</td>
</tr>
<tr>
<td>.none()</td>
<td>是否不存在值为1的二进制位<br/>或者说是否全部位为0</td>
</tr>
<tr>
<td>.size()</td>
<td>位长，也即是非模板参数值</td>
</tr>
<tr>
<td>.count()</td>
<td>值为1的个数</td>
</tr>
<tr>
<td>.test(pos)</td>
<td>测试pos处的二进制位是否为1<br/>与0做或运算</td>
</tr>
<tr>
<td>.set()</td>
<td>全部位置1</td>
</tr>
<tr>
<td>.set(pos)</td>
<td>pos位处的二进制位置1<br/>与1做或运算</td>
</tr>
<tr>
<td>.reset()</td>
<td>全部位置0</td>
</tr>
<tr>
<td>.reset(pos)</td>
<td>pos位处的二进制位置0<br/>与0做或运算</td>
</tr>
<tr>
<td>.flip()</td>
<td>全部位逐位取反</td>
</tr>
<tr>
<td>.flip(pos)</td>
<td>pos处的二进制位取反</td>
</tr>
<tr>
<td>.to_ulong()</td>
<td>将二进制转换为unsigned long输出</td>
</tr>
<tr>
<td>.to_string()</td>
<td>将二进制转换为字符串输出</td>
</tr>
<tr>
<td>~bs</td>
<td>按位取反<br/>效果等效为bs.flip()</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>将二进制位输出到os流<br/>小值在右，大值在左</td>
</tr>
</tbody></table>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL "></a><a href="#context.13">STL</a><a name="section.13"> </a></h2><p>STL提供了六⼤组件，彼此之间可以组合套⽤，这六⼤组件分别是：</p>
<ol>
<li><p><strong>容器</strong></p>
<p>各种数据结构，如vector、list、deque、set、map等，⽤来存放数据，从实现角度来看，STL 容器是⼀种 <code>class template</code></p>
</li>
<li><p><strong>算法</strong></p>
<p>各种常⽤的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是⼀种 <code>function template</code></p>
</li>
<li><p><strong>迭代器</strong></p>
<p>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是⼀种将 operator* , operator-&gt; , operator++, operator– 等指针相关操作予以重载的 <code>class template</code>。  </p>
<p>所有STL容器都附带有⾃⼰专属的迭代器，只有容器的设计者才知道如何遍历⾃⼰的元素。  </p>
<p>原⽣指针(native pointer)也是⼀种迭代器。</p>
</li>
<li><p><strong>仿函数</strong></p>
<p>⾏为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是⼀种重载了operator() 的 class 或者 class template</p>
</li>
<li><p><strong>适配器（配接器）</strong></p>
<p>⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东西。  </p>
<p>STL提供的queue 和 stack，虽然看似容器，但其实只能算是⼀种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应</p>
</li>
<li><p><strong>空间配置器</strong></p>
<p>负责空间的配置与管理。从实现角度看，配置器是⼀个实现了动态空间配置、空间管理、空间释放的 class template</p>
<p>⼀般的分配器的 std:alloctor 都含有两个函数 allocate 与 deallocte，这两个函数分别调⽤ operator new() 与 delete()，这两个函数的底层⼜分别是malloc() and free(); 但是每次malloc会带来格外开销（因为每次malloc⼀个元素都要带有附加信息）</p>
</li>
</ol>
<p><strong>容器之间的实现关系以及分类：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161642801.png" alt="image-20230615150413812-1692155829457"></p>
<p><strong>STL六⼤组件的交互关系：</strong></p>
<ol>
<li>容器通过空间配置器取得数据存储空间  </li>
<li>算法通过迭代器存储容器中的内容  </li>
<li>仿函数可以协助算法完成不同的策略的变化 </li>
<li>适配器可以修饰仿函数</li>
</ol>
<p><strong>STL的优点</strong></p>
<p>STL 具有⾼可重⽤性，⾼性能，⾼移植性，跨平台的优点</p>
<ol>
<li>⾼可重⽤性<br>STL 中几乎所有的代码都采⽤了模板类和模版函数的⽅式实现，这相⽐于传统的由函数和类组成的库来说提供了更好的代码重⽤机会</li>
<li>⾼性能<br>如 map 可以⾼效地从⼗万条记录⾥⾯查找出指定的记录，因为 map 是采⽤红黑树的变体实现的</li>
<li>⾼移植性<br>如在项⽬ A 上⽤ STL 编写的模块，可以直接移植到项⽬ B 上</li>
</ol>
<p><strong>STL 的⼀个重要特性是将数据和操作分离</strong></p>
<p>数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当 “粘合剂” 以使算法可以和容器交互运作</p>
<h2 id="unordered-set方法"><a href="#unordered-set方法" class="headerlink" title="unordered_set方法 "></a><a href="#context.14">unordered_set方法</a><a name="section.14"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 x 在 us 中， 返回1 否则0 </span></span><br><span class="line">us.<span class="built_in">count</span>(x);</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="pair容器"><a href="#pair容器" class="headerlink" title="pair容器 "></a><a href="#context.15">pair容器</a><a name="section.15"> </a></h2><p>保存两个数据成员，⽤来⽣成特定类型的模板</p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line"><span class="comment">///&lt; 数据成员是public，两个成员分别是first和second</span></span><br></pre></td></tr></table></figure>



<h2 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器 "></a><a href="#context.16">vector 容器</a><a name="section.16"> </a></h2><p><strong>底层：</strong></p>
<p>Vector在堆中分配了⼀段连续的内存空间来存放元素</p>
<p>底层为动态数组</p>
<p>扩容：</p>
<ol>
<li>固定扩容</li>
<li>加倍扩容</li>
</ol>
<h2 id="list（链表）"><a href="#list（链表）" class="headerlink" title="list（链表） "></a><a href="#context.17">list（链表）</a><a name="section.17"> </a></h2><p><strong>中间位置的插入与删除是 O(1)</strong></p>
<p><strong>实现方式：</strong>双向链表</p>
<h2 id="vector和list的区别"><a href="#vector和list的区别" class="headerlink" title="vector和list的区别 "></a><a href="#context.18">vector和list的区别</a><a name="section.18"> </a></h2><ol>
<li>vector 底层实现是数组；list 是双向链表 </li>
<li>vector 是顺序内存，⽀持随机访问，list 不⾏ </li>
<li>vector 在中间节点进⾏插⼊删除会导致内存拷⻉，list不会 </li>
<li>vector ⼀次性分配好内存，不够时才进⾏翻倍扩容；list 每次插⼊新节点都会进⾏内存申请 </li>
<li>vector 随机访问性能好，插⼊删除性能差；list 随机访问性能差，插⼊删除性能好</li>
</ol>
<h2 id="deque（双端数组）"><a href="#deque（双端数组）" class="headerlink" title="deque（双端数组） "></a><a href="#context.19">deque（双端数组）</a><a name="section.19"> </a></h2><ol>
<li>O(1)<br>首尾插入，删除，访问</li>
<li>O(n)<br>中间插入 insert()，erase()</li>
</ol>
<p><strong>在头&#x2F;尾部插入&#x2F;删除时间复杂度为 O(1)</strong></p>
<p><strong>致命缺陷：</strong>不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下</p>
<p>因此，需要线性结构时，大多数情况下优先考虑<code>vector</code>和<code>list</code>，<code>deque</code>的应用并不多，而目前能看到的一个应用就是，STL用其作为<code>stack</code>和<code>queue</code>的底层数据结构。</p>
<p>⽀持快速随机访问，由于 deque 需要处理内部跳转，因此速度上没有 vector 快</p>
<p>deque 是⼀个<strong>双端开口</strong>的连续线性空间，其内部为分段连续的空间组成，随时可以增加⼀段新的空间并链接</p>
<p><strong>注意：</strong></p>
<p>由于deque的迭代器⽐vector要复杂，这影响了各个运算层面，所以除⾮必要尽量使⽤ vector；<br>为了提⾼效率，在对deque进⾏排序操作的时候，我们可以先把 deque 复制到 vector 中再进⾏排序最后在复制回 deque</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161643278.png" alt="image-20230615153051799-1692155829457"></p>
<p>deque采⽤⼀块map作为主控，其中的每个元素都是指针，指向另⼀⽚连续线性空间，称之为 缓存区，这个区才是⽤来储存数据的</p>
<h2 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack &#x2F; queue "></a><a href="#context.20">stack &#x2F; queue</a><a name="section.20"> </a></h2><p>概述：栈与队列被称之为 deque 的配接器，其底层是以 deque 为底部架构。通过 deque 执⾏具体操作</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue "></a><a href="#context.21">priority_queue</a><a name="section.21"> </a></h2><pre><code>     优先队列是一种容器适配器，采用了堆这样的数据结构，保证了第一个元素总是整个优先队列中最大的(或最小的)元素。  优先队列默认使用vector作为底层存储数据的容器，在vector上使用了堆算法将vector中的元素构造成堆的结构，所以其实我们就可以把它当作堆，凡是需要用堆的位置，都可以考虑优先队列。
</code></pre>
<p>​		 默认情况下 <code>priority_queue</code> 是大堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="comment">///&lt; 优先队列底层使用的存储结构，可以看出来，默认采用vector</span></span><br><span class="line">          <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt;  <span class="comment">///&lt; 定义优先队列中元素的比较方式的类，默认是按小于(less)的方式比较，</span></span><br><span class="line">                                                                <span class="comment">///&lt; 这种比较方式创建出来的就是大堆。所以优先队列默认就是大堆</span></span><br><span class="line">                                                                <span class="comment">///&lt; 如果需要创建小堆，就需要将less改为greater</span></span><br><span class="line">          &gt; <span class="keyword">class</span> priority_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重载比较函数 Compare */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 重载 ()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;  <span class="comment">///&lt; 此处与快排的排序相反， &gt; 表从小到大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(&amp;Cmp)&gt; <span class="built_in">pq</span>(Cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 3: class / struct</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：priority_queue 无迭代器！！</strong></p>
<ol>
<li>push() &#x2F; emplace()<br>O(log N)，push(x) 令x入队，其中 N 为当前优先队列中元素的个数</li>
<li>top()<br>O(1)，获得队首元素(即堆顶元素)</li>
<li>pop()<br>O(log N)，令队首元素(即堆顶元素)出队</li>
<li>empty()<br>O(1)，检测优先队列是否为空，返回 true则空，返回false 则非空</li>
<li>size()<br>O(1)，返回优先队列内元素的个数</li>
</ol>
<p><strong>emplace()与push()的区别</strong></p>
<p>当我们使用push()时，会创建一个对象，然后将其插入优先级队列。而使用emplace()，该对象将原地构造，节省了不必要的副本</p>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map &#x2F; set "></a><a href="#context.22">map &#x2F; set</a><a name="section.22"> </a></h2><p>有序（从小到大），底层为<strong>红黑树</strong></p>
<p><strong>共同点：</strong>都是C++的关联容器，只是通过它提供的接口对里面的元素进行访问，底层都是采⽤红黑树实现</p>
<p><strong>不同点：</strong></p>
<p>set：⽤来判断某⼀个元素是不是在⼀个组里面。<br>map：映射，相当于字典，把⼀个值映射成另⼀个值，可以创建字典</p>
<p><strong>优点：</strong></p>
<p>查找某⼀个数的时间为 <code>O(logn)</code>；遍历时采⽤ iterator，效果不错</p>
<p><strong>缺点：</strong></p>
<p>每次插⼊值的时候，都需要调整红黑树，效率有⼀定影响</p>
<p><strong>重载 &lt; 排序方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">    <span class="built_in">Student</span>(std::string name, <span class="type">int</span> age):<span class="built_in">name_</span>(name),<span class="built_in">age_</span>(age)&#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Student &amp;s) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(name_ != s.name_)&#123;</span><br><span class="line">            <span class="keyword">return</span> name_ &lt; s.name_;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age_ &lt; s.age_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::string <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name_ + <span class="string">&quot;, age:&quot;</span> + std::<span class="built_in">to_string</span>(age_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    set&lt;Student&gt; s;</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;Danney&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="built_in">Student</span>(<span class="string">&quot;LiMing&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        cout &lt;&lt; it.<span class="built_in">show</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小梦_人生如戏」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/yu532164710/article/details/105194036</span></span><br></pre></td></tr></table></figure>



<p><strong>细节：</strong></p>
<ol>
<li><strong>为什么要成倍的扩容而不是⼀次增加⼀个固定⼤⼩的容量呢？</strong><br>采⽤成倍⽅式扩容，可以保证常数的时间复杂度，⽽增加指定⼤⼩的容量只能达到O(n)的时间复杂度</li>
<li><strong>为什么是以两倍的⽅式扩容而不是三倍四倍，或者其他⽅式呢？</strong><br>考虑可能产⽣的堆空间浪费，所以增⻓倍数不能太⼤，⼀般是 1.5 或 2；GCC 是 2；VS 是 1.5，k &#x3D; 2 每次扩展的新尺寸必然刚好⼤于之前分配的总和，之前分配的内存空间不可能被使⽤，这样对于缓存并不友好，采⽤ 1.5 倍的增⻓⽅式可以更好的实现对内存的重复利用</li>
</ol>
<p><strong>注：C++并没有规定扩容因子K，这是由标准库的实现者决定的</strong></p>
<h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map &#x2F; unordered_map "></a><a href="#context.23">map &#x2F; unordered_map</a><a name="section.23"> </a></h2><p>map中元素是⼀些 <code>key-value</code> 对，关键字起索引作⽤，值表示和索引相关的数据</p>
<p><strong>底层实现：</strong></p>
<p><code>map</code> 底层是基于<strong>红黑树</strong>实现的，因此map内部元素排列是有序的<br><code>unordered_map</code> 底层则是基于<strong>哈希表</strong>实现的，因此其元素的排列顺序是杂乱⽆序的</p>
<table>
<thead>
<tr>
<th></th>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>有序性，这是map结构最⼤的优点，<br />其元素的有序性在很多应⽤中都会简化很多的操作<br />map的查找、删除、增加等⼀系列操作时间复杂度稳定，都为 O(logn)</td>
<td>查找、删除、添加的速度快，时间复杂度为常数级O(1）</td>
</tr>
<tr>
<td>缺点</td>
<td>查找、删除、增加等操作平均时间复杂度较慢，与 n 相关</td>
<td>因为unordered_map内部基于哈希表，<br />以（key,value）对的形式存储，因此空间占⽤率⾼<br />unordered_map的查找、删除、添加的时间复杂度不稳定<br />平均为O(1)，取决于哈希函数，极端情况下可能为O(n)</td>
</tr>
</tbody></table>
<p><strong>问题：</strong></p>
<ol>
<li><strong>为什么 <code>insert</code> 之后，以前保存的 <code>iterator</code> 不会失效？</strong><br><strong>答：</strong> 因为 map 和 set 存储的是结点，不需要内存拷⻉和内存移动。但是像 vector 在插入数据时如果内存不够会重新开辟一块内存。 map 和 set 的 iterator 指向的是节点的指针，vector 指向的是内存的某个位置</li>
<li><strong>为何 map 和 set 的插入删除效率比其他序列容器高？</strong><br><strong>答：</strong> 因为 map 和 set 底部使用红黑树实现，插入和删除的时间复杂度是 <code>O(logn)</code>，而像 vector 这样的序列容器插入和删除的时间复杂度是 <code>O(N)</code></li>
</ol>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap "></a><a href="#context.24">multimap</a><a name="section.24"> </a></h2><p>multimap是C++ STL中的一个关联容器，它与map类似，但可以存储多个具有相同键值的元素。</p>
<p>multimap使用红黑树实现，因此它的插入、查找、删除操作的时间复杂度为O(log n)，其中n为multimap中元素的数量。由于multimap允许重复的键值，因此对于某些操作，如查找、删除等，复杂度可能会更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.构造函数</span></span><br><span class="line"><span class="built_in">multimap</span>();                             <span class="comment">///&lt; 创建一个空的multimap。</span></span><br><span class="line"><span class="built_in">multimap</span>(InputIt first, InputIt last);  <span class="comment">///&lt; 创建一个包含[first, last)区间内所有元素的新multimap，要求这些元素必须支持拷贝构造函数。</span></span><br><span class="line"><span class="built_in">multimap</span>(<span class="type">const</span> multimap&amp; other);        <span class="comment">///&lt; 拷贝构造函数，创建一个新的multimap，它与另一个multimap中的元素相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.迭代器</span></span><br><span class="line"><span class="built_in">begin</span>();   <span class="comment">///&lt; 返回指向multimap第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>();     <span class="comment">///&lt; 返回指向multimap最后一个元素之后位置的迭代器。</span></span><br><span class="line"><span class="built_in">rbegin</span>();  <span class="comment">///&lt; 返回指向multimap最后一个元素的反向迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>();    <span class="comment">///&lt; 返回指向multimap第一个元素之前位置的反向迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.容量</span></span><br><span class="line"><span class="built_in">empty</span>();     <span class="comment">///&lt; 如果multimap为空，则返回true，否则返回false。</span></span><br><span class="line"><span class="built_in">size</span>();      <span class="comment">///&lt; 返回multimap中元素的数量。</span></span><br><span class="line"><span class="built_in">max_size</span>();  <span class="comment">///&lt; 返回multimap可以包含的最大元素数量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.插入与删除</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> value_type&amp; val);                     <span class="comment">///&lt; 将val插入到multimap中。如果multimap中已经存在一个键值与val相等的元素，</span></span><br><span class="line">                                                   <span class="comment">///&lt; 则新的val将会被插入到该键值所对应的元素序列的尾部。</span></span><br><span class="line"><span class="built_in">insert</span>(InputIt first, InputIt last);               <span class="comment">///&lt; 将[first, last)区间内的所有元素插入到multimap中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* m.emplace(key, value) */</span></span><br><span class="line"><span class="built_in">emplace</span>(key, value);                               <span class="comment">///&lt; 在当前multimap容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key);                        <span class="comment">///&lt; 删除multimap中所有键值为key的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator position);                    <span class="comment">///&lt; 删除迭代器position所指向的元素。</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator first, const_iterator last);  <span class="comment">///&lt; 删除[first, last)区间内的所有元素。</span></span><br><span class="line"><span class="built_in">clear</span>();                                           <span class="comment">///&lt; 清空multimap中的所有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.查找</span></span><br><span class="line"><span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key);        <span class="comment">///&lt; 返回multimap中键值为key的元素数量。</span></span><br><span class="line"><span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key);         <span class="comment">///&lt; 查找并返回multimap中第一个键值为key的元素的迭代器。如果找不到，则返回end()。</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="type">const</span> key_type&amp; key);  <span class="comment">///&lt; 返回一个pair，包含两个迭代器，第一个迭代器指向multimap中第一个键值为key的元素，</span></span><br><span class="line">                                   <span class="comment">///&lt; 第二个迭代器指向multimap中第一个键值大于key的元素。如果找不到任何元素，则两个迭代器都等于end()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 除了以上方法，multimap还继承了map类的其他方法，如key_comp()、value_comp()等。 **********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义排序 demo */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，对键进行降序排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, std::string, Compare&gt; myMultimap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 insert() 函数插入键值对</span></span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>));</span><br><span class="line">    myMultimap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">3</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : myMultimap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key = &quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;, Value = &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-模板全特化和偏特化"><a href="#C-模板全特化和偏特化" class="headerlink" title="C++模板全特化和偏特化 "></a><a href="#context.25">C++模板全特化和偏特化</a><a name="section.25"> </a></h2><p><strong>模板分为：</strong>1. 类模板  2. 函数模板</p>
<p><strong>特化分为：</strong>1. 特例化（全特化）  2. 部分特例化（偏特化）</p>
<p>对模板特例化是因为对特定类型，可以利⽤某些特定知识来提⾼效率，⽽不是使⽤通⽤模板</p>
<p><strong>对函数模板：</strong></p>
<ol>
<li>模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本</li>
<li>⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化</li>
</ol>
<p><strong>模板函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;模板函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span> , <span class="type">char</span> &gt;(<span class="type">int</span> a, <span class="type">char</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///&lt; 函数模板，只有全特化，偏特化的功能可以通过函数的重载完成</span></span><br></pre></td></tr></table></figure>



<p><strong>对类模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(T1 i,T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;模板类&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span> , <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i, <span class="type">char</span> j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;全特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">char</span>, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">char</span> i, T2 j):<span class="built_in">a</span>(i),<span class="built_in">b</span>(j)&#123;cout&lt;&lt;<span class="string">&quot;偏特化&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 对主版本模板类、全特化类、偏特化类的调⽤优先级从⾼到低进⾏排序是：全特化类&gt;偏特化类&gt;主版本模板类</span></span><br></pre></td></tr></table></figure>





<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式 "></a><a href="#context.26">lambda表达式</a><a name="section.26"> </a></h2><p>lambda表达式<strong>表示⼀个可调⽤的代码单元</strong>，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤它，不需要其他地⽅调⽤它</p>
<p>表达式语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; [捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span></span><br><span class="line"><span class="comment">///&lt; 只有 [capture list] 捕获列表和 &#123; function body &#125; 函数体是必选的</span></span><br><span class="line"><span class="comment">///&lt; 其中 -&gt; return type 可省略，单行函数自动判断返回类型</span></span><br><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;function body &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; 例：</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [&amp;count](<span class="type">int</span> x) &#123;</span><br><span class="line">    count += x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; count == 0;</span></span><br><span class="line"><span class="built_in">test</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">///&lt; count == 1;</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>不捕获任何变量，这种情况下 <code>lambda</code> 表达式内部不能访问外部的变量</td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>以引用方式捕获所有变量（保证 <code>lambda</code> 执行时变量存在）</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>用值的方式捕获所有变量（创建时拷贝，修改对 <code>lambda</code> 内对象无影响）</td>
</tr>
<tr>
<td><code>[=, &amp;foo]</code></td>
<td>以引用捕获变量 <code>foo</code>，但其余变量都靠值捕获</td>
</tr>
<tr>
<td><code>[&amp;, foo]</code></td>
<td>以值捕获 <code>foo</code> ，但其余变量都靠引用捕获</td>
</tr>
<tr>
<td><code>[bar]</code></td>
<td>以值方式捕获 <code>bar</code>，不捕获其他变量</td>
</tr>
<tr>
<td><code>[this]</code></td>
<td>捕获所在类的 <code>this</code> 指针</td>
</tr>
</tbody></table>
<p><strong>lambda最大的⼀个优势是在使⽤STL中的算法(algorithms)库</strong></p>
<p>如数组排序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161644180.png" alt="image-20230616102708669-1692155829457"></p>
<p>set&lt;&gt;</p>
<p>deque</p>
<p>vector&lt;&gt;</p>
<p>map&lt;&gt;</p>
<p>list&lt;&gt;</p>
<p>stack&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 小端模式，高位存内存高地址，地位存低</span><br><span class="line">浮点数最好用double类型(默认)而不是float</span><br><span class="line"></span><br><span class="line">const int c = 12;			# 同c的 #define，声明常量，c++中应使用const</span><br><span class="line"></span><br><span class="line">int xxx[3] = &#123; 20, 1, 16 &#125;		# 花括号直接给数组赋值</span><br><span class="line"></span><br><span class="line">sizeof xx				# 显示xx变量长度字节，（int）加括号为类型</span><br><span class="line"># char为1bytes</span><br><span class="line"># 整形: char (1), short (2), int (4), long (4), long long (8)</span><br><span class="line"># 浮点型: float (4), double (8), long double (80,96,128位&lt;16字节&gt;  /8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示个数则  xx/xx[0]</span><br><span class="line"># 数组默认表示地址，不能像python一样直接打印数组</span><br><span class="line"></span><br><span class="line">strlen()		# 显示字符串长度，需要include cstring</span><br><span class="line">		# 同python的len()，只针对字符串</span><br><span class="line">.size()		# 同上，需要include string</span><br><span class="line"></span><br><span class="line">--&gt; 字符串以空字符结尾 &#x27;\0&#x27;</span><br><span class="line">--&gt; 字符数组相反</span><br><span class="line">char fish[] = &quot;Bubbles&quot;;		</span><br><span class="line"># 字符串常量直接用双引号，末尾会自动加\0，且表地址</span><br><span class="line"># 字符常量用单引号，如：&#x27;s&#x27; , 且与字符串常量不能互换</span><br><span class="line"></span><br><span class="line">面向行的输入：getline(1, 2)</span><br><span class="line"># 不保存换行符！</span><br><span class="line"># 1.用来存储的数组名称 2.读取的字符数(需要-1)</span><br><span class="line"># 例：getline(name, 20)  读19个存到name</span><br><span class="line"></span><br><span class="line">面向行的输入：get(1, 2)		# 保留回车</span><br><span class="line"># 可用get()来读取一个字符（包括回车）</span><br><span class="line"># 可用 cin.get(name, 10).get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string类</span><br><span class="line"># 可以赋值给变量</span><br><span class="line"></span><br><span class="line">struct	结构体 --&gt; c需要关键字struct xx  ， c++ 不需要struct</span><br><span class="line"># 注意结构体赋值是加花括号 &#123; &#125;</span><br><span class="line"></span><br><span class="line">union	共用体 --&gt; 只能存int,lomg,double</span><br><span class="line"></span><br><span class="line">enum xxx &#123;a, b, c&#125;		# 此时xxx为枚举</span><br><span class="line"># xxx ban			# 定义ban为枚举</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针 "></a><a href="#context.27">智能指针</a><a name="section.27"> </a></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.28">定义</a><a name="section.28"> </a></h3><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p>
<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;TC&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> TC())</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TC *tc = ptr.<span class="built_in">get</span>();  <span class="comment">///&lt; 获取原指针</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>();  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);  <span class="comment">///&lt; 析构原指针并赋值 nullptr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="shared-ptr（常用）"><a href="#shared-ptr（常用）" class="headerlink" title="shared_ptr（常用） "></a><a href="#context.29">shared_ptr（常用）</a><a name="section.29"> </a></h3><p>采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p>
<p><strong>注：</strong></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr "></a><a href="#context.30">unique_ptr</a><a name="section.30"> </a></h3><p>unique_ptr采用的是独享资源所有权，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr "></a><a href="#context.31">weak_ptr</a><a name="section.31"> </a></h3><p>弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr "></a><a href="#context.32">auto_ptr</a><a name="section.32"> </a></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。</p>
<p><code>auto_ptr</code> 是一个失败设计，很多公司明确要求不能使用 <code>auto_ptr</code></p>
<h2 id="function"><a href="#function" class="headerlink" title="function "></a><a href="#context.33">function</a><a name="section.33"> </a></h2><p>类似c的函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;<span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();<span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;;<span class="comment">//lambda表达式</span></span><br></pre></td></tr></table></figure>







<h2 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype &#x2F; auto "></a><a href="#context.34">decltype &#x2F; auto</a><a name="section.34"> </a></h2><p><strong>decltype 作用：</strong>用来<strong>推导表达式类型</strong>的关键字，用来在编译时期进行自动类型推导</p>
<p>与 <code>auto</code> 的区别：</p>
<p>auto 根据 &#x3D; 右边的初始值推导出变量的类型，decltype 根据 exp 表达式推导出变量的类型，跟 &#x3D; 右边的 value 没有关系；<br>auto 要求变量必须初始化，因为 auto 是根据变量的初始值来推导变量类型的，如果不初始化，变量的类型也就无法推导；<br>而 decltype 不要求，可不用赋值</p>
<p><strong>decltype  的几种形式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;            <span class="comment">// y -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">0</span>;        <span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// *p -&gt; const int, p -&gt; const int*</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *m = &amp;z;          <span class="comment">// *m -&gt; int, m -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(m)* n = &amp;m;          <span class="comment">// *n -&gt; int*, n -&gt; int**</span></span><br></pre></td></tr></table></figure>



<p><strong>推导规则</strong></p>
<ol>
<li><p>如果 <code>exp</code> 是一个不被括号<code>()</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，<code>decltype(exp)</code> 的类型和 <code>exp</code> 一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> A::total = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">decltype</span>(n) x = n;           <span class="comment">// n 为 int，x 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(r) y = n;           <span class="comment">// r 为 const int &amp;，y 被推导为 const int &amp;</span></span><br><span class="line">	<span class="keyword">decltype</span>(A::total)  z = <span class="number">0</span>;   <span class="comment">// total 是类 A 的一个 int 类型的成员变量，z 被推导为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(A.name) url = <span class="string">&quot;www.baidu.com&quot;</span>; <span class="comment">// url 为 string 类型</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是函数调用，则 <code>decltype(exp)</code> 的类型就和函数返回值的类型一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;   <span class="comment">// 函数返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func2</span><span class="params">(<span class="type">void</span>)</span></span>;       <span class="comment">// 函数返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">double</span>)</span></span>;       <span class="comment">// 函数返回值为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func4</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">// 函数返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func5</span><span class="params">(<span class="type">void</span>)</span></span>;          <span class="comment">// 函数返回值为 const int&amp;&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func1</span>(<span class="number">100</span>,<span class="string">&#x27;A&#x27;</span>)) a = n; <span class="comment">// a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func2</span>()) b = <span class="number">0</span>;        <span class="comment">// b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func3</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;    <span class="comment">// c 的类型为 int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func4</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) x = n;    <span class="comment">// x 的类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func5</span>()) y = <span class="number">0</span>;         <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>如果 <code>exp</code> 是一个左值，或被括号<code>()</code>包围，<code>decltype(exp)</code> 的类型就是 <code>exp</code> 的引用，假设 <code>exp</code> 的类型为 <code>T</code>，则 <code>decltype(exp)</code> 的类型为 <code>T&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> A obj;</span><br><span class="line">	<span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;   <span class="comment">// a 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>((obj.x)) b = a; <span class="comment">// b 的类型为 int&amp;</span></span><br><span class="line">	 </span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(m + n) c = <span class="number">0</span>;     <span class="comment">// n + m 得到一个右值，c 的类型为 int</span></span><br><span class="line">	<span class="keyword">decltype</span>(n = n + m) d = c; <span class="comment">// n = n + m 得到一个左值，d 的类型为 int &amp;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左值：表达式执行结束后依然存在的数据，即持久性数据；右值是指那些在表达式执行结束不再存在的数据，即临时性数据。一个区分的简单方法是：对表达式取地址，如果编译器不报错就是左值，否则为右值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>类的静态成员可以使用 <code>auto</code>， 对于类的非静态成员无法使用 <code>auto</code>，如果想推导类的非静态成员的类型，只能使用 <code>decltype</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">   <span class="keyword">decltype</span>(T.<span class="built_in">begin</span>()) m_it;</span><br><span class="line">   <span class="comment">// typename T::iterator m_it;   // 这种用法会出错</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	   m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	A&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">	obj.<span class="built_in">func</span>(v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2023/07/27/C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">快速判断是否是字母</a><a name="context.1"> </a></li>
<li><a href="#section.2">快速判断两字符是否相同且为字母</a><a name="context.2"> </a></li>
<li><a href="#section.3">C 关键字</a><a name="context.3"> </a><ul>
<li><a href="#section.4">free&#x2F;malloc</a><a name="context.4"> </a></li>
<li><a href="#section.5">float&#x2F;double</a><a name="context.5"> </a></li>
<li><a href="#section.6">union&#x2F;volatile</a><a name="context.6"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="快速判断是否是字母"><a href="#快速判断是否是字母" class="headerlink" title="快速判断是否是字母 "></a><a href="#context.1">快速判断是否是字母</a><a name="section.1"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 包括大小写字母</span><br><span class="line">(uchar)((ch | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<h2 id="快速判断两字符是否相同且为字母"><a href="#快速判断两字符是否相同且为字母" class="headerlink" title="快速判断两字符是否相同且为字母 "></a><a href="#context.2">快速判断两字符是否相同且为字母</a><a name="section.2"> </a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((ch = ch1 ^ ch2) == <span class="number">0</span>) || (ch == <span class="number">0x20</span>) &amp;&amp; ((<span class="type">unsigned</span>)(ch1 | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span></span><br></pre></td></tr></table></figure>



<p>bit -&gt; Byte -&gt; kb	1Byte &#x3D; 8bit</p>
<p>bit比特位	byte字节	且内存中一个空间占一个字节&#x3D;8位</p>
<p><strong>负数在内存中存储的是补码，求原码-1然后除符号位其余取反</strong></p>
<p><strong>且任何数字在内存中都是以补码存储的，正数原反补都一样</strong></p>
<h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C 关键字 "></a><a href="#context.3">C 关键字</a><a name="section.3"> </a></h2><table>
<thead>
<tr>
<th><strong>auto</strong></th>
<th><strong>break</strong></th>
<th><strong>case</strong></th>
<th><strong>char</strong></th>
<th><strong>const</strong></th>
<th><strong>continue</strong></th>
<th><strong>default</strong></th>
<th><strong>do</strong></th>
<th><strong>double</strong></th>
<th><strong>else</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>enum</strong></td>
<td><strong>extern</strong></td>
<td><strong>float</strong></td>
<td><strong>for</strong></td>
<td><strong>goto</strong></td>
<td><strong>if</strong></td>
<td><strong>int</strong></td>
<td><strong>long</strong></td>
<td><strong>register</strong></td>
<td><strong>return</strong></td>
</tr>
<tr>
<td><strong>short</strong></td>
<td><strong>signed</strong></td>
<td><strong>sizeof</strong></td>
<td><strong>static</strong></td>
<td><strong>struct</strong></td>
<td><strong>switch</strong></td>
<td><strong>typedef</strong></td>
<td><strong>union</strong></td>
<td><strong>unsigned</strong></td>
<td><strong>void</strong></td>
</tr>
<tr>
<td><strong>volatile</strong></td>
<td><strong>while</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>typedef</strong> unsigned int uint		把unsigned int重定义为unit</p>
<p><strong>void</strong>							声明函数无返回值或无参数</p>
<p><strong>auto</strong>							在局部中自动销毁原变量值</p>
<p><strong>static</strong> 						静态局部变量，不会销毁，保存赋值</p>
<p><strong>const</strong> <strong>x</strong>						定义常量x，不可改变</p>
<p><strong>extern</strong>						声明外部-变量&#x2F;函数</p>
<p><strong>#define</strong> a 100					定义常量和宏，可以是三目运算符</p>
<table>
<thead>
<tr>
<th>Char</th>
<th>Short</th>
<th>Int</th>
<th>long</th>
<th>long long</th>
<th>folat</th>
<th>double</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>短整型</td>
<td>整型</td>
<td>长整型</td>
<td>超长整型</td>
<td>浮点型</td>
<td>双精度浮点型</td>
</tr>
<tr>
<td>1字节</td>
<td>2字节&#x2F;16位</td>
<td>4字节&#x2F;32位</td>
<td>4字节</td>
<td></td>
<td>4&#x2F;8字节</td>
<td>64位保留后6位</td>
</tr>
</tbody></table>
<p>a&lt;&lt;2			a左移2位</p>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>|</th>
<th>^</th>
<th>!</th>
<th>~</th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td>按位或</td>
<td>异或</td>
<td>非</td>
<td>按位取反</td>
</tr>
<tr>
<td>a&amp;&amp;b（逻辑与）</td>
<td>||</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a, b均为真返回真</td>
<td>逻辑或,有一个返回真</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>%c			打印一个字符串格式的数据</p>
<p>%s			打印字符串</p>
<p>%d			整型十进制数据</p>
<p>%u			无符号的十进制整数</p>
<p>%f			浮点型</p>
<p>%g			浮点，不显示无意义的0</p>
<p>%lf			双精度浮点型</p>
<p>%p			指针，以地址的形式打印</p>
<p>%x			打印十六进制</p>
<p>%o			输出八进制数</p>
<p>%%			‘%’</p>
<p>float</p>
<p>(-1)^s * M * 2^E		s&#x3D;0&#x2F;1	E&#x3D;n(8位,得加127)		M&#x3D;1.?? (23位1.省略)	</p>
<p>​					S	E(8&#x2F;11bit)	M(23&#x2F;52bit)</p>
<p>double				同上，E(加减1023)</p>
<p>整型转换(小转整int)</p>
<p>算数转换(小转大)</p>
<p>​	long double</p>
<p>double</p>
<p>​	float</p>
<p>​	unsigned long int</p>
<p>​	long int</p>
<p>​	unsigned int</p>
<p>​	int</p>
<p>&gt;&gt;			右移（除2），补符号位			左移补0,其他同</p>
<p>exp ? a : b	exp为真则返回a，否则返回b</p>
<p>do{循环语句}</p>
<p>while(判断);</p>
<p>b &#x3D; a++		后置++表示先把a给b，a自己在++</p>
<p>​			前置相反</p>
<p>函数</p>
<p>scanf(“%d”, &amp;n)		获得输入给n</p>
<p>printf(“%d”, n)			打印n</p>
<p>sizeof(char)			看char的长度，单位：byte字节</p>
<p>​					sizeof(数组名) &#x2F; &amp;数组名à表整个数组，其余均表地址</p>
<p>qsort()</p>
<p>strcat(1,2)			把字符串2加到1后面</p>
<p>assert(?)				<strong>断言</strong>，如果?为假则报错，否则继续运行</p>
<p>strcmp(1,2)			逐个比较字符串大小(ASCII)，1&gt;2返回正数，1&#x3D;2返回0，同</p>
<p>strncmp()				同上，比较前n位</p>
<p>strtok(arr,p)			arr,p为指针，在arr中按p切割</p>
<p>定义常量</p>
<p>const int n &#x3D; 4			定义常变量，不能改变</p>
<p>#define n 10			define定义的标识符常量</p>
<p>enum n				枚举常量</p>
<p>{a, b, c}			abc分别对应012</p>
<p>转义符：</p>
<p>\0		在字符串里表到这结束</p>
<p>​	\ddd		ddd表示1-3个八进制的数字，如：\130 表X</p>
<p>​	\xdd		dd表2个十六进制数字，\x30 表0</p>
<table>
<thead>
<tr>
<th>C</th>
<th></th>
<th></th>
<th></th>
<th>Python</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>scanf(“%d”, &amp;a)</td>
<td></td>
<td></td>
<td>输入</td>
<td>input()</td>
<td></td>
</tr>
<tr>
<td>getchar()</td>
<td>获得输入</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数组数组名为地址</td>
<td>char arr[] &#x3D; {‘x1’, ‘’…, 0}</td>
<td>0必加</td>
<td></td>
<td>列表</td>
<td>[]</td>
<td></td>
</tr>
<tr>
<td>char arr[ ][n]</td>
<td>列不可省略</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>字符串长度</td>
<td>strlen()</td>
<td></td>
<td></td>
<td>字符串长度</td>
<td>len(x)</td>
<td></td>
</tr>
<tr>
<td>if ()</td>
<td></td>
<td></td>
<td></td>
<td>if …:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>需要定义变量</td>
<td></td>
<td></td>
<td></td>
<td>不需要定义变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>函数</td>
<td>int Function(x ,y) {}</td>
<td></td>
<td></td>
<td></td>
<td>def function: {}</td>
<td></td>
</tr>
<tr>
<td>结构体</td>
<td>struct Name{}</td>
<td></td>
<td></td>
<td>类</td>
<td>Class</td>
<td></td>
</tr>
<tr>
<td>字符串</td>
<td>不能直接给变量得用数组</td>
<td>strcpy()</td>
<td></td>
<td>字符串</td>
<td>能直接给变量</td>
<td></td>
</tr>
<tr>
<td>转换类型</td>
<td>(int)3.14</td>
<td>3.14-&gt;3</td>
<td></td>
<td>转换类型</td>
<td>int(3.14)</td>
<td></td>
</tr>
</tbody></table>
<p>switch(x)</p>
<p>{</p>
<p>​	case 1: …; break;			加break表执行完退出switch，</p>
<p>​	case 2: …;					无break表执行完后继续往下执行</p>
<p>​	case n: …;</p>
<p>​	default: …; break;			表默认情况执行default的语句</p>
<p>}</p>
<p><strong>指针</strong>		</p>
<p>数组默认传的是指针，如int arr[]; Function(arr)ßarr为指针，是arr[0]的地址</p>
<p>&amp;a&#x3D;0		取a的地址</p>
<p>int* b &#x3D; &amp;a	b为<strong>指针</strong>变量，存a的地址**,** 32位平台是4个字节，64位平台是8个字节</p>
<p>int<em>*c&#x3D;&amp;*b	int**表c指向int</em></p>
<p>*b &#x3D; 20		*为<strong>解引用操作符</strong>，把20存放进b的地址中</p>
<p>arr				首元素地址</p>
<p>&amp;arr[0]			首元素的地址</p>
<p>&amp;arr				数组的地址</p>
<p>int (*p)[10]&#x3D;&amp;a	数组指针			à去掉名字就是类型</p>
<p>int (*p)(int int)&#x3D;Add	函数指针</p>
<p><strong>结构体</strong></p>
<p>(typedef)struct Book		&#x2F;&#x2F;加typedef则下面a为类型，如a s,定义了s结构体</p>
<p>{</p>
<p>​	char name[20];</p>
<p>​	short price;</p>
<p>}à(a)s1,s2;		&#x2F;&#x2F;s1,s2为同Book的全局变量(python的class)</p>
<p>struct Book n1 &#x3D; {“xxx”, 55};</p>
<p>struct Book* pc &#x3D; &amp;n1			&#x2F;&#x2F;定义指针为pc，存结构体n1</p>
<p>printf(“%s”, pc-&gt;name)			&#x2F;&#x2F;打印name，-&gt;表指向，即取该地址的name</p>
<p>srtcpy(n1.name, “new”)			&#x2F;&#x2F;想改name用字符串拷贝，把new给name</p>
<p><strong>结构体内存对齐</strong></p>
<p>​		对齐到本身对齐数整数倍的地址处（参考上一个）</p>
<p>总大小为最大对齐数的整数倍</p>
<p>（嵌套结构体，按最大的字节算）</p>
<p># 数组随下表增长，地址从低到高变化</p>
<p># 栈区地址从高到低存</p>
<p>栈区à		局部变量</p>
<p>​			函数的形式参数</p>
<p>​			函数调用也开辟空间</p>
<p>堆区à		动态内存分配</p>
<p>​			Malloc&#x2F;free</p>
<p>​			Realloc</p>
<p>​			calloc</p>
<p>静态区à		全局变量</p>
<p>​			静态变量	static</p>
<p><strong>枚举</strong></p>
<p><strong>enum Color</strong></p>
<p><strong>{</strong></p>
<p>​	<strong>RED,</strong>		&#x2F;&#x2F;序号为0，也可以赋值</p>
<p>​	<strong>…</strong></p>
<p><strong>}</strong></p>
<p><strong>数据内存存储模式（</strong>以字节为单位<strong>）</strong></p>
<p>1.小端		数据低位存内存低位		内存地址：低à高（左低右高）</p>
<p>2.大端		数据低位存内存高位		数据：高à低（左高右低）如二进制数</p>
<p><em>*<em>划重点！！*<strong><strong>à</strong>	<strong>Keil，C51为大端</strong>		<strong>X86为小端</strong></strong>，很多</em>*</em><em>ARM,DSP也为小端，有些ARM可选</em>*</p>
<p><strong>C语言</strong> à 编译    +    连接</p>
<p>​	编译生成目标文件		目标文件经过链接器，链接库处理，生成可执行文件</p>
<p>汇编 à 二进制</p>
<p><strong>预处理符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__FILE__				返回文件名+路径</span><br><span class="line"></span><br><span class="line">__LINE__				返回所在行数</span><br><span class="line"></span><br><span class="line">__DATE__			返回当今日期</span><br><span class="line"></span><br><span class="line">__TIME__			返回当前时间</span><br></pre></td></tr></table></figure>

<p><strong>文件处理</strong></p>
<p>FILE* pf &#x3D; fopen(“log.txt”, “w”)			以只读打开&#x2F;创建文件</p>
<p>fprintf(pf, “file:%s	line:%d	date:%s	time:%s	i&#x3D;%d\n”,</p>
<p><strong>FILE</strong>, <strong>LINE</strong>, <strong>DATE</strong>, <strong>TIME</strong>, i)			以格式化写文件</p>
<p>fclose(pf)				关闭文件</p>
<p>pf &#x3D; NULL				指针清空</p>
<p><strong>运算效率</strong></p>
<p>移位 &gt; 赋值 &gt; 大小比较 &gt; 加法 &gt; 减法 &gt; 乘法 &gt; 取模 &gt; 除法</p>
<p><strong>回调函数详述</strong></p>
<p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="free-malloc"><a href="#free-malloc" class="headerlink" title="free&#x2F;malloc "></a><a href="#context.4">free&#x2F;malloc</a><a name="section.4"> </a></h3><p>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</p>
<p>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小</p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了</p>
<h3 id="float-double"><a href="#float-double" class="headerlink" title="float&#x2F;double "></a><a href="#context.5">float&#x2F;double</a><a name="section.5"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/float.png" alt="img"></p>
<ul>
<li><em>符号位</em>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li><em>指数位</em>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<strong>指数位的长度越长则数值的表达范围就越大</strong>；</li>
<li><em>尾数位</em>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<strong>尾数的长度决定了这个数的精度</strong>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161639261.png" alt="img"></p>
<p><strong>把小数点，移动到第一个有效数字后面</strong>，即将 1010.101 右移 <code>3</code> 位成 <code>1.010101</code>，右移 3 位就代表 +3，左移 3 位就是 -3。</p>
<p><strong>float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了</strong>，即指数位这 8 位存的是 <code>10000010</code>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p>
<p><code>1.010101</code> 这个数的<strong>小数点右侧的数字就是 float 里的「尾数位」</strong>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <code>01010100000000000000000</code>。</p>
<p>这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<strong>既然这一位永远都是 1，那就可以不用存起来了</strong>。</p>
<p>于是就让 23 位尾数只存储小数部分，然后在计算时会<strong>自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点</strong>。</p>
<p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640274.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640766.png" alt="img"></p>
<p><strong>TIPS:</strong></p>
<blockquote>
<p><strong>为什么负数要用补码表示？</strong></p>
</blockquote>
<p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。</p>
<blockquote>
<p><strong>十进制小数怎么转成二进制？</strong></p>
</blockquote>
<p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p>
<blockquote>
<p><strong>计算机是怎么存小数的？</strong></p>
</blockquote>
<p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：</p>
<ul>
<li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li>
<li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li>
<li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li>
</ul>
<p>用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</p>
<blockquote>
<p><strong>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</strong></p>
</blockquote>
<p>不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p>
<p>因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p>
<p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>
<h3 id="union-volatile"><a href="#union-volatile" class="headerlink" title="union&#x2F;volatile "></a><a href="#context.6">union&#x2F;volatile</a><a name="section.6"> </a></h3><p><strong>union</strong></p>
<p>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。其占内存为最大成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line"><span class="comment">// sizeof(data) 为 sizeof(double) = 8</span></span><br></pre></td></tr></table></figure>



<p><strong>volatile</strong></p>
<p>修饰异变的参数，每次都要去寄存器或内存重新读取</p>
<p>只要变量可能被意外的修改，就需要把该变量声明为volatile。在实际应用中，只有三种类型数据可能被修改：</p>
<ul>
<li>外设寄存器地址映射</li>
<li>在中断服务程序中修改全局变量</li>
<li>在多线程、多任务应用中，全局变量被多个任务读写</li>
</ul>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/07/27/DS/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">二叉树</a><a name="context.1"> </a><ul>
<li><a href="#section.2">遍历方式</a><a name="context.2"> </a><ul>
<li><a href="#section.3">深度优先DFS（Depth First Search）</a><a name="context.3"> </a></li>
<li><a href="#section.4">广度优先BFS（Breath First Search）</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">分类</a><a name="context.5"> </a></li>
</ul>
</li>
<li><a href="#section.6">二叉搜索树（BST）</a><a name="context.6"> </a></li>
<li><a href="#section.7">AVL树（BBT）</a><a name="context.7"> </a><ul>
<li><a href="#section.8">定义</a><a name="context.8"> </a></li>
<li><a href="#section.9">使用场景</a><a name="context.9"> </a></li>
<li><a href="#section.10">插入</a><a name="context.10"> </a><ul>
<li><a href="#section.11">1.左左型右旋</a><a name="context.11"> </a></li>
<li><a href="#section.12">2.左右型的左右旋</a><a name="context.12"> </a></li>
<li><a href="#section.13">3.右右型左旋</a><a name="context.13"> </a></li>
<li><a href="#section.14">4.右左型右左旋</a><a name="context.14"> </a></li>
</ul>
</li>
<li><a href="#section.15">总结</a><a name="context.15"> </a></li>
</ul>
</li>
<li><a href="#section.16">红黑树</a><a name="context.16"> </a><ul>
<li><a href="#section.17">定义</a><a name="context.17"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树 "></a><a href="#context.1">二叉树</a><a name="section.1"> </a></h2><p>为<strong>有序树</strong>：</p>
<p>如果结点的各子树从左到右是有次序的、不能颠倒，则为有序树，否则为无序树。对于有序树的孩子来说，最左边的孩子称为第一个孩子，最右边的孩子称为最后一个孩子。</p>
<p>比如，如果树T1是一个有序树，则其根结点的第一个孩子为结点B，最后一个孩子为结点D</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式 "></a><a href="#context.2">遍历方式</a><a name="section.2"> </a></h3><h4 id="深度优先DFS（Depth-First-Search）"><a href="#深度优先DFS（Depth-First-Search）" class="headerlink" title="深度优先DFS（Depth First Search） "></a><a href="#context.3">深度优先DFS（Depth First Search）</a><a name="section.3"> </a></h4><p>递归遍历 - 函数递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///&lt; 中左右</span></span><br><span class="line">        cout &lt;&lt; tree-&gt;val &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;left);</span><br><span class="line">        <span class="built_in">Recur</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTree</span><span class="params">(Tree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Recur</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 统一遍历方法！！！ */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>迭代遍历 - stack + while</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="广度优先BFS（Breath-First-Search）"><a href="#广度优先BFS（Breath-First-Search）" class="headerlink" title="广度优先BFS（Breath First Search） "></a><a href="#context.4">广度优先BFS（Breath First Search）</a><a name="section.4"> </a></h4><p>层序遍历 - 队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 迭代法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归法 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="分类"><a href="#分类" class="headerlink" title="分类 "></a><a href="#context.5">分类</a><a name="section.5"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230719102948357.png" alt="image-20230719102948357"></p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>



<p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="type">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST） "></a><a href="#context.6">二叉搜索树（BST）</a><a name="section.6"> </a></h2><p>也称<strong>二叉查找树 BST（Binary Search Tree）</strong></p>
<p>二叉搜索树的<strong>重要特质</strong>为，<strong>在二叉树的基础上增加了左子树的所有值应都小于根节点的值，右子树的所有值应都大于根节点的值</strong>。</p>
<p>乍看二叉搜索树的访问效率很高，最大的遍历次数为树的高度，最小的遍历次数为1。但实际存在某种特殊情况，比如根节点只有一个右孩子，然后剩下的全部元素为一条直线向下排列在左子树，造成分部不均匀，查找和插入效率几乎等同于线性结构。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230717160027885.png" alt="image-20230717160027885"></p>
<p>力扣参考题目：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>、<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不同的二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                g[i] += g[j - <span class="number">1</span>] * g[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 验证二叉搜索树</span></span><br><span class="line"><span class="comment">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recur</span><span class="params">(TreeNode *tree, <span class="type">long</span> min, <span class="type">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!tree)</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &lt;= min || tree-&gt;val &gt;= max)</span><br><span class="line">            ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = <span class="built_in">Recur</span>(tree-&gt;left, min, tree-&gt;val) &amp;&amp; <span class="built_in">Recur</span>(tree-&gt;right, tree-&gt;val, max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="AVL树（BBT）"><a href="#AVL树（BBT）" class="headerlink" title="AVL树（BBT） "></a><a href="#context.7">AVL树（BBT）</a><a name="section.7"> </a></h2><p><strong>平衡二叉树</strong>全称叫做 平衡二叉搜索（排序）树，简称 AVL树。英文：Balanced Binary Tree （BBT）</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义 "></a><a href="#context.8">定义</a><a name="section.8"> </a></h3><p>AVL树本质上是一颗二叉搜索树，但它又具有以下特点：</p>
<ol>
<li>它是一颗空树或它的左右两个子树的高度差的绝对值不超过 1</li>
<li>左右两个子树也是一颗平衡二叉树</li>
</ol>
<p><strong>需满足以下特征：</strong></p>
<ol>
<li>对于任何一颗子树的root根结点而言，它的左子树任何节点的key一定比root小，而右子树任何节点的key 一定比root大；</li>
<li>对于AVL树而言，其中任何子树仍然是AVL树；</li>
<li>每个节点的左右子节点的高度之差的绝对值最多为1；</li>
</ol>
<p><strong>平衡因子（BF -  Balance Factor） &#x3D; 左子树的深度 - 右子树的深度</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景 "></a><a href="#context.9">使用场景</a><a name="section.9"> </a></h3><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;&#x3D; 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p>
<p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于<strong>查询场景</strong>， 而不是增加删除频繁的场景。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入 "></a><a href="#context.10">插入</a><a name="section.10"> </a></h3><h4 id="1-左左型右旋"><a href="#1-左左型右旋" class="headerlink" title="1.左左型右旋 "></a><a href="#context.11">1.左左型右旋</a><a name="section.11"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718152017647.png" alt="image-20230718152017647"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左左型</strong> ，我们应该进行右旋转。</p>
<h4 id="2-左右型的左右旋"><a href="#2-左右型的左右旋" class="headerlink" title="2.左右型的左右旋 "></a><a href="#context.12">2.左右型的左右旋</a><a name="section.12"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718152120654.png" alt="image-20230718152120654"></p>
<p>在结点T的 <strong>左结点（L）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>左右型</strong> ，我们应该进行左右旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154009644.png" alt="image-20230718154009644"></p>
<h4 id="3-右右型左旋"><a href="#3-右右型左旋" class="headerlink" title="3.右右型左旋 "></a><a href="#context.13">3.右右型左旋</a><a name="section.13"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154115097.png" alt="image-20230718154115097"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>右子树（R）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右右型</strong> ，我们应该进行左旋转。</p>
<h4 id="4-右左型右左旋"><a href="#4-右左型右左旋" class="headerlink" title="4.右左型右左旋 "></a><a href="#context.14">4.右左型右左旋</a><a name="section.14"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154205.png" alt="image-20230718154205"></p>
<p>在结点T的 <strong>右结点（R）</strong> 的 <strong>左子树（L）</strong> 上做了插入元素的操作，我们称这种情况为 <strong>右左型</strong> ，我们应该进行右左旋。</p>
<p><strong>步骤如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230718154226276.png" alt="image-20230718154226276"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结 "></a><a href="#context.15">总结</a><a name="section.15"> </a></h3><table>
<thead>
<tr>
<th>插入位置</th>
<th>状态</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>在结点T的左结点（L）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>左左型</td>
<td>右旋</td>
</tr>
<tr>
<td>在结点T的左结点（L）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>左右型</td>
<td>左右旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>右子树（R）</strong> 上做了插入元素</td>
<td>右右型</td>
<td>左旋</td>
</tr>
<tr>
<td>在结点T的右结点（R）的 <strong>左子树（L）</strong> 上做了插入元素</td>
<td>右左型</td>
<td>右左旋</td>
</tr>
</tbody></table>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树 "></a><a href="#context.16">红黑树</a><a name="section.16"> </a></h2><p>红黑树（RBT）继承了AVL可自平衡的优点，</p>
<p>同时, 红黑树（RBT）在<strong>查询速率和平衡调整</strong>中寻找平衡，放宽了<strong>树的平衡条件</strong>，从而可以用于 <strong>增加删除频繁</strong>的场景。</p>
<p>在实际应用中，红黑树的使用要多得多。</p>
<p><strong>查找插入删除的时间复杂度为 O(logN)</strong></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 "></a><a href="#context.17">定义</a><a name="section.17"> </a></h3><p><strong>需满足以下特征：</strong></p>
<ol>
<li>节点非黑即红</li>
<li>根节点一定是黑色</li>
<li>叶子节点（NIL）一定是黑色</li>
<li>每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。</li>
</ol>
<p><strong>注：默认插入节点颜色为红色</strong></p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式</title>
    <url>/2023/09/09/Embedded/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">OTA</a><a name="context.1"> </a></li>
<li><a href="#section.2">STM32</a><a name="context.2"> </a><ul>
<li><a href="#section.3">系统架构</a><a name="context.3"> </a></li>
<li><a href="#section.4">启动配置</a><a name="context.4"> </a></li>
<li><a href="#section.5">启动流程</a><a name="context.5"> </a></li>
<li><a href="#section.6">中断向量表</a><a name="context.6"> </a></li>
<li><a href="#section.7">map文件分析</a><a name="context.7"> </a></li>
<li><a href="#section.8">内存管理</a><a name="context.8"> </a><ul>
<li><a href="#section.9">6个储存数据段</a><a name="context.9"> </a></li>
<li><a href="#section.10">3种存储属性区</a><a name="context.10"> </a></li>
<li><a href="#section.11">加载域和运行域</a><a name="context.11"> </a></li>
<li><a href="#section.12">FreeRTOS中的堆</a><a name="context.12"> </a></li>
</ul>
</li>
<li><a href="#section.13">生成bin文件</a><a name="context.13"> </a></li>
</ul>
</li>
<li><a href="#section.14">总线概览</a><a name="context.14"> </a></li>
<li><a href="#section.15">I2C</a><a name="context.15"> </a></li>
<li><a href="#section.16">SPI</a><a name="context.16"> </a><ul>
<li><a href="#section.17">连接方式</a><a name="context.17"> </a></li>
<li><a href="#section.18">基本通讯过程</a><a name="context.18"> </a></li>
<li><a href="#section.19">四种模式</a><a name="context.19"> </a></li>
<li><a href="#section.20">CPOL</a><a name="context.20"> </a></li>
<li><a href="#section.21">CPHA</a><a name="context.21"> </a></li>
</ul>
</li>
<li><a href="#section.22">串口通讯</a><a name="context.22"> </a><ul>
<li><a href="#section.23">物理层</a><a name="context.23"> </a><ul>
<li><a href="#section.24">电平标准</a><a name="context.24"> </a></li>
<li><a href="#section.25">RS232信号线</a><a name="context.25"> </a></li>
</ul>
</li>
<li><a href="#section.26">协议层</a><a name="context.26"> </a><ul>
<li><a href="#section.27">波特率</a><a name="context.27"> </a></li>
<li><a href="#section.28">通讯的起始和停止信号</a><a name="context.28"> </a></li>
<li><a href="#section.29">有效数据</a><a name="context.29"> </a></li>
<li><a href="#section.30">数据校验</a><a name="context.30"> </a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#section.31">中断</a><a name="context.31"> </a></li>
<li><a href="#section.32">DMA</a><a name="context.32"> </a><ul>
<li><a href="#section.33">主要作用</a><a name="context.33"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="OTA"><a href="#OTA" class="headerlink" title="OTA "></a><a href="#context.1">OTA</a><a name="section.1"> </a></h2><p>OTA 是空中升级 <code>Over the air</code> 的缩写，指的是通过无线通信网络（如Wi-Fi、蓝牙、LoRa等）对嵌入式系统进行远程升级或更新。</p>
<p>在嵌入式系统中，OTA技术可以用于更新固件、软件或配置文件等。通过OTA技术，用户可以在不需要物理接触设备的情况下，对其进行升级和更新，从而提高系统的可靠性、安全性和灵活性。</p>
<h2 id="STM32"><a href="#STM32" class="headerlink" title="STM32 "></a><a href="#context.2">STM32</a><a name="section.2"> </a></h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构 "></a><a href="#context.3">系统架构</a><a name="section.3"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308192253545.png" alt="img"></p>
<p><strong>代码区(code area)从0x00000000开始</strong>，通过指令总线(ICode Bus)和数据总线(DCode Bus)对Flash中代码进行访问。</p>
<p><strong>数据区(SRAM)从0x20000000开始</strong>，通过系统总线(System Bus)进行访问。</p>
<h3 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置 "></a><a href="#context.4">启动配置</a><a name="section.4"> </a></h3><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308192255947.png" alt="img"></p>
<p> STM32系列可以有3种启动模式，由BOOT1与BOOT0的设置决定选择Flash、System memory还是SRAM作为启动空间。</p>
<ol>
<li><strong>从主闪存存储器启动(Main Flash memory)：</strong><br> 主闪存存储器被映射到启动空间(0x0000 0000)，<strong>但仍然能够在它原有的地址(0x0800 0000)访问它</strong>，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000。</li>
<li><strong>从系统存储器启动(System memory)：</strong><br> 系统存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(互联型产品原有地址为0x1FFF B000，其它产品原有地址为0x1FFF F000)访问它。 </li>
<li><strong>从内置SRAM启动(Embedded SRAM)：</strong><br> <strong>只能在0x20000000开始的地址区访问SRAM，启动后这个映射消失，需要重定位中断向量表。</strong></li>
</ol>
<p>STM32将 0x00000000 到 0x0005FFFF 的区域作为启动空间（boot space）的别名区。</p>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程 "></a><a href="#context.5">启动流程</a><a name="section.5"> </a></h3><p>精简版：</p>
<ol>
<li><p>&#x3D;&#x3D;<strong>通过Boot引脚设定,寻找初始地址</strong>&#x3D;&#x3D; </p>
</li>
<li><p>&#x3D;&#x3D;<strong>初始化栈指针 __initial_sp，指针位于SRAM区</strong>&#x3D;&#x3D; </p>
</li>
<li><p>&#x3D;&#x3D;<strong>指向复位程序 Reset_Hander</strong>&#x3D;&#x3D; </p>
</li>
<li><p>&#x3D;&#x3D;<strong>设置异常中断 HardFault_Handler</strong>&#x3D;&#x3D; </p>
</li>
<li><p>&#x3D;&#x3D;<strong>设置系统时钟 SystemInit</strong>&#x3D;&#x3D; </p>
</li>
<li><p>&#x3D;&#x3D;<strong>调用C库函数 _main</strong>&#x3D;&#x3D; </p>
</li>
<li><p><strong>首先复位MCU，进行地址映射，获取栈顶指针MSP和PC指针的内容</strong></p>
<p> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308201444357.png" alt="img"><br> MCU上电后，自动执行<br> 当程序编译完成之后，sp堆栈栈顶指针都已经确定。<br> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308201307158.png" alt="img"><br> R13(SP堆栈指针)的值为0x20000868(MSP)存在地址为0x00000000中，R15(PC程序计数器)的值为0x08000420存在地址为0x00000004中，堆栈指针指向sram区，且堆栈必须建立在该区。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308201308487.png" alt="img"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308201308463.png" alt="img"></p>
<p> 当从flash中启动时SP在地址0x08000000中存储,PC的值在地址0x08000004中存储。但仍可以在原地址中被访问。这也就是所谓的映射。</p>
<p>  <b><font color='blue' size=3 face="">这即是手册中所说：主闪存存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的地址(0x0800 0000)访问它，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000。</font></b> </p>
</li>
<li><p><strong>根据PC的值找到复位中断处理函数Reset_Handler</strong><br> <strong>(1) 进入中断处理函数 <code>Reset_Handler</code></strong><br> 中断处理函数外部定义<br> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308201459507.png" alt="img">原地址0x00000004处的内容为0x0800022D,取出后的内容变为了0x0800022C,它把末位的1变成了0，这个是由于内存对齐造成的，因为cortex-m3核PC的LSB一定读回0，因此指令至少是半字对齐的（《cortex-m3编程手册》）。</p>
<p> <code>LDR  R0,  =SystemInit</code> 将函数 <code>SystemInit</code> 的入口地址传给 R0，从反汇编窗口可以看到指令被写成 <code>LDR   r0,   [pc,#36]</code>，表明 <code>SystemInit</code> 的入口地址在存放在 PC 指针偏移 36 处，即：<code>0x08000022C（+0x4）+0x24=0x08000254</code>（因为CM3内部使用了指令流水线，读PC时返回的值是当前指令的地址+4《Cortex™-M3权威指南》）下一条指令在 0x0800022E 处。</p>
<p> <strong>(2) 进入 <code>SystemInit</code> 函数MCU复位后，PC所指向的第一行代码</strong></p>
<p> 复位PC后，此时程序寻址到PC指针指示的地址0x0800022C处准备执行</p>
<p> BLX R0 将R0的值传给PC（必须保证加载到PC的数值是奇数（即LSB&#x3D;1），传给PC后，PC的LSB读回0），调用SystemInit函数。</p>
<p> SystemInit这个函数里面开启了外部晶振，设置了锁相环PLL，关闭了所有中断，设置了时钟为72MHz，并且重定位中断向量表在0x08000000处（这句在Flash启动时可以不需要，因为能从0x00000000映射到0x08000000）。</p>
</li>
</ol>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表 "></a><a href="#context.6">中断向量表</a><a name="section.6"> </a></h3><p>STM32的中断向量表是干什么的？到底有什么用？它放在哪里？</p>
<p>一、中断向量表里有什么？它放在那里？到底有什么用？<br>1、中断向量表实际上就是存放在Code区（也就是STM32内部的Flash区）从0x00000000地址开始的一个数组，数组的成员为4个字节，而且这些数组在启动文件的时候已经初始化好。</p>
<p>2、STM32根据内核和外设中断优先级，同一标号，标号越小，优先级越大。然后把内核和外设的中断服务函数的地址放在这个数组里面，数组的下标跟中断的优先级对应，我们也把这个中断的编号叫做中断向量。</p>
<p>3、在启动文件执行的时候，内核和每个外设的中断服务函数的地址都是已经确定好的，地址就存放在中断向量表中，而且在启动文件里面已经写好了中断服务函数，只是这些中断服务函数为空，而且带[weak]弱定义，那么我们就需要在C文件里面重新实现这个中断服务函数，用户写这个中断服务函数的时候，函数名必须跟启动文件里面写的中断函数名对应，因为函数名对应的就是中断服务函数的地址，如果中断服务函数名和启动文件的名字不一样，就默认启动文件里面预先写好的空的中断服务函数，而且是一个死循环，程序就会一直卡死在中断服务函数里面。</p>
<p>二、那内核是如何响应中断的呢？<br>当中断来临的时候，首先取向量，每个中断的中断向量不一样，然后根据向量查询中断向量表，根据里面的地址找到中断服务函数，从而实现整个中断的响应过程。</p>
<h3 id="map文件分析"><a href="#map文件分析" class="headerlink" title="map文件分析 "></a><a href="#context.7">map文件分析</a><a name="section.7"> </a></h3><p>在map文件的最后，都会有这样的汇总信息，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308242103093.png" alt="image-20230625222801536"></p>
<p>上图中：</p>
<p><strong>Code：</strong>代码存储区。这部分是存放代码的。</p>
<p><strong>RO-Data：</strong>只读数据区。这部分保存程序中用 const 定义的全局常量数据和字符串。</p>
<p><strong>RW-Data：</strong>已初始化的读写数据。程序中定义的已经初始化的全局变量和静态变量。</p>
<p><strong>ZI-Data：</strong>未初始化的读写数据。程序中定义的未初始化的全局变量和静态变量。这部分内容是在程序运行的时候保存在RAM中的。</p>
<p><strong><mark>栈顶指针的值 &#x3D; RW-data + ZI-data</mark></strong></p>
<p>map文件中还做了统计：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308242103870.png" alt="image-20230625222912989"></p>
<p>从上图可以看出：</p>
<p><strong>RO：</strong>只读数据。这部分包含 Code 和 RO-Data 这部分是存放在Flash中的。</p>
<p><strong>RW：</strong>可读写数据。这部分包含 RW-Data 和 ZI-Data，这部分是存放在RAM中的，就是占据运行内存的。</p>
<p><strong>ROM Size：</strong>总的ROM的大小。这部分包含Code、RO-data、RW-Data，是程序中占Flash的实际大小。</p>
<p>为了方便理解，可以参考下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308242103202.png" alt="image-20230625222928677"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理 "></a><a href="#context.8">内存管理</a><a name="section.8"> </a></h3><p><code>stm32</code> 的内存管理就是对 <code>0x0800 0000</code> 开始的 <code>Flash</code> 部分和 <code>0x2000 0000</code> 开始的 <code>SRAM</code> 部分的使用和管理</p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202309092223474.png" alt="image-20230909222128002"></p>
<h4 id="6个储存数据段"><a href="#6个储存数据段" class="headerlink" title="6个储存数据段 "></a><a href="#context.9">6个储存数据段</a><a name="section.9"> </a></h4><ul>
<li><strong>data</strong><br>  数据段，储存已初始化的，且初始化不为0的全局变量和静态变量</li>
<li><strong>bss</strong><br>  Block Started by Symbol。储存未初始化的，或初始化为0的全局变量和静态变量</li>
<li><strong>text（Code Segment&#x2F;Text Segment）</strong><br>  代码段，储存程序代码</li>
<li><strong>constdata</strong><br>  储存只读常量</li>
<li><strong>heap</strong><br>  堆，存放进程运行中被动态分配的内存段。其可用大小定义在启动文件startup_stm32fxx.s中，由程序员使用malloc()和free()函数进行分配和释放</li>
<li><strong>stack</strong><br>  栈，其大小定义在启动文件startup_stm32fxx.s中，由系统自动分配和释放。可存放局部变量、函数的参数和返回值，中断发生时能保存现场。但是static声明的局部静态变量不储存在栈中，而是放在data数据段</li>
</ul>
<h4 id="3种存储属性区"><a href="#3种存储属性区" class="headerlink" title="3种存储属性区 "></a><a href="#context.10">3种存储属性区</a><a name="section.10"> </a></h4><ul>
<li><strong>RO（Read Only）</strong><br>  烧写到 Flash 中，可以长久保存。text 代码段和 constdata 都属于 RO。由于需要掉电储存，RO 里也保存了一份 data 的数据</li>
<li><strong>RW（Read Write）</strong><br>  储存在RAM中。data属于此区。上电时单片机会将Flash中保存的data类型数据复制到RAM中，以供读写使用</li>
<li><strong>ZI（Zero Init）</strong><br>  零初始化区，同样储存在RAM里。系统上电时会把此区域的数据进行0初始化。bss，heap，stack均属于这个区域</li>
</ul>
<h4 id="加载域和运行域"><a href="#加载域和运行域" class="headerlink" title="加载域和运行域 "></a><a href="#context.11">加载域和运行域</a><a name="section.11"> </a></h4><p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202309092245842.png" alt="image-20230909224556738"></p>
<p><strong>程序占用 <mark>Flash &#x3D; Code + RO data + RW data</mark></strong></p>
<p><strong>程序运行时候占用 <mark>RAM &#x3D; RW data + ZI data</mark></strong></p>
<p><strong>Code + RO data + RW data</strong> 的大小也是生成的 <strong>bin</strong> 文件的大小</p>
<h4 id="FreeRTOS中的堆"><a href="#FreeRTOS中的堆" class="headerlink" title="FreeRTOS中的堆 "></a><a href="#context.12">FreeRTOS中的堆</a><a name="section.12"> </a></h4><p><mark>FreeRTOS中的堆也属于ZI区</mark>，但是它与STM32内存结构中的堆并不占用相同的空间，两个堆同时存在。以下出现的堆(heap)表示FreeRTOS堆，另外<mark>在STM32启动文件中定义大小的堆称为系统堆</mark></p>
<p>FreeRTOS内核主要使用的内存管理函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xSize )</span>;	<span class="comment">//申请内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> *pv )</span>;	        <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure>

<p>以上函数控制的是 FreeRTOS 堆；系统堆则应使用 <code>malloc()</code> 和 <code>free()</code> 来分配和释放。</p>
<p>FreeRTOS有 5 种 heap 的实现方式，在STM32CubeMX中默认为 heap_4.c。这种方式可以满足大部分使用需求，暂时不用关注其实现细节。</p>
<p>这一个堆的大小定义在 <code>FreeRTOSConfig.c</code> 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ((size_t)3072)</span></span><br></pre></td></tr></table></figure>



<p>FreeRTOS创建任务时默认的任务栈大小为128字，在32位系统中即为128*4&#x3D;512Byte，再加上TCB块占用84Byte，一共596Byte。而大小为3072Byte的堆允许创建3个这样的任务，占用约1800Byte。堆中剩余的部分则存放了系统内核、信号量、队列、任务通知等数据。</p>
<p>需要创建更多任务时，堆的大小可自行修改。用RAM的空间减去已分配的空间，即为能给堆分配的最大空间：</p>
<p><code>Space = RAM − bss − data − SysHeap − Stack</code></p>
<h3 id="生成bin文件"><a href="#生成bin文件" class="headerlink" title="生成bin文件 "></a><a href="#context.13">生成bin文件</a><a name="section.13"> </a></h3><ol>
<li><p><strong>生成 axf 输入文件</strong><br> <img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202309092258040.png" alt="image-20230909225724296"></p>
</li>
<li><p><strong>生成 bin 输出文件</strong></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe --bin --output .\Obj\DW21CTLA.bin .\Obj\xxx.axf</span></span><br><span class="line"><span class="comment">// --output 可缩写为 -o</span></span><br></pre></td></tr></table></figure>

<p> <img src="C:/Users/breeze/AppData/Roaming/Typora/typora-user-images/image-20230909225816776.png" alt="image-20230909225816776"></p>
</li>
</ol>
<h2 id="总线概览"><a href="#总线概览" class="headerlink" title="总线概览 "></a><a href="#context.14">总线概览</a><a name="section.14"> </a></h2><p>UART、I2C、SPI、USB异同</p>
<table>
<thead>
<tr>
<th>总线接口</th>
<th>串&#x2F;并</th>
<th>同步&#x2F;异步</th>
<th>速率</th>
<th>工作方式</th>
<th>用线</th>
<th>总线拓扑结构</th>
<th>信号距离</th>
</tr>
</thead>
<tbody><tr>
<td>UART</td>
<td>串</td>
<td>异步</td>
<td>慢<br />波特率设置</td>
<td>全双工</td>
<td>2线<br />RX、TX</td>
<td>RS485支持总线式、<br />星形、树形</td>
<td>远<br />最远1200m</td>
</tr>
<tr>
<td>I2C</td>
<td>串</td>
<td>同步</td>
<td>慢</td>
<td>半双工</td>
<td>2线<br />SDA、SCL</td>
<td>总线型（特殊的树形）</td>
<td>近</td>
</tr>
<tr>
<td>SPI</td>
<td>串</td>
<td>同步</td>
<td>快</td>
<td>全双工</td>
<td>3线或4线<br />SCLK、SIMO、<br />SOMI、SS（片选）</td>
<td>环形</td>
<td>远</td>
</tr>
<tr>
<td>USB</td>
<td>串</td>
<td>同步</td>
<td>快</td>
<td>半双工</td>
<td>4线<br />VBUS（5V）、GND、<br />D+、D-（3.3V）</td>
<td>星形</td>
<td>近</td>
</tr>
</tbody></table>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C "></a><a href="#context.15">I2C</a><a name="section.15"> </a></h2><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI "></a><a href="#context.16">SPI</a><a name="section.16"> </a></h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式 "></a><a href="#context.17">连接方式</a><a name="section.17"> </a></h3><p>3条总线 + 1条片选线</p>
<p><code>SCK、MOSI、MISO + SS/NSS/CS</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308242104024.png" alt="image-20230805195959632"></p>
<h3 id="基本通讯过程"><a href="#基本通讯过程" class="headerlink" title="基本通讯过程 "></a><a href="#context.18">基本通讯过程</a><a name="section.18"> </a></h3><p><img src="/BCCPP.assets/image-20230805194747396.png" alt="image-20230805194747396"></p>
<h3 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式 "></a><a href="#context.19">四种模式</a><a name="section.19"> </a></h3><table>
<thead>
<tr>
<th>SPI 模式</th>
<th>时钟极性<br />CPOL</th>
<th>时钟相位<br />CPHA</th>
<th>空闲时 SCK 时钟</th>
<th>采样时刻</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>低电平</td>
<td>奇数边沿</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>低电平</td>
<td>偶数边沿</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>高电平</td>
<td>奇数边沿</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>高电平</td>
<td>偶数边沿</td>
</tr>
</tbody></table>
<p>主机与从机需要工作在相同的模式下才可以正常通讯</p>
<p>实际中采用较多的是 <strong>“模式 0”</strong> 与 <strong>“模式 3”</strong>。</p>
<h3 id="CPOL"><a href="#CPOL" class="headerlink" title="CPOL "></a><a href="#context.20">CPOL</a><a name="section.20"> </a></h3><p>指 SPI 通讯设备处于空闲状态时，SCK 信号线的电平信号 (即 SPI 通讯开始前、 NSS 线为高电平时 SCK 的状态)。CPOL&#x3D;0 时，SCK 在空闲状态时为低电平，CPOL&#x3D;1 时，则相反。</p>
<h3 id="CPHA"><a href="#CPHA" class="headerlink" title="CPHA "></a><a href="#context.21">CPHA</a><a name="section.21"> </a></h3><p>指数据的采样的时刻，当 CPHA&#x3D;0 时，MOSI 或 MISO 数据线上的信号将会在SCK 时钟线的“奇数边沿”被采样。 当 CPHA&#x3D;1 时，数据线在 SCK 的“偶数边沿”采样</p>
<p><img src="/BCCPP.assets/image-20230805194827664.png" alt="image-20230805194827664"></p>
<h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯 "></a><a href="#context.22">串口通讯</a><a name="section.22"> </a></h2><p>分为<strong>物理层</strong>和<strong>协议层</strong>来讲解</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层 "></a><a href="#context.23">物理层</a><a name="section.23"> </a></h3><h4 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准 "></a><a href="#context.24">电平标准</a><a name="section.24"> </a></h4><p>根据通讯使用的电平标准不同，串口通讯可分为 TTL 标准及 RS-232 标准，见下表</p>
<table>
<thead>
<tr>
<th>通讯标准</th>
<th>电平标准（发送端）</th>
</tr>
</thead>
<tbody><tr>
<td>5V TTL</td>
<td>逻辑1：2.4V ~ 5V</td>
</tr>
<tr>
<td></td>
<td>逻辑0：0 ~ 0.5V</td>
</tr>
<tr>
<td>RS-232</td>
<td>逻辑1：-15 ~ -3V</td>
</tr>
<tr>
<td></td>
<td>逻辑0：+3V ~ +15V</td>
</tr>
</tbody></table>
<p>我们知道<strong>常见的电子电路中常使用 TTL 的电平标准</strong>，理想状态下，使用 5V 表示二进制逻辑 1， 使用 0V 表示逻辑 0；</p>
<p>而为了增加串口通讯的远距离传输及抗干扰能力，它使用-15V 表示逻辑 1， +15V 表示逻辑 0。</p>
<p>使用 RS232 与 TTL 电平校准表示同一个信号时的对比如下图</p>
<p><img src="D:\1wyh\Learning\经验书23\BCCPP.assets\image-20230720165301371.png" alt="image-20230720165301371"></p>
<p><strong>注：</strong>因为控制器一般使用 TTL 电平标准，所以常常会使用 MA3232 芯片对 TTL 及 RS-232 电平的信号进行互相转换。</p>
<h4 id="RS232信号线"><a href="#RS232信号线" class="headerlink" title="RS232信号线 "></a><a href="#context.25">RS232信号线</a><a name="section.25"> </a></h4><p>在最初的应用中，RS-232 串口标准常用于计算机、路由与调制调解器 (MODEN，俗称“猫”) 之间的通讯， 在这种通讯系统中，设备被分为数据终端设备 DTE(计算机、路由) 和数据通讯设备DCE(调制调解器)。 我们以这种通讯模型讲解它们的信号线连接方式及各个信号线的作用。</p>
<p>在旧式的台式计算机中一般会有 RS-232 标准的 COM 口 (也称 DB9 接口)，见图下。</p>
<p><img src="D:\1wyh\Learning\经验书23\BCCPP.assets\image-20230720165655500.png" alt="image-20230720165655500"></p>
<p><strong>接口示意：</strong></p>
<p><img src="D:\1wyh\Learning\经验书23\BCCPP.assets\image-20230720165720644.png" alt="image-20230720165720644"></p>
<p>信号线说明 (公头，为方便理解，可把 DTE 理解为计算机，DCE 理解为调制调解器)</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>符号</th>
<th>数据方向</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>载波检测</td>
<td>DCD</td>
<td>DTEDCE</td>
<td>Data Carrier Detect，数据载波检测，用于DTE告知对方，本机是否收到对方的载波信号</td>
</tr>
<tr>
<td>2</td>
<td>接收数据</td>
<td>RXD</td>
<td>DTEDCE</td>
<td>Receive Data，数据接收信号，即输入 。</td>
</tr>
<tr>
<td>3</td>
<td>发送数据</td>
<td>TXD</td>
<td>DTEDCE</td>
<td>Transmit Data，数据发送信号，即输出。两个设备之间的TXD与RXD应交叉相连</td>
</tr>
<tr>
<td>4</td>
<td>数据终端 (DTE) 就绪</td>
<td>DTR</td>
<td>DTEDCE</td>
<td>Data Terminal Ready，数据终端就绪，用于DTE向对方告知本机是否已准备好</td>
</tr>
<tr>
<td>5</td>
<td>信号地</td>
<td>GND</td>
<td></td>
<td>地线，两个通讯设备之间的地电位可能不一样，这会影响收发双方的电平信号，所以两个串口设备之间必须要使用地线连接，即共地。</td>
</tr>
<tr>
<td>6</td>
<td>数据设备(DCE)就绪</td>
<td>DSR</td>
<td>DTEDCE</td>
<td>Data Set Ready，数据发送就绪，用于DCE告知对方本机是否处于待命状态</td>
</tr>
<tr>
<td>7</td>
<td>请求发送</td>
<td>RTS</td>
<td>DTEDCE</td>
<td>Request To Send，请求发送， DTE 请求 DCE 本设备向DCE端发送数据</td>
</tr>
<tr>
<td>8</td>
<td>允许发送</td>
<td>CTS</td>
<td>DTEDCE</td>
<td>Clear To Send，允许发送，DCE回应对方的RTS发送请求，告知对方是否可以发送数据</td>
</tr>
<tr>
<td>9</td>
<td>响铃指示</td>
<td>RI</td>
<td>DTEDCE</td>
<td>Ring Indicator，响铃指示，表示DCE端与线路已接通</td>
</tr>
</tbody></table>
<p><img src="D:\1wyh\Learning\经验书23\BCCPP.assets\image-20230720165858716.png" alt="image-20230720165858716"></p>
<p>串口线中的 RTS、CTS、DSR、DTR 及 DCD 信号，使用逻辑 1 表示信号有效，逻辑 0 表示信号无效。 例如，当计算机端控制 DTR 信号线表示为逻辑 1 时，它是为了告知远端的调制调解器，本机已准备好接收数据， 0 则表示还没准备就绪。</p>
<p><strong>在目前的其它工业控制使用的串口通讯中，一般只使用 RXD、TXD 以及 GND 三条信号线！！！</strong></p>
<h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层 "></a><a href="#context.26">协议层</a><a name="section.26"> </a></h3><p>串口通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。在串口通讯的协议层中， 规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据</p>
<p><img src="D:\1wyh\Learning\经验书23\BCCPP.assets\image-20230720170204183.png" alt="image-20230720170204183"></p>
<h4 id="波特率"><a href="#波特率" class="headerlink" title="波特率 "></a><a href="#context.27">波特率</a><a name="section.27"> </a></h4><p>本章中主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号 (如前面讲解的 DB9 接口中是没有时钟信号的)， 所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码，如上图中用虚线分开的每一格就是代表一个码元。 常见的波特率为 4800、9600、115200 等。</p>
<h4 id="通讯的起始和停止信号"><a href="#通讯的起始和停止信号" class="headerlink" title="通讯的起始和停止信号 "></a><a href="#context.28">通讯的起始和停止信号</a><a name="section.28"> </a></h4><p>串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示， 而数据包的停止信号可由 0.5、1、1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。</p>
<h4 id="有效数据"><a href="#有效数据" class="headerlink" title="有效数据 "></a><a href="#context.29">有效数据</a><a name="section.29"> </a></h4><p>在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度 常被约定为 5、6、7 或 8 位长。</p>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验 "></a><a href="#context.30">数据校验</a><a name="section.30"> </a></h4><p>在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差， 可以在传输过程加上校验位来解决这个问题。校验方法有奇校验 (odd)、偶校验(even)、0 校验 (space)、1 校验 (mark) 以及无校验 (noparity)，它们介绍如下：</p>
<p>奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001， 此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据 加上 1 位的校验位总共 9 位。</p>
<p>偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。</p>
<p>0 校验是不管有效数据中的内容是什么，校验位总为“0”，1 校验是校验位总为“1”。</p>
<p>在无校验的情况下，数据包中不包含校验位。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断 "></a><a href="#context.31">中断</a><a name="section.31"> </a></h2><p>在嵌入式系统中，ISR中断和IRQ中断是两种不同类型的中断。</p>
<p><strong>ISR</strong>中断，全称为“Interrupt Service Routine”，是指由硬件或软件触发的中断事件所对应的中断处理程序。当系统发生中断事件时，CPU会暂停当前正在执行的程序，并跳转到ISR中断处理程序的入口点执行特定的操作。ISR中断通常用于处理实时事件和外部设备的中断，例如定时器中断、串口数据到达中断等。</p>
<p><strong>IRQ</strong>中断，全称为“Interrupt Request”，指的是CPU接收到一个外部设备请求服务的信号。外部设备通常通过引脚将中断信息发送给CPU，CPU收到中断信号后会执行相应的中断处理程序。IRQ中断通常用于处理外部设备的事件，例如键盘输入、鼠标点击以及外部中断信号等。</p>
<p>异同点如下：</p>
<ol>
<li>触发方式不同：ISR中断是由硬件或软件触发的中断事件，而IRQ中断是由外部设备发送的中断请求信号触发的。</li>
<li>处理对象不同：ISR中断常用于处理实时事件和外部设备中断，而IRQ中断常用于处理外部设备的事件。</li>
<li>响应时间不同：ISR中断的响应时间通常比IRQ中断更为紧迫，因为ISR中断通常用于处理实时事件，需要尽快响应。</li>
<li>中断优先级不同：ISR中断的优先级可以通过编程设置，而IRQ中断的优先级通常由硬件决定。</li>
<li>中断误差处理方式不同：ISR中断可以轻松地使程序从中断处理程序返回到中断之前的位置，而IRQ中断不具备这种能力，必须通过其他方式解决。</li>
</ol>
<p>需要注意的是，ISR中断的概念更广泛，可以是任何中断处理程序，包括IRQ中断。IRQ中断是一种特定类型的中断，指的是由外部设备请求服务的中断。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA "></a><a href="#context.32">DMA</a><a name="section.32"> </a></h2><p>即直接内存访问（Direct Memory Access），是计算机系统中一种用于减轻中央处理器（CPU）负载的技术。它允许外设（如网络卡、硬盘控制器等）直接与系统内存交换数据，而不需要经过CPU的介入。</p>
<h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用 "></a><a href="#context.33">主要作用</a><a name="section.33"> </a></h3><p>DMA的主要作用是提高数据传输的效率和系统的整体性能，它可以实现以下功能：</p>
<ol>
<li>数据传输：DMA可以直接控制总线，将数据从外设读入内存或从内存写出到外设，而无需通过CPU进行数据传输。</li>
<li>解放CPU负载：DMA的工作过程中，CPU可以继续执行其他任务，而不需要等待数据传输完成，从而减轻了CPU的负载。</li>
<li>快速数据交换：DMA传输数据的速度往往比CPU慢，因此它常用于大数据量的高速输入输出设备，可以快速地将数据从外设传输到内存或者从内存传输到外设。</li>
<li>多任务处理：使用DMA可以使CPU在数据传输过程中同时处理其他任务，从而提高系统的并发处理能力。</li>
</ol>
<p><strong>一些常见的应用场景包括：</strong></p>
<ol>
<li>高速网络传输：DMA技术广泛应用于以太网卡和网络交换机等网络设备中，可以实现高速数据传输和实时流处理。</li>
<li>存储设备控制：DMA可以用于硬盘控制器、固态硬盘(SSD)等存储设备，提高数据传输速度和读写操作的效率。</li>
<li>图形处理：DMA可以用于图形处理单元（GPU）与系统内存之间的数据传输，加速图形渲染和图形计算等操作。</li>
<li>音视频处理：DMA技术常用于音频和视频编解码、实时流媒体传输等领域，提高数据传输速度和处理效率。</li>
</ol>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS</title>
    <url>/2023/08/18/FreeRTOS/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">第11章 - 移植FreeRTOS到STM32</a><a name="context.1"> </a></li>
<li><a href="#section.2">第12章 - 任务</a><a name="context.2"> </a><ul>
<li><a href="#section.3">静态创建示例</a><a name="context.3"> </a></li>
<li><a href="#section.4">动态创建示例</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">第13章 - FreeRTOS 的启动流程</a><a name="context.5"> </a></li>
<li><a href="#section.6">第14章 - 任务管理</a><a name="context.6"> </a><ul>
<li><a href="#section.7">任务迁移图</a><a name="context.7"> </a></li>
<li><a href="#section.8">任务函数</a><a name="context.8"> </a></li>
<li><a href="#section.9">任务设计要点</a><a name="context.9"> </a></li>
<li><a href="#section.10">互斥量</a><a name="context.10"> </a></li>
</ul>
</li>
<li><a href="#section.11">第15章 - 消息队列</a><a name="context.11"> </a><ul>
<li><a href="#section.12">应用场景</a><a name="context.12"> </a></li>
<li><a href="#section.13">常用函数</a><a name="context.13"> </a></li>
</ul>
</li>
<li><a href="#section.14">第16章 - 信号量</a><a name="context.14"> </a><ul>
<li><a href="#section.15">二值信号量</a><a name="context.15"> </a><ul>
<li><a href="#section.16">二值信号量与互斥量的区别</a><a name="context.16"> </a></li>
</ul>
</li>
<li><a href="#section.17">互斥信号量量</a><a name="context.17"> </a></li>
<li><a href="#section.18">计数信号量</a><a name="context.18"> </a></li>
<li><a href="#section.19">递归信号量</a><a name="context.19"> </a></li>
<li><a href="#section.20">其他函数</a><a name="context.20"> </a></li>
</ul>
</li>
<li><a href="#section.21">第17章 - 互斥量</a><a name="context.21"> </a><ul>
<li><a href="#section.22">相关函数</a><a name="context.22"> </a></li>
</ul>
</li>
<li><a href="#section.23">第18章 - 事件</a><a name="context.23"> </a><ul>
<li><a href="#section.24">事件函数</a><a name="context.24"> </a></li>
</ul>
</li>
<li><a href="#section.25">第19章 - 软件定时器</a><a name="context.25"> </a><ul>
<li><a href="#section.26">定时器函数</a><a name="context.26"> </a></li>
</ul>
</li>
<li><a href="#section.27">第20章 - 任务通知</a><a name="context.27"> </a><ul>
<li><a href="#section.28">任务通知函数</a><a name="context.28"> </a></li>
</ul>
</li>
<li><a href="#section.29">第21章 - 内存管理</a><a name="context.29"> </a><ul>
<li><a href="#section.30">内存管理接口</a><a name="context.30"> </a></li>
</ul>
</li>
<li><a href="#section.31">第22章 - 中断管理</a><a name="context.31"> </a><ul>
<li><a href="#section.32">异常分类</a><a name="context.32"> </a></li>
<li><a href="#section.33">中断</a><a name="context.33"> </a></li>
</ul>
</li>
<li><a href="#section.34">第23章 - CPU利用率</a><a name="context.34"> </a></li>
<li><a href="#section.35">FreeRTOS操作系统调度方式有哪些？</a><a name="context.35"> </a></li>
</ul>
<hr>
<h2 id="第11章-移植FreeRTOS到STM32"><a href="#第11章-移植FreeRTOS到STM32" class="headerlink" title="第11章 - 移植FreeRTOS到STM32 "></a><a href="#context.1">第11章 - 移植FreeRTOS到STM32</a><a name="section.1"> </a></h2><p>demo工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└---- demo</span><br><span class="line">      ├---- doc</span><br><span class="line">      ...</span><br><span class="line">      ├---- FreeRTOS</span><br><span class="line">      |     ├---- include		# FreeRTOS/Source/include/*</span><br><span class="line">      |     ├---- port			# FreeRTOS/Source/portable/ MemMang + RVDS</span><br><span class="line">      |     └---- src			# FreeRTOS/Source/*.c</span><br><span class="line">      └---- User</span><br><span class="line">            ...</span><br><span class="line">            ├---- FreeRTOSConfig.h		# FreeRTOS/Demo/CORTEX_STM32F103_Keil/  建议使用野火的，有注释</span><br><span class="line">            ├---- stm32f10x_conf.h</span><br><span class="line">            ├---- stm32f10x_it.c</span><br><span class="line">            ├---- stm32f10x_it.h</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<p><strong>修改 FreeRTOSConfig.h 一定要注意</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">            FreeRTOS与中断服务函数有关的配置选项                         </span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler 	PendSV_Handler		<span class="comment">///&lt; 实现需注释掉</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler 	SVC_Handler</span></span><br></pre></td></tr></table></figure>

<p>同时，将 <code>stm32f10x_it.c</code> 中的上面两个实现注释掉，并且实现 <code>systick</code>中断服务函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SysTick Handler.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">    <span class="keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_xTaskGetSchedulerState */</span>        </span></span><br><span class="line">        xPortSysTickHandler();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_xTaskGetSchedulerState == 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_xTaskGetSchedulerState */</span>        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多任务管理机制分为<strong>抢占式</strong>和<strong>协作式</strong>两种。</p>
<p>抢占式优先处理优先级高的任务，协作式等待任务主动释放后才切换任务。</p>
<h2 id="第12章-任务"><a href="#第12章-任务" class="headerlink" title="第12章 - 任务 "></a><a href="#context.2">第12章 - 任务</a><a name="section.2"> </a></h2><p>创建任务方式分为两种：</p>
<ol>
<li>静态创建<br><code>SRAM</code> 静态内存的例程中，任务控制块和任务栈的内存空间都是从内部的 <code>SRAM</code> 中分配的，具体分配到哪个地址由编译器决定。</li>
<li>动态创建<br>即，堆。其实堆也是内存，也属于 <code>SRAM</code> 。<code>FreeRTOS</code> 的做法是在 <code>SRAM</code> 中定义一个大数组（即堆内存）供 <code>FreeRTOS</code> 的动态内存分配函数使用。第一次使用会对堆初始化，在 <code>heap_x.c</code> 中实现。</li>
</ol>
<p><strong>注：FreeRTOS默认动态创建</strong></p>
<h3 id="静态创建示例"><a href="#静态创建示例" class="headerlink" title="静态创建示例 "></a><a href="#context.3">静态创建示例</a><a name="section.3"> </a></h3><p>静态创建需要自己定义栈大小等，且在 <code>FreeRTOSConfig.h</code> 中需要打开宏 <code>configSUPPORT_STATIC_ALLOCATION</code></p>
<p>还需要对栈进行8字节对齐(FreeRTOS默认8字节对齐)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             包含的头文件</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="comment">/* FreeRTOS头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开发板硬件bsp头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 任务句柄 ****************************/</span></span><br><span class="line"><span class="comment">/* 创建任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t AppTaskCreate_Handle;</span><br><span class="line"><span class="comment">/* LED 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED_Task_Handle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 全局变量申明(静态创建任务需要) ****************************/</span></span><br><span class="line"><span class="comment">/* AppTaskCreate任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t AppTaskCreate_Stack[<span class="number">128</span>];</span><br><span class="line"><span class="comment">/* LED任务栈*/</span></span><br><span class="line"><span class="type">static</span> StackType_t LED_Task_Stack[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* AppTaskCreate 任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t AppTaskCreate_TCB;</span><br><span class="line"><span class="comment">/* LED_Task 任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t LED_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE];</span><br><span class="line"><span class="comment">/* 定时器任务栈 */</span></span><br><span class="line"><span class="type">static</span> StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Idle_Task_TCB;</span><br><span class="line"><span class="comment">/* 定时器任务控制块 */</span></span><br><span class="line"><span class="type">static</span> StaticTask_t Timer_Task_TCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             函数申明</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态创建任务需要 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                   StackType_t **ppxIdleTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态创建任务需要 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                    StackType_t **ppxTimerTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulTimerTaskStackSize)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************</span></span><br><span class="line"><span class="comment">* @brief 主函数</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @retval 无</span></span><br><span class="line"><span class="comment">* @note step.1 开发板硬件初始化</span></span><br><span class="line"><span class="comment">        step.2 创建APP应用任务</span></span><br><span class="line"><span class="comment">        step.3 启动FreeTROS，开始多任务调度</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 开发板硬件初始化 */</span></span><br><span class="line">    BSP_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my rtos demo\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建AppTaskCreate 任务 */</span></span><br><span class="line">    AppTaskCreate_Handle = xTaskCreateStatic((TaskFunction_t)AppTaskCreate,</span><br><span class="line">                                             (<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;AppTaskCreate&quot;</span>,</span><br><span class="line">                                             (<span class="type">uint32_t</span>)<span class="number">128</span>,</span><br><span class="line">                                             (<span class="type">void</span>*)<span class="literal">NULL</span>,</span><br><span class="line">                                             (UBaseType_t)<span class="number">3</span>,</span><br><span class="line">                                             (StackType_t*)AppTaskCreate_Stack,</span><br><span class="line">                                             (StaticTask_t*)&amp;AppTaskCreate_TCB);</span><br><span class="line">                                             </span><br><span class="line">    <span class="keyword">if</span> (AppTaskCreate_Handle != <span class="literal">NULL</span>)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        vTaskStartScheduler();  <span class="comment">///&lt; 启动任务，开启调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常情况下不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    taskENTER_CRITICAL();  <span class="comment">///&lt; 进入临界区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 LED_Task 任务 */</span></span><br><span class="line">    LED_Task_Handle = xTaskCreateStatic((TaskFunction_t)LED_Task,</span><br><span class="line">                                       (<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;LED_Task&quot;</span>,</span><br><span class="line">                                       (<span class="type">uint32_t</span>)<span class="number">128</span>,</span><br><span class="line">                                       (<span class="type">void</span>*)<span class="literal">NULL</span>,</span><br><span class="line">                                       (UBaseType_t)<span class="number">4</span>,</span><br><span class="line">                                       (StackType_t*)LED_Task_Stack,</span><br><span class="line">                                       (StaticTask_t*)&amp;LED_Task_TCB);</span><br><span class="line">                                       </span><br><span class="line">    <span class="keyword">if</span> (LED_Task_Handle != <span class="literal">NULL</span>)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vTaskDelete(AppTaskCreate_Handle);  <span class="comment">///&lt; 删除 AppTaskCreate 任务</span></span><br><span class="line">    taskEXIT_CRITICAL();  <span class="comment">///&lt; 退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED3_ON;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led3_task running, LED3_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led3_task running, LED3_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * STM32中断优先级分组为4，即4位都用来表示抢占优先级，范围为0~15</span></span><br><span class="line"><span class="comment">     * 优先级只需要分组一次即可，以后如果有其他的任务需要用到中断，</span></span><br><span class="line"><span class="comment">     * 都统一用这个优先级分组，千万不要再分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* LED 初始化 */</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试硬件是否正常工作 */</span></span><br><span class="line">    LED3_ON;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串口初始化 */</span></span><br><span class="line">    USART_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetIdleTaskMemory</span><span class="params">(StaticTask_t **ppxIdleTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                   StackType_t **ppxIdleTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> *pulIdleTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *ppxIdleTaskTCBBuffer = &amp;Idle_Task_TCB;</span><br><span class="line">    *ppxIdleTaskStackBuffer = Idle_Task_Stack;</span><br><span class="line">    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationGetTimerTaskMemory</span><span class="params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span></span><br><span class="line"><span class="params">                                    StackType_t **ppxTimerTaskStackBuffer,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulTimerTaskStackSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    *ppxTimerTaskTCBBuffer = &amp;Timer_Task_TCB;</span><br><span class="line">    *ppxTimerTaskStackBuffer = Timer_Task_Stack;</span><br><span class="line">    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************END OF FILE****************************/</span></span><br></pre></td></tr></table></figure>



<h3 id="动态创建示例"><a href="#动态创建示例" class="headerlink" title="动态创建示例 "></a><a href="#context.4">动态创建示例</a><a name="section.4"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             包含的头文件</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="comment">/* FreeRTOS头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开发板硬件bsp头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 任务句柄 ****************************/</span></span><br><span class="line"><span class="comment">/* 创建任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t AppTaskCreate_Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* LED1 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED1_Task_Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* LED2 任务句柄 */</span></span><br><span class="line"><span class="type">static</span> TaskHandle_t LED2_Task_Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 全局变量申明 ****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*                             函数申明</span></span><br><span class="line"><span class="comment">*************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED2_Task</span><span class="params">(<span class="type">void</span> *pvParameters)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************</span></span><br><span class="line"><span class="comment">* @brief 主函数</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @retval 无</span></span><br><span class="line"><span class="comment">* @note step.1 开发板硬件初始化</span></span><br><span class="line"><span class="comment">        step.2 创建APP应用任务</span></span><br><span class="line"><span class="comment">        step.3 启动FreeTROS，开始多任务调度</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;  <span class="comment">///&lt; 定义一个创建信息返回值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开发板硬件初始化 */</span></span><br><span class="line">    BSP_Init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my rtos demo\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 AppTaskCreate 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)AppTaskCreate,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;AppTaskCreate&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">1</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;AppTaskCreate_Handle);</span><br><span class="line">                          </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        vTaskStartScheduler();  <span class="comment">///&lt; 启动任务，开启调度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  <span class="comment">///&lt; 正常情况下不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppTaskCreate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdPASS;  <span class="comment">///&lt; 定义一个创建信息返回值</span></span><br><span class="line">    </span><br><span class="line">    taskENTER_CRITICAL();  <span class="comment">///&lt; 进入临界区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 LED1_Task 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)LED1_Task,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;LED1_Task&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">2</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;LED1_Task_Handle);</span><br><span class="line">                                </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 LED2_Task 任务 */</span></span><br><span class="line">    xReturn = xTaskCreate((TaskFunction_t)LED2_Task,</span><br><span class="line">                          (<span class="type">const</span> <span class="type">char</span>*   )<span class="string">&quot;LED2_Task&quot;</span>,</span><br><span class="line">                          (<span class="type">uint16_t</span>      )<span class="number">512</span>,</span><br><span class="line">                          (<span class="type">void</span>*         )<span class="literal">NULL</span>,</span><br><span class="line">                          (UBaseType_t   )<span class="number">3</span>,</span><br><span class="line">                          (TaskHandle_t* )&amp;LED2_Task_Handle);</span><br><span class="line">                                </span><br><span class="line">    <span class="keyword">if</span> (xReturn == pdPASS)  <span class="comment">///&lt; 任务创建成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2_Task 任务创建成功！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2_Task 任务创建失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vTaskDelete(AppTaskCreate_Handle);  <span class="comment">///&lt; 删除 AppTaskCreate 任务</span></span><br><span class="line">    taskEXIT_CRITICAL();  <span class="comment">///&lt; 退出临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED1_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED3_ON;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led1_task running, LED3_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led1_task running, LED3_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED2_Task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2_ON;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led2_task running, LED2_ON\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LED3_OFF;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;led2_task running, LED2_OFF\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * STM32中断优先级分组为4，即4位都用来表示抢占优先级，范围为0~15</span></span><br><span class="line"><span class="comment">     * 优先级只需要分组一次即可，以后如果有其他的任务需要用到中断，</span></span><br><span class="line"><span class="comment">     * 都统一用这个优先级分组，千万不要再分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* LED 初始化 */</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试硬件是否正常工作 */</span></span><br><span class="line">    LED3_ON;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 串口初始化 */</span></span><br><span class="line">    USART_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************END OF FILE****************************/</span></span><br></pre></td></tr></table></figure>





<h2 id="第13章-FreeRTOS-的启动流程"><a href="#第13章-FreeRTOS-的启动流程" class="headerlink" title="第13章 - FreeRTOS 的启动流程 "></a><a href="#context.5">第13章 - FreeRTOS 的启动流程</a><a name="section.5"> </a></h2><p>主要有两种：</p>
<ol>
<li>万事俱备只欠东风<br>一次性创建完所有带阻塞的任务，然后直接进行任务调度</li>
<li>小心翼翼，十分谨慎<br>只创建一个任务，然后开始调度，在任务中创建其他带阻塞的任务，最后需删除初始任务</li>
</ol>
<p><strong>注：RT-Thread和FreeRTOS默认使用第二种</strong></p>
<p><strong>在临界区创建的任务会在退出临界区后按优先级排序执行！</strong></p>
<h2 id="第14章-任务管理"><a href="#第14章-任务管理" class="headerlink" title="第14章 - 任务管理 "></a><a href="#context.6">第14章 - 任务管理</a><a name="section.6"> </a></h2><p><code>freeRTOS</code> 内核采用两种方法寻找最高优先级的任务，</p>
<ol>
<li>通用方法：<br>在就绪链表中从高优先级往低优先级查找 <code>uxTopPriority</code>，因为在创建任务时已经将优先级进行排序，查找到的第一个 <code>uxTopPriority</code> 就是我们需要的任务，然后通过 <code>uxTopPriority</code> 获取对应的任务控制块。</li>
<li>特殊方法：<br>利用计算前导零指令 <code>CLZ</code>，直接在 <code>uxTopReadyPriority</code> 这个32位的变量中得出 <code>uxTopPriority</code>，这样就可以知道哪一个优先级任务能够运行，这种调度算法比普通方法更便捷，但受限于平台（在 <code>STM32</code> 中我们就使用这种方法）。</li>
</ol>
<h3 id="任务迁移图"><a href="#任务迁移图" class="headerlink" title="任务迁移图 "></a><a href="#context.7">任务迁移图</a><a name="section.7"> </a></h3><p><img src="D:\1wyh\Learning\经验书23\FreeRTOS.assets\image-20230510190415673.png" alt="image-20230510190415673"></p>
<h3 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数 "></a><a href="#context.8">任务函数</a><a name="section.8"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务挂起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">(TaskHandle_t xTaskToSuspend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务挂起</span></span><br><span class="line"><span class="comment"> * @note: 挂起任务调度器（挂起所有任务），调用几次就需要恢复几次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * @note: 调用一次即可恢复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * @note: 同上，区别是此函数专门用在中断服务函数程序中，不能用于任务和中断间的同步!!!</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 需要进行上下文切换; pdFASLE: 不需要上下文切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">vTaskResumeFromISR</span><span class="params">(TaskHandle_t xTaskToResume)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务恢复</span></span><br><span class="line"><span class="comment"> * return pdTRUE: 需要进行上下文切换; pdFASLE: 不需要上下文切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">vTaskResumeAll</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务删除</span></span><br><span class="line"><span class="comment"> * @param xTaskToDelete: 若为 NULL 则表示删除自身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务延时（相对）</span></span><br><span class="line"><span class="comment"> * @note: 相对延时，调用结束后开始计算，不适用于周期性执行任务的场合，因为会被打断!!!</span></span><br><span class="line"><span class="comment"> * @param xTicksToDelay: 单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务延时（绝对）</span></span><br><span class="line"><span class="comment"> * @note: 绝对延时，常用于较精确的周期运行任务，不受外界影响</span></span><br><span class="line"><span class="comment"> * @param pxPreviousWakeTime: 指针变量，保存任务最后一次解除阻塞的时刻，第一次使用时必须为当前时间!</span></span><br><span class="line"><span class="comment"> * @param xTimeIncrement: 周期循环时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">(TickType_T * <span class="type">const</span> pxPreviousWakeTime, </span></span><br><span class="line"><span class="params">                     <span class="type">const</span> TickType_t   xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>



<h3 id="任务设计要点"><a href="#任务设计要点" class="headerlink" title="任务设计要点 "></a><a href="#context.9">任务设计要点</a><a name="section.9"> </a></h3><p>需要考虑任务运行的上下文环境，任务的执行时间是否合理</p>
<ol>
<li><p>中断服务函数</p>
<p>优先级最高，运行在非任务的执行环境下（一般为芯片的特殊运行模式，也称特权模式），一般只标记事件的发生，然后通知任务去处理，需要快进快出，因此不能挂起当前任务，不能调用会阻塞运行的API</p>
</li>
<li><p>普通任务<br>不允许出现死循环（无阻塞）</p>
</li>
<li><p>空闲任务（idle任务）<br>FreeRTOS需要保证至少有一个任务在运行，因此这是唯一一个不允许出现阻塞的任务</p>
</li>
<li><p>任务的执行时间<br>指两方面，一是任务从开始到结束的时间；二是任务的周期<br>设计时，必须考虑任务的时间，一般来说处理时间更短的任务，其优先级应设置得更高一些。</p>
</li>
</ol>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量 "></a><a href="#context.10">互斥量</a><a name="section.10"> </a></h3><p>互斥量是二值信号量的特殊形式 (它也是通过 Queue 实现)，与二值信号量不同，互斥量用于控制多个任务之间共享资源的访问，也就是互锁；</p>
<p>不同于上面两种，互斥量不但开放了中断，同时也不挂起调度器；</p>
<p>注：<strong>互斥量具有优先级继承机制！！！</strong>使用互斥量，需要定义 <strong>configUSE_MUTEXES</strong> 为 1</p>
<p>如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么优先级继承能够降低优先级翻转的影响呢？举个例子，现在有任务A、任务B和任务C，三个任务的优先级顺序为任务C&gt;任务B&gt;任务A。任务A和任务C都要使用某一个硬件资源，并且当前任务A占有该资源。</span><br><span class="line"></span><br><span class="line">先看没有优先级继承的情况：任务C也要使用该资源，但是此时任务A正在使用这个资源，因此任务C进入阻塞，此时三个任务的优先级顺序没有发生变化。在任务C进入阻塞之后，某硬件产生了一次中断，唤醒了一个事件，该事件可以解除任务B的阻塞状态。在中断结束后，因为任务B的优先级是大于任务A的，所以任务B抢占任务A的CPU权限。那么任务C的阻塞时间就至少为：中断处理时间+任务B的运行时间+任务A的运行时间。</span><br><span class="line"></span><br><span class="line">再看有优先级继承的情况：任务C也要使用该资源，但是此时任务A正在使用这个资源，因此任务C进入阻塞，此时由于优先级A会继承任务C的优先级，三个任务的优先级顺序发生了变化，新的优先级顺序为：任务C=任务A&gt;任务B。在任务C进入阻塞之后，某硬件产生了一次中断，唤醒了一个事件，该事件可以解除任务B的阻塞状态。在中断结束后，因为任务A的优先级临时被提高，大于任务B的优先级，所以任务A继续获得CPU权限。任务A完成后，处于高优先级的任务C会接管CPU。所以任务C的阻塞时间为：中断处理时间+任务A的运行时间。看，任务C的阻塞时间变小了，这就是优先级继承的优势。</span><br></pre></td></tr></table></figure>





<h2 id="第15章-消息队列"><a href="#第15章-消息队列" class="headerlink" title="第15章 - 消息队列 "></a><a href="#context.11">第15章 - 消息队列</a><a name="section.11"> </a></h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景 "></a><a href="#context.12">应用场景</a><a name="section.12"> </a></h3><p>队列是 <code>FreeRTOS</code> 主要的任务间通信方式，读取采用先进先出（FIFO），也支持后进先出（LIFO）</p>
<p>用于 1.任务与任务间；2.中断和任务间；传送信息，通过复制的方式实现的，数据量过大时传指针。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数 "></a><a href="#context.13">常用函数</a><a name="section.13"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态创建队列</span></span><br><span class="line"><span class="comment"> * @param uxQueueLength: 队列能够存储的最大消息单元数目，即队列长度</span></span><br><span class="line"><span class="comment"> * @param uxItemSize: 队列中消息单元的大小、以字节为单位</span></span><br><span class="line"><span class="comment"> * @return 创建成功则返回队列句柄，用于访问创建的队列；不成功则返回NULL，可能原因是创建队列所需的RAM分配失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">(UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                           UBaseType_t uxItemSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态创建队列</span></span><br><span class="line"><span class="comment"> * @param uxQueueLength: 队列能够存储的最大单元数目，即队列深度</span></span><br><span class="line"><span class="comment"> * @param uxItemSize: 队列中数据单元的长度，以字节为单位</span></span><br><span class="line"><span class="comment"> * @param pucQueueStorageBuffer: 指针，指向一个 uint8_t 类型的数组，数组大小至少为 uxQueueLength * uxItemSize 个字节；</span></span><br><span class="line"><span class="comment"> *							     为 0 时，pxQueueBuffer 可以为NULL</span></span><br><span class="line"><span class="comment"> * @param pxQueueBuffer: 指针，指向 StaticQueue_t 类型的变量，此变量用于存储队列的数据结构</span></span><br><span class="line"><span class="comment"> * @return 创建成功则返回队列句柄，用于访问创建的队列；不成功则返回NULL，可能原因是创建队列所需的RAM分配失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(UBaseType_t   uxQueueLength,</span></span><br><span class="line"><span class="params">                                 UBaseType_t   uxItemSize,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint8_t</span>       *pucQueueStorageBuffer,</span></span><br><span class="line"><span class="params">                                 StaticQueue_t *pxQueueBuffer)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除队列</span></span><br><span class="line"><span class="comment"> * @param xQueue: 所需删除的队列句柄，如果未被创建无法删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xQueueDelete</span><span class="params">(QueueHandle_t xQueue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列发送消息</span></span><br><span class="line"><span class="comment"> * @brief: 向队列尾部插入</span></span><br><span class="line"><span class="comment"> * @note: 等同于 xQueueSendToBack();</span></span><br><span class="line"><span class="comment"> * 		  不能在中断服务程序中被调用，在中断中必须使用带有中断保护功能的 xQueueSendFromISR()</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列尾部的队列消息</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                      TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列发送消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向队列尾部插入</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列尾部的队列消息</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将此设置成 pdTRUE，</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	     cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                             BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">/* demo</span></span><br><span class="line"><span class="comment">void vBufferISR(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    char cIn;</span></span><br><span class="line"><span class="comment">    BaseType_t xHighterPriorityTaskWoken;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    /* 在ISR开始时，我们并没有唤醒任务 */</span></span><br><span class="line">    xHighterPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 直到缓冲区为空 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 从缓冲区获取一个字节的数据 */</span></span><br><span class="line">        cIn = portINPUT_BTYE(RX_REGISTER_ADRESS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送这个数据 */</span></span><br><span class="line">        xQueueSendFromISR(xRxQueue, &amp;cIn, &amp;xHighterPriorityTaskWoken);</span><br><span class="line">    &#125; <span class="keyword">while</span> (portINPUT_BTYE(BUFFER_COUNT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这时 buffer 已经为空，如果需要，则进行上下文切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (xHighterPriorityTaskWoken) &#123;</span><br><span class="line">        <span class="comment">/* 上下文切换，这时一个宏，不同的处理器，具体的方法不一样 */</span></span><br><span class="line">        taskYIELD_FROM_ISR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列头发送消息</span></span><br><span class="line"><span class="comment"> * @brief: 向队列头部插入</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列头部的消息</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	     cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                             TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向队列头发送消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向队列头部插入信息</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue: 指针，指向要发送到队列头部的消息</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将此设置成 pdTRUE，</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息发送成功; errQUEUE_FULL: 发送失败，队列已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      	            cosnt <span class="type">void</span>    *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                    BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息</span></span><br><span class="line"><span class="comment"> * @brief: 从一个队列中接收消息，并把接收的消息从队列中删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                         TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息</span></span><br><span class="line"><span class="comment"> * @brief: 从一个队列中接收消息，不删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 队列满时，等待队列空闲的最大超时时间，单位为系统节拍周期</span></span><br><span class="line"><span class="comment"> *					    若队列满且此参数为0，则立即返回；若为 portMAX_DELAY，将导致任务挂起(没有超时)</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                      TickType_t    xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中从一个队列中接收消息，并从队列中删除该消息</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 任务在向队列投递消息时，如果队列已满，则任务将阻塞在该队列上。</span></span><br><span class="line"><span class="comment"> *                                   如果导致一个任务解除阻塞，需将此设置成 pdTRUE，否则不变</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span>          *pvBuffer,</span></span><br><span class="line"><span class="params">                                BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取消息(中断中)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中从一个队列中接收消息，不删除</span></span><br><span class="line"><span class="comment"> * @param xQueue: 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer: 指针，指向接收到的要保存的数据</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 任务在向队列投递消息时，如果队列已满，则任务将阻塞在该队列上。</span></span><br><span class="line"><span class="comment"> *                                   如果导致一个任务解除阻塞，需将此设置成 pdTRUE，否则不变</span></span><br><span class="line"><span class="comment"> *                                   然后再中断退出前进行一次上下文切换，去执行比唤醒任务的优先级更高的任务</span></span><br><span class="line"><span class="comment"> *                                   注：从FreeRTOS V7.3.0 起，此参数作为可选项，可以设置成NULL</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 接收成功; pdFALSE: 接收失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>          *pvBuffer)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第16章-信号量"><a href="#第16章-信号量" class="headerlink" title="第16章 - 信号量 "></a><a href="#context.14">第16章 - 信号量</a><a name="section.14"> </a></h2><p>信号量控制块结构体与消息队列结构体是一样的，只是某些成员参数代表含义不同。</p>
<h3 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量 "></a><a href="#context.15">二值信号量</a><a name="section.15"> </a></h3><p>既可以用于临界资源访问，也可以用于同步功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建二值信号量</span></span><br><span class="line"><span class="comment"> * @note: 创建成功后为空，需要先调用 xSemaphoreGive()，归还后才能获取</span></span><br><span class="line"><span class="comment"> *        老式函数 vSemaphoreCreateBinary() 创建的二值信号量则不用，创建后为1，可以直接获取(take)</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄，原型为 void 类型指针; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>







<h5 id="二值信号量与互斥量的区别"><a href="#二值信号量与互斥量的区别" class="headerlink" title="二值信号量与互斥量的区别 "></a><a href="#context.16">二值信号量与互斥量的区别</a><a name="section.16"> </a></h5><p>互斥量具有继承机制，二值信号没有。</p>
<p>二值信号更适合应用于同步功能（任务与任务，任务和中断）</p>
<p>互斥量更偏向应用于临街资源访问</p>
<h3 id="互斥信号量量"><a href="#互斥信号量量" class="headerlink" title="互斥信号量量 "></a><a href="#context.17">互斥信号量量</a><a name="section.17"> </a></h3><p>为特殊的二值信号量，其特有的优先级继承机制使它更适用于简单互斥锁，也就是保护临界资源。</p>
<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量 "></a><a href="#context.18">计数信号量</a><a name="section.18"> </a></h3><p>用于计数，被任务取走时（take），计数减一；归还时（give），计数加一；为0不可用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建计数信号量</span></span><br><span class="line"><span class="comment"> * @brief: 创建一个计数信号量</span></span><br><span class="line"><span class="comment"> * @param uxMaxCount: 计数信号量的最大值，当达到这个值时，信号量不能再被释放(give)</span></span><br><span class="line"><span class="comment"> * @param uxInitialCount: 创建计数信号量的初始值(一般为uxMaxCount)</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">                                           UBaseType_t uxInitialCount)</span>;</span><br></pre></td></tr></table></figure>





<h3 id="递归信号量"><a href="#递归信号量" class="headerlink" title="递归信号量 "></a><a href="#context.19">递归信号量</a><a name="section.19"> </a></h3><p>是可以重复获取调用的信号量。</p>
<p>已经获取递归互斥量的任务可以重复获取该递归互斥量，该任务拥有递归信号量的所有权。</p>
<p>注意，成功获取几次就需归返几次，在此之前递归互斥量都处于无效状态，其他任务无法获取，只有持有递归信号量的任务才能获取与释放。</p>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数 "></a><a href="#context.20">其他函数</a><a name="section.20"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量删除</span></span><br><span class="line"><span class="comment"> * @brief: 删除一个信号量</span></span><br><span class="line"><span class="comment"> * @note: 如果有任务阻塞在该信号量上，不要删除</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xSemaphoreDelete</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量释放（归还）</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于释放信号量，实现为消息队列通用发送函数 xQueueGenericSend()</span></span><br><span class="line"><span class="comment"> * @note: 可用于释放 1.二值信号量 2.计数信号量 3.互斥信号量</span></span><br><span class="line"><span class="comment"> *        不能用于递归互斥量，由 xSemaphoreCreateRecursiveMutex() 创建</span></span><br><span class="line"><span class="comment"> *        不能在中断中使用！！！</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量释放（中断中归还）</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于释放信号量，带中断保护</span></span><br><span class="line"><span class="comment"> * @note: 可用于释放 1.二值信号量 2.计数信号量</span></span><br><span class="line"><span class="comment"> *        不能用于互斥信号量，因为互斥量不可在中断中使用，且互斥量的优先级继承只能在任务中起作用，在中断中毫无意义</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 因为调用此函数可能会唤醒阻塞在该信号量上的任务，</span></span><br><span class="line"><span class="comment"> *                                   如果被唤醒的优先级大于当前任务，则此为 pdTRUE，然后在中断退出前执行一次上下文切换；</span></span><br><span class="line"><span class="comment"> *                                   从 FreeRTOS V7.3.0 开始作为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: pdFALSE；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                 BaseType_t        *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量获取(拿走)</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于获取信号量，不带中断保护</span></span><br><span class="line"><span class="comment"> * @note: 可用于获取 1.二值信号量 2.计数信号量 3.互斥信号量</span></span><br><span class="line"><span class="comment"> *        不能用于递归互斥量，不能在中断中使用！！！</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 等待信号量可用的最大超时时间，单位为 tick（系统节拍周期），若为 portMAX_DELAY，则将一直阻塞</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                          TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号量获取(中断中拿走)</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，用于中断中获取信号量，不带阻塞机制（其实很少在中断中获取信号量）</span></span><br><span class="line"><span class="comment"> * @note: 可用于获取 1.二值信号量 2.计数信号量</span></span><br><span class="line"><span class="comment"> *        不能用于互斥信号量，因为互斥量不可在中断中使用，且互斥量的优先级继承只能在任务中起作用，在中断中毫无意义</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 因为调用此函数可能会唤醒阻塞在该信号量上的任务，</span></span><br><span class="line"><span class="comment"> *                                   如果被唤醒的优先级大于当前任务，则此为 pdTRUE，然后在中断退出前执行一次上下文切换；</span></span><br><span class="line"><span class="comment"> *                                   从 FreeRTOS V7.3.0 开始作为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY, 表信号量不可用;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                 <span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取当前计数信号的可用次数</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 计数信号量句柄，二值信号量句柄</span></span><br><span class="line"><span class="comment"> * @return 如果信号量是计数信号量，则返回信号量的当前计数值 &gt;=0</span></span><br><span class="line"><span class="comment"> *         如果信号量是二值信号量，则当信号量可用时，返回 1，当信号量不可用时，返回 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxSemaphoreGetCount</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"><span class="comment">/* demo</span></span><br><span class="line"><span class="comment">UBaseType_t semavalue = uxSemaphoreGetCount(xCountingSemaphore);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="第17章-互斥量"><a href="#第17章-互斥量" class="headerlink" title="第17章 - 互斥量 "></a><a href="#context.21">第17章 - 互斥量</a><a name="section.21"> </a></h2><p>互斥量又称互斥信号量，是一种特殊的二值信号。互斥量和信号量的不同之处在于，它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界区资源的独占式处理。</p>
<p><strong>注：只在任务中起作用，不能用于中断服务函数中！！！</strong></p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数 "></a><a href="#context.22">相关函数</a><a name="section.22"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数，创建一个互斥信号量</span></span><br><span class="line"><span class="comment"> * @return 成功: 互斥量句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建递归互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @return 成功: 互斥量句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateRecursiveMutex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除互斥量</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xSemaphoreDelete</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 互斥量获取</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                          TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归互斥量获取</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 只能获取由 xSemaphoreCreateRecursiveMutex 创建的互斥量</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 等待信号量可用的最大超时时间，单位为 tick（系统节拍周期），若为 portMAX_DELAY，则将一直阻塞</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeRecursive</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                                   TickType_t        xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 互斥量释放</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 详见 16章 其他函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归互斥量释放</span></span><br><span class="line"><span class="comment"> * @brief: 为宏函数</span></span><br><span class="line"><span class="comment"> * @note: 只能获取由 xSemaphoreCreateRecursiveMutex 创建的互斥量</span></span><br><span class="line"><span class="comment"> *        拿走几次都需要释放几次!</span></span><br><span class="line"><span class="comment"> * @param xSemaphore: 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: errQUEUE_EMPTY;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveRecursive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第18章-事件"><a href="#第18章-事件" class="headerlink" title="第18章 - 事件 "></a><a href="#context.23">第18章 - 事件</a><a name="section.23"> </a></h2><p>​		事件是一种实现任务间通信的机制，主要用于实现多任务间的同步，但<strong>事件通信只能是事件类型的通信，无数据传输</strong>。与信号量不同的是，事件可以实现一对多、多对多的同步，即一个任务可以等待多个事件的发生：1.可以是任意一个事件发生时唤醒任务进行事件处理；2.也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。</p>
<p>​		每一个事件组只需要很少的RAM空间来保存其状态。</p>
<p>​		如果宏 <code>configUSE_16_BIT_TICKS</code> 定义为1，则 <code>uxEventBits</code> 就是16位的，其中有8位来存储事件组。</p>
<p>​		否则， <code>uxEventBits</code> 就是32位的，其中有24位来存储事件组。</p>
<h3 id="事件函数"><a href="#事件函数" class="headerlink" title="事件函数 "></a><a href="#context.24">事件函数</a><a name="section.24"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件创建</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件删除</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件句柄</span></span><br><span class="line"><span class="comment"> * @return 成功: 句柄; 失败: NULL;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xEventGroupDelete</span><span class="params">(EventGroupHandle_t xEventGroup)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件置位</span></span><br><span class="line"><span class="comment"> * @brief: 置位事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToSet: 指定事件中的事件标志位。</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x08，则只置位位3,</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x09，则置位位3和位0</span></span><br><span class="line"><span class="comment"> * @return 返回调用 xEventGroupSetBits() 时事件组中的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup, </span></span><br><span class="line"><span class="params">                               <span class="type">const</span> EventBits_t  uxBitsToSet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件置位（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断函数中，置位事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToSet: 指定事件中的事件标志位。</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x08，则只置位位3,</span></span><br><span class="line"><span class="comment"> *                     如果设置 uxBitsToSet 为 0x09，则置位位3和位0</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用之前必须初始化为 pdFALSE;</span></span><br><span class="line"><span class="comment"> *                                   调用会给守护任务发送一个消息，如果守护任务的优先级高于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   此参会被置为 pdTRUE，然后再中断退出前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return pdTRUE: 消息成功发送给守护任务; pdFALSE: 发送失败;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup, </span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> EventBits_t  uxBitsToSet,</span></span><br><span class="line"><span class="params">                                     BaseType_t         *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 等待事件</span></span><br><span class="line"><span class="comment"> * @brief: 用于获取任务感兴趣的事件</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToWaitFor: 一个按位或的值，指定需要等待事件组中的哪些位 置1</span></span><br><span class="line"><span class="comment"> * @param xClearOnExit: pdTRUE: 当等待到满足任务唤醒的事件时，系统将清除由形参 uxBitsToWaitFor 指定的事件标志位</span></span><br><span class="line"><span class="comment"> *                      pdFALSE: 不会清除由形参 uxBitsToWaitFor 指定的事件标志位</span></span><br><span class="line"><span class="comment"> * @param xWaitForAllBits: pdTRUE: 指定的标志位都置位时（事件都存在），才满足唤醒条件</span></span><br><span class="line"><span class="comment"> *                         pdFALSE: 指定的标志位任一位 置位时（事件存在一个即可），满足唤醒条件</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 最大超时时间</span></span><br><span class="line"><span class="comment"> * @return 返回事件中的哪些事件标志位被置位，返回值很可能并不是用户指定的事件位，需要对返回值进行判断后再处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(<span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t        uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t         xClearOnExit,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t         xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                TickType_t               xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除事件组指定位</span></span><br><span class="line"><span class="comment"> * @brief: 清除事件组中指定的位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup: 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToClear: 指定事件组中的哪个位需要清除</span></span><br><span class="line"><span class="comment"> * @return 在还没有清除指定位之前事件的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t  uxBitsToClear)</span>;</span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBitsFromISR</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> EventBits_t  uxBitsToClear)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第19章-软件定时器"><a href="#第19章-软件定时器" class="headerlink" title="第19章 - 软件定时器 "></a><a href="#context.25">第19章 - 软件定时器</a><a name="section.25"> </a></h2><p>​		定时器，是指从指定的时刻开始，经过一段指定的时间后触发一个超时事件，用户可以自定义定时器的周期与频率。类似生活中的闹钟，我们可以设置闹钟什么时候响，还能设置响的次数，是响一次还是每天都响。</p>
<ol>
<li>硬件定时器<br>    是芯片本身提供定时功能，一般是由外部晶振为芯片提供输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后，芯片中断控制产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</li>
<li>软件定时器<br>    利用回调函数的方式处理中断。定时精度与系统时钟的周期有关。一般系统利用 <code>SysTick</code> 作为软件定时器的基础时钟，软件定时器的回调函数类似硬件的中断服务函数，所以回调函数也需要快进快出，并且不能有任何阻塞任务运行的情况。</li>
</ol>
<p><code>FreeRTOS</code> 软件定时器功能上支持：</p>
<ol>
<li>裁剪，可通过宏关闭软件定时器功能</li>
<li>软件定时器创建</li>
<li>软件定时器启动</li>
<li>软件定时器停止</li>
<li>软件定时器复位</li>
<li>软件定时器删除</li>
<li>单次模式</li>
<li>周期模式</li>
</ol>
<p><strong>注意：软件定时器的精度是无法和硬件定时器相比的，因为软件定时器过程中有可能被其他中断所打断，这是由于软件定时器的执行上下文是任务。</strong></p>
<h3 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数 "></a><a href="#context.26">定时器函数</a><a name="section.26"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器创建</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @note: 创建成功后是休眠的</span></span><br><span class="line"><span class="comment"> * @param pcTimerName: 定时器名称</span></span><br><span class="line"><span class="comment"> * @param xTimerPeriodInTicks: 软件定时器的周期，单位为系统节拍周期(即 tick)，</span></span><br><span class="line"><span class="comment"> *                             使用 pdMS_TO_TICKS()可以把时间单位从ms转换为系统节拍周期</span></span><br><span class="line"><span class="comment"> * @param uxAutoReload: pdTRUE: 周期模式; pdFALSE: 单次模式，运行一次后就进去休眠态</span></span><br><span class="line"><span class="comment"> * @param pvTimerID: 软件定时器ID，数字形式。该ID典型的用法是当一个回调函数分配给一个或多个软件定时器时，</span></span><br><span class="line"><span class="comment"> *                   在回调函数中根据 ID 号来处理不同的软件定时器</span></span><br><span class="line"><span class="comment"> * @param pxCallbackFunction: 软件定时器的回调函数，时间到时会调用这个函数</span></span><br><span class="line"><span class="comment"> * @return 成功: 定时器句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> TickType_t   xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> UBaseType_t  uxAutoReload,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span> * <span class="type">const</span>       pvTimerID,</span></span><br><span class="line"><span class="params">                           TimerCallbackFunction_t pxCallbackFunction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器启动</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @note: 宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 用户指定超时阻塞时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                      如果该值不为0，则调用该函数的任务将被锁定在阻塞态，阻塞时间为用户指定的时间，</span></span><br><span class="line"><span class="comment"> *                      直到指定的时间过去后，系统才会将启动软件定时器的命令发送出去。</span></span><br><span class="line"><span class="comment"> *                      如果在 FreeRTOS 调度器开启之前调用此函数，此参将不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: 定时器句柄; 失败: NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">(TimerHandle_t    xTimer,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器启动（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中启动一个软件定时器</span></span><br><span class="line"><span class="comment"> * @note: 宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 定时器守护任务的大部分时间都在阻塞态等待定时器命令队列的命令。</span></span><br><span class="line"><span class="comment"> *                                   调用此函数将会向定时器的命令队列发送一个启动命令，这很可能会将定时器从阻塞态移除。</span></span><br><span class="line"><span class="comment"> *                                   如果调用此函数让定时器任务脱离阻塞态，且定时器守护任务的优先级大于等于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   那么此参数的值会在函数内部设置为 pdTRUE，然后在中断退出之前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStartFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                              BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器停止</span></span><br><span class="line"><span class="comment"> * @brief: 停止一个软件定时器，让其进入休眠态</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 用户指定的超时时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                    如果在 FreeRTOS 调度器开启之前调用此函数，则此参数不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                      TickType_t    xBlockTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器停止(中断)</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中停止一个软件定时器，让其进入休眠态</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 定时器守护任务的大部分时间都在阻塞态等待定时器命令队列的命令。</span></span><br><span class="line"><span class="comment"> *                                   调用此函数将会向定时器的命令队列发送一个启动命令，这很可能会将定时器从阻塞态移除。</span></span><br><span class="line"><span class="comment"> *                                   如果调用此函数让定时器任务脱离阻塞态，且定时器守护任务的优先级大于等于当前被中断的任务的优先级，</span></span><br><span class="line"><span class="comment"> *                                   那么此参数的值会在函数内部设置为 pdTRUE，然后在中断退出之前执行一次上下文切换</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStopFromISR</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                             BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 软件定时器删除</span></span><br><span class="line"><span class="comment"> * @brief: 删除一个已经被创建成功的软件定时器</span></span><br><span class="line"><span class="comment"> * @note: 为宏函数</span></span><br><span class="line"><span class="comment"> * @param xTimer: 定时器句柄</span></span><br><span class="line"><span class="comment"> * @param xBlockTime: 用户指定的超时时间，单位为系统节拍周期（即tick）</span></span><br><span class="line"><span class="comment"> *                    如果在 FreeRTOS 调度器开启之前调用此函数，则此参数不起作用</span></span><br><span class="line"><span class="comment"> * @return 成功: pdPASS; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">(TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                        TickType_t    xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第20章-任务通知"><a href="#第20章-任务通知" class="headerlink" title="第20章 - 任务通知 "></a><a href="#context.27">第20章 - 任务通知</a><a name="section.27"> </a></h2><p>​		<code>FreeRTOS</code> 从 <code>V8.2.0</code> 版本开始提供任务通知功能，每个任务都有一个32位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列（可以保存一个32位整数或指针值）。</p>
<p>​		使用任务通知比通过信号量等ICP通信方式接触阻塞的任务速度要快45%，并且更加省RAM内存空间（使用GCC编译器，-o2优化级别），任务通知的使用无需创建队列。</p>
<p><code>FreeRTOS</code> 提供以下几种方式发送通知给任务：</p>
<ol>
<li>如果有通知未读，则不覆盖通知值</li>
<li>直接覆盖通知值</li>
<li>设置通知值的一个或者多个位，可以当作事件组来使用</li>
<li>递增通知值，可以当作计数信号量使用</li>
</ol>
<p>注意有以下限制：</p>
<ol>
<li>只能有一个任务接收任务通知消息，因为必须指定接受通知的任务</li>
<li>只有等待通知的任务可以被阻塞，发送通知的任务在任何情况下都不会因为发送失败而进入阻塞态</li>
</ol>
<h3 id="任务通知函数"><a href="#任务通知函数" class="headerlink" title="任务通知函数 "></a><a href="#context.28">任务通知函数</a><a name="section.28"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于在任务中向指定任务发送任务通知，并更新对方的任务通知值（加1操作）</span></span><br><span class="line"><span class="comment"> * @note: 为宏函数，用于二值信号量和计数信号量</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄，并让其自身的任务通知值加一</span></span><br><span class="line"><span class="comment"> * @return 总是返回 pdPASS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">(TaskHandle_t xTaskToNotify)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中，用于在任务中向指定任务发送任务通知，并更新对方的任务通知值（加1操作）</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄，并让其自身的任务通知值加一</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskNotifyGiveFromISR</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                            BaseType_t   *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 向指定的任务发送一个任务通知，带有通知值并且用户可以指定通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @note: 指定一个通知值，和此通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见下表</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(TaskHandle_t  xTaskToNotify,</span></span><br><span class="line"><span class="params">                       <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                       eNotifyAction eAction)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>eAction取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>eNoAction</td>
<td>对象任务接受任务通知，但是任务自身的任务通知值不更新，即形参 ulValue没有用</td>
</tr>
<tr>
<td>eSetBits</td>
<td>对象任务接收任务通知，同时任务自身的任务通知值与ulValue按位或。<br />如果 ulValue 为 0x01，那么任务的通知值的位0将被置1</td>
</tr>
<tr>
<td>eIncrement</td>
<td>对象任务接受任务通知。任务自身的任务通知值加1，即形参 ulValue 没用，<br />这时调用 xTaskNotify 相当于调用 xTaskNotifyGive</td>
</tr>
<tr>
<td>eSetValueWithOverwrite</td>
<td>对象任务接收任务通知，且任务自身的任务通知值会无条件的被设置为 ulValue</td>
</tr>
<tr>
<td>eSetValueWithoutOverwrite</td>
<td>对象任务接收任务通知，且对象任务没有通知值，那么通知值就会被设置为 ulValue<br />若上次通知值没有被取走，则不更新，同时返回 pdFALSE</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 在中断中向指定的任务发送一个任务通知</span></span><br><span class="line"><span class="comment"> * @note: 指定一个通知值，和此通知值的发送方式</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">(TaskHandle_t  xTaskToNotify,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                              eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                              BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 向指定的任务发送一个任务通知，并返回对象任务的上一个通知值</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pulPreviousNotifyValue: 对象任务的上一个任务通知值，如果为 NULL ，则不需要回传，这时等价于 xTaskNotify</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                              eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                              <span class="type">uint32_t</span>      *pulPreviousNotifyValue)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 发送任务通知（中断）</span></span><br><span class="line"><span class="comment"> * @brief: 中断中向指定的任务发送一个任务通知，并返回对象任务的上一个通知值</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify: 接受通知的任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue: 用于更新接受任务通知的 任务通知值，具体如何更新由形参 eAction 决定</span></span><br><span class="line"><span class="comment"> * @param eAction: 任务通知值的更新方式，详见上表</span></span><br><span class="line"><span class="comment"> * @param pulPreviousNotifyValue: 对象任务的上一个任务通知值，如果为 NULL ，则不需要回传，这时等价于 xTaskNotify</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken: 使用前必须被初始化为 pdFALSE</span></span><br><span class="line"><span class="comment"> *                                   当调用该函数发送一个任务通知时，目标任务接收到通知后将从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment"> *                                   并且如果其优先级比当前运行的任务的优先级高，那么此参会被设置为 pdTRUE</span></span><br><span class="line"><span class="comment"> *                                   然后在中断退出前执行一次上下文切换，为可选参数，可以为 NULL</span></span><br><span class="line"><span class="comment"> * @return 参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，又接收到了一个通知，</span></span><br><span class="line"><span class="comment"> *         则这次通知值未能更新并返回 pdFALSE;</span></span><br><span class="line"><span class="comment"> *         其他情况均返回 pdPASS;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryFromISR</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span>      ulValue,</span></span><br><span class="line"><span class="params">                                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                      <span class="type">uint32_t</span>      *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                                      BaseType_t    *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于获取一个任务通知，如获取二值信号量、计数信号量类型的任务通知</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param xClearCountOnExit: 为 pdFALSE 时，此函数退出前，将任务的通知值减1，可以用来实现计数信号量</span></span><br><span class="line"><span class="comment"> *                           为 pdTRUE 时，退出前将任务通知值清0，可用来实现二值信号量</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 超时时间，单位为系统节拍周期，宏 pdMS_TO_TICKS 用于将毫秒转化为系统节拍数</span></span><br><span class="line"><span class="comment"> * @return 在任务通知值减1或者清零之前，返回任务的当前通知值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">(BaseType_t xClearCountOnExit,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全功能等待任务通知</span></span><br><span class="line"><span class="comment"> * @brief: 用于等待一个任务通知，并带有超时等待</span></span><br><span class="line"><span class="comment"> * @note: </span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnEntry: 表在使用通知前，将任务通知值的哪些位清零，实现是按位取反后位与</span></span><br><span class="line"><span class="comment"> *                              如果设置为 0x01，那么在进入函数前，位1会被清零</span></span><br><span class="line"><span class="comment"> *                              如果设置为 0xFFFFFFFF（ULONG_MAX），那么在进入函数前，所有位清零，表清空通知值</span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnExit: 表在函数退出前，决定任务接收到的通知值的哪些位会被清零，实现同上</span></span><br><span class="line"><span class="comment"> *                             在清零前，接收到的任务通知值会先保存到形参 *pulNotificationValue 中</span></span><br><span class="line"><span class="comment"> *                             比如为 0x03，那么在退出前，接收到的任务通知值的位0-1会被清零</span></span><br><span class="line"><span class="comment"> *                             如果设置为 0xFFFFFFFF（ULONG_MAX），那么所有位清零，表清空通知值</span></span><br><span class="line"><span class="comment"> * @param pulNotificationValue: 用于保存接收到的任务通知值，不用则设为 NULL</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait: 超时时间，单位为系统节拍周期，宏 pdMS_TO_TICKS 用于将毫秒转化为系统节拍数</span></span><br><span class="line"><span class="comment"> * @return 成功: pdTRUE; 失败: pdFALSE;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(<span class="type">uint32_t</span>   ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span>   ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span>   *pulNotificationValue,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>





<h2 id="第21章-内存管理"><a href="#第21章-内存管理" class="headerlink" title="第21章 - 内存管理 "></a><a href="#context.29">第21章 - 内存管理</a><a name="section.29"> </a></h2><p>​		在计算机系统中，变量、中间数据一般存放在系统存储空间中，只有在实际使用时才将它们从存储空间调入中央处理器内部进行运算。通常存储空间分为两种：1.内部存储空间（RAM）；2.外部存储空间</p>
<p>​		内部存储空间访问速度比较快，能够按照变量地址随机地访问。外部存储空间内所保存的内容相对来说比较固定，即使掉电后数据也不会丢失，可以把它理解为计算机的硬盘。</p>
<p>​		一些可靠性要求非常高的系统应该选择使用静态分配；普通业务系统可以使用动态分配，来提高内存的使用率。</p>
<p><strong>注意：嵌入式实时操作系统中，一般不调用计算机中的 <code>malloc()</code> 和 <code>free()</code></strong></p>
<p>原因如下：</p>
<ol>
<li>这些函数在小型嵌入式系统中并不总是可用的，小型嵌入式设备中的RAM不足</li>
<li>实现可能需要占用相当大的一块代码空间</li>
<li>几乎都不是安全的</li>
<li>不是确定的，每次调用这些函数执行的时间可能都不一样</li>
<li>有可能产生碎片</li>
<li>会使链接器配置的更复杂</li>
<li>如果允许堆空间的生长方向覆盖其他变量占据的内存，那么它们会成为 debug 的灾难</li>
</ol>
<h3 id="内存管理接口"><a href="#内存管理接口" class="headerlink" title="内存管理接口 "></a><a href="#context.30">内存管理接口</a><a name="section.30"> </a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvPortMalloc</span><span class="params">(<span class="type">size_t</span> xSize)</span>;              <span class="comment">///&lt; 内存申请函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">(<span class="type">void</span> *pv)</span>;                      <span class="comment">///&lt; 内存释放函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortInitialiseBlocks</span><span class="params">(<span class="type">void</span>)</span>;              <span class="comment">///&lt; 初始化内存堆函数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">(<span class="type">void</span>)</span>;             <span class="comment">///&lt; 获取当前未分配的内存堆大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">///&lt; 获取未分配的内存堆历史最小值</span></span><br></pre></td></tr></table></figure>



<p><code>FreeRTOS</code> 的 <code>V 9.0.0</code> 版本提供了5中内存管理算法：</p>
<ol>
<li><p><code>heap_1.c</code></p>
<p>最简单的一个，只能申请，不能释放，申请时间是常量</p>
<p>特点：</p>
<p>（1）用于从不删除任务、队列、信号量、互斥量等的应用程序（实际上大多数使用FreeRTOS的应用程序都符合这个条件）</p>
<p>（2）函数的执行时间是确定的，并且不会产生内存碎片</p>
</li>
<li><p><code>heap_2.c</code><br>采用一种最佳匹配算法<br>特点：<br>（1）可以用于那些反复删除任务、队列、信号量等内核对象且不担心内存碎片的应用程序<br>（2）如果我们的应用程序中的队列、任务、信号量等的顺序不可预测，也有可能导致内存碎片<br>（3）具有不确定性，但是效率比标准C库中的 <code>malloc()</code> 函数高得多<br>（4）不能用于内存分配和释放是随机大小的应用程序</p>
</li>
<li><p><code>heap_3.c</code></p>
<p>简单的封装了标准C库的 <code>malloc()</code> 和 <code>free()</code> ，但具有保护功能，即操作内存前挂起调度器，完成后再恢复调度器</p>
<p>特点：</p>
<p>（1）需要链接器设置一个堆，<code>malloc()</code> 和 <code>free()</code> 由编译器提供</p>
<p>（2）具有不确定性</p>
<p>（3）很可能增大 RTOS 内核的代码大小</p>
</li>
<li><p><code>heap_4.c</code></p>
<p>与2一样，均采用最佳匹配算法来实现动态的内存分配，不一样的是此方法包含了一种合并算法，能把相邻的空闲内存块合并成一个更大的块，减少内存碎片<br>特点：</p>
<p>（1）可用于重复删除任务、队列、信号量、互斥量等的应用程序</p>
<p>（2）可用于分配和释放随机字节内存的应用程序，但并不像2那样产生严重的内存碎片</p>
<p>（3）具有不确定性，但是效率比标准C库中的 <code>malloc()</code> 函数高得多</p>
</li>
<li><p><code>heap_5.c</code><br>和4一样，但允许内存堆跨越多个非连续的内存区，也就是允许在不连续的内存堆中实现内存分配，比如在片内RAM中定义一个内存堆，还可以在外部SDRAM中再定义一个或多个内存堆，这些内存都归系统管理</p>
</li>
</ol>
<h2 id="第22章-中断管理"><a href="#第22章-中断管理" class="headerlink" title="第22章 - 中断管理 "></a><a href="#context.31">第22章 - 中断管理</a><a name="section.31"> </a></h2><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类 "></a><a href="#context.32">异常分类</a><a name="section.32"> </a></h3><ol>
<li><p>同步异常</p>
<p>由内部事件（像处理器指令运行产生的事件）引起的异常称为同步异常，例如，造成被零除的算术运算引发一个异常。</p>
</li>
<li><p>异步异常</p>
<p>主要指由外部异常源产生的异常，事件来源是外部硬件装置。例如，按下按键。</p>
</li>
</ol>
<p>区别：</p>
<p>同步异常触发后，系统必须立刻进行处理而不能依然执行原有的程序指令步骤</p>
<p>异步异常触发后，可以延缓处理甚至是忽略</p>
<p><strong>中断属于异步异常</strong></p>
<p><code>FreeRTOS</code> 的中断管理支持：</p>
<ol>
<li>开&#x2F;关中断</li>
<li>恢复中断</li>
<li>中断屏蔽</li>
<li>可选择系统管理的中断优先级</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断 "></a><a href="#context.33">中断</a><a name="section.33"> </a></h3><p>与中断相关的硬件可以划分为3类：外设、中断控制器、CPU本身</p>
<ol>
<li><p>外设</p>
<p>当外设需要请求CPU时，产生一个中断信号，该信号连接至中断控制器</p>
</li>
<li><p>中断控制器</p>
<p>是CPU众多外设中的一个，一方面接收其他外设中断信号的输入，另一方面会发出中断信号给CPU。可以通过对中断控制器编程实现对中断源的优先级、触发方式、打开和关闭源等设置操作。在 <code>Cortex-M</code> 系列控制器中，常用的中断控制器是 <code>NVIC (Nested Vectored Interrupt Controller)</code> 内嵌向量中断控制器</p>
</li>
<li><p>CPU</p>
<p>CPU 会响应中断源的请求、中断当前正在执行的任务，转而执行中断处理程序。NVIC最多支持240个中断，每个中断最多有256个优先级</p>
</li>
</ol>
<p><strong>中断管理的运作机制</strong></p>
<ol>
<li>保存当前处理器状态信息</li>
<li>载入异常或中断处理函数到PC寄存器</li>
<li>把控制权转交给处理函数并开始执行</li>
<li>当处理函数执行完成时，恢复处理器状态信息</li>
<li>从异常或中断中返回到前一个程序执行点</li>
</ol>
<p><strong>注：FreeRTOS允许中断嵌套！！</strong></p>
<h2 id="第23章-CPU利用率"><a href="#第23章-CPU利用率" class="headerlink" title="第23章 - CPU利用率 "></a><a href="#context.34">第23章 - CPU利用率</a><a name="section.34"> </a></h2><h2 id="FreeRTOS操作系统调度方式有哪些？"><a href="#FreeRTOS操作系统调度方式有哪些？" class="headerlink" title="FreeRTOS操作系统调度方式有哪些？ "></a><a href="#context.35">FreeRTOS操作系统调度方式有哪些？</a><a name="section.35"> </a></h2><p>FreeRTOS操作系统支持三种调度方式：</p>
<ol>
<li>抢占式调度（Pre-emptive）</li>
<li>时间片调度（time slice）</li>
<li>合作式调度（co-operative）</li>
</ol>
<p>实际应用主要是抢占式调度和时间片调度结合的调度方法，合作式调度用到的很少。</p>
]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣TOP100</title>
    <url>/2023/09/04/LeetCodeTop100/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="力扣TOP100"><a href="#力扣TOP100" class="headerlink" title="力扣TOP100"></a>力扣TOP100</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">哈希</a><a name="context.1"> </a></li>
<li><a href="#section.2">双指针</a><a name="context.2"> </a></li>
<li><a href="#section.3">滑动窗口</a><a name="context.3"> </a></li>
<li><a href="#section.4">子串</a><a name="context.4"> </a></li>
<li><a href="#section.5">数组</a><a name="context.5"> </a></li>
<li><a href="#section.6">矩阵</a><a name="context.6"> </a></li>
<li><a href="#section.7">链表</a><a name="context.7"> </a></li>
<li><a href="#section.8">二叉树</a><a name="context.8"> </a></li>
<li><a href="#section.9">回溯</a><a name="context.9"> </a></li>
<li><a href="#section.10">二分</a><a name="context.10"> </a></li>
<li><a href="#section.11">栈</a><a name="context.11"> </a></li>
<li><a href="#section.12">堆</a><a name="context.12"> </a></li>
<li><a href="#section.13">贪心</a><a name="context.13"> </a></li>
<li><a href="#section.14">动规</a><a name="context.14"> </a></li>
<li><a href="#section.15">技巧</a><a name="context.15"> </a><ul>
<li><a href="#section.16">向上取整</a><a name="context.16"> </a></li>
<li><a href="#section.17">向下取整</a><a name="context.17"> </a></li>
<li><a href="#section.18">四舍五入</a><a name="context.18"> </a></li>
<li><a href="#section.19">保留小数</a><a name="context.19"> </a></li>
</ul>
</li>
</ul>
<hr>
<p><a href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希 "></a><a href="#context.1">哈希</a><a name="section.1"> </a></h2><p><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment">你可以按任意顺序返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment">输出：[1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,3], target = 6</span></span><br><span class="line"><span class="comment">输出：[0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">只会存在一个有效答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (it != um.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = &#123;it-&gt;second, i&#125;;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                um[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: strs = [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">输出: [[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= strs.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= strs[i].length &lt;= 100</span></span><br><span class="line"><span class="comment">strs[i] 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!strs.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> str: strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">string <span class="title">s</span><span class="params">(<span class="number">26</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c: str)</span><br><span class="line">                    ++s[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                </span><br><span class="line">                um[s].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it: um)</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [100,4,200,1,3,2]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!us.<span class="built_in">count</span>(num + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> n = num - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (us.<span class="built_in">count</span>(n))</span><br><span class="line">                    --n;</span><br><span class="line">                </span><br><span class="line">                ret = <span class="built_in">max</span>(ret, num - n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针 "></a><a href="#context.2">双指针</a><a name="section.2"> </a></h2><p><a href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0,1,0,3,12]</span></span><br><span class="line"><span class="comment">输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: nums = [0]</span></span><br><span class="line"><span class="comment">输出: [0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; nums.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[slow++], nums[fast]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202309052152274.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment">返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment">说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：[1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="comment">输出：49 </span></span><br><span class="line"><span class="comment">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [1,1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">2 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                len = right - left;</span><br><span class="line">                ret = height[left] &gt; height[right]</span><br><span class="line">                      ? <span class="built_in">max</span>(ret, len * height[right--])</span><br><span class="line">                      : <span class="built_in">max</span>(ret, len * height[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked">15. 3Sum - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,1,1]</span></span><br><span class="line"><span class="comment">输出：[]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和不为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [0,0,0]</span></span><br><span class="line"><span class="comment">输出：[[0,0,0]]</span></span><br><span class="line"><span class="comment">解释：唯一可能的三元组和为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 &lt;= nums.length &lt;= 3000</span></span><br><span class="line"><span class="comment">-105 &lt;= nums[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                    --r;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                    ++l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[l++], nums[r--]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l - <span class="number">1</span>] == nums[l]) ++l;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]) --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/image-20230808221849426.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：height = [4,2,0,3,2,5]</span></span><br><span class="line"><span class="comment">输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == height.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">0 &lt;= height[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, hl = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>, hr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                hl = <span class="built_in">max</span>(hl, height[left]);</span><br><span class="line">                hr = <span class="built_in">max</span>(hr, height[right]);</span><br><span class="line">                ret += height[left] &gt; height[right] ? hr - height[right--] : hl - height[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口 "></a><a href="#context.3">滑动窗口</a><a name="section.3"> </a></h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment">输出: 3 </span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment">输出: 1</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="comment">输出: 3</span></span><br><span class="line"><span class="comment">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">0 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">s 由英文字母、数字、符号和空格组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</span></span><br><span class="line"><span class="comment">异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">输出: [0,6]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span></span><br><span class="line"><span class="comment">输出: [0,1,2]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length, p.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">s 和 p 仅包含小写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tar</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: p)</span><br><span class="line">            ++tar[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">        &#123;</span><br><span class="line">            --tar[s[fast] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">while</span> (tar[s[fast] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                ++tar[s[slow++] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast - slow + <span class="number">1</span> == p.<span class="built_in">size</span>())</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="子串"><a href="#子串" class="headerlink" title="子串 "></a><a href="#context.4">子串</a><a name="section.4"> </a></h2><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,1,1], k = 2</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3], k = 3</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">-1000 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">-107 &lt;= k &lt;= 107</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 前缀 + 哈希 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            um[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                pre += n;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(pre - k))</span><br><span class="line">                    ret += um[pre - k];</span><br><span class="line"></span><br><span class="line">                ++um[pre];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment">返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span><br><span class="line"><span class="comment">输出：[3,3,5,5,6,7]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">滑动窗口的位置                最大值</span></span><br><span class="line"><span class="comment">---------------               -----</span></span><br><span class="line"><span class="comment">[1  3  -1] -3  5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1 [3  -1  -3] 5  3  6  7       3</span></span><br><span class="line"><span class="comment"> 1  3 [-1  -3  5] 3  6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1 [-3  5  3] 6  7       5</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3 [5  3  6] 7       6</span></span><br><span class="line"><span class="comment"> 1  3  -1  -3  5 [3  6  7]      7</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输入：nums = [1], k = 1</span></span><br><span class="line"><span class="comment">输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= nums.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 采用堆结构 priority_queue</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">                <span class="keyword">while</span> (pq.<span class="built_in">top</span>().second &lt;= i - k)</span><br><span class="line">                    pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。在最坏情况下，数组 nums 中的元素单调递增，那么最终优先队列中包含了所有元素，没有元素被移除。由于将一个元素放入优先队列的时间复杂度为 O(log⁡n)，因此总时间复杂度为 O(nlog⁡n)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">空间复杂度：O(n)，即为优先队列需要使用的空间。这里所有的空间复杂度分析都不考虑返回的答案需要的 O(n) 空间，只计算额外的空间使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 单调栈 deque</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[dq.<span class="built_in">back</span>()])</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">                dq.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= i - k)</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                </span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)，其中 n 是数组 nums 的长度。每一个下标恰好被放入队列一次，并且最多被弹出队列一次，因此时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment">空间复杂度：O(k)，与方法一不同的是，在方法二中我们使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素，因此队列使用的空间为 O(k)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment">如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;BANC&quot;</span></span><br><span class="line"><span class="comment">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：s = &quot;a&quot;, t = &quot;a&quot;</span></span><br><span class="line"><span class="comment">输出：&quot;a&quot;</span></span><br><span class="line"><span class="comment">解释：整个字符串 s 是最小覆盖子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span></span><br><span class="line"><span class="comment">输出: &quot;&quot;</span></span><br><span class="line"><span class="comment">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span></span><br><span class="line"><span class="comment">因此没有符合条件的子字符串，返回空字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == s.length</span></span><br><span class="line"><span class="comment">n == t.length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 105</span></span><br><span class="line"><span class="comment">s 和 t 由英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt;= t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: t)</span><br><span class="line">            &#123;</span><br><span class="line">                --um[c];</span><br><span class="line">                ++need;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>, fast, start;</span><br><span class="line">            <span class="type">int</span> min_size = INT_MAX;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">while</span> (slow &lt; s.<span class="built_in">size</span>() &amp;&amp; !um.<span class="built_in">count</span>(s[slow])) ++slow;</span><br><span class="line">            <span class="keyword">for</span> (fast = slow; fast &lt; s.<span class="built_in">size</span>(); ++fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (um.<span class="built_in">count</span>(s[fast]))</span><br><span class="line">                &#123;</span><br><span class="line">                    need -= ++um[s[fast]] &lt;= <span class="number">0</span>;</span><br><span class="line">                    dq.<span class="built_in">emplace_back</span>(fast);</span><br><span class="line">                    <span class="keyword">while</span> (need == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; min_size)</span><br><span class="line">                        &#123;</span><br><span class="line">                            start = slow;</span><br><span class="line">                            min_size = fast - slow + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (--um[s[slow]] &lt; <span class="number">0</span>)</span><br><span class="line">                            ++need;</span><br><span class="line"></span><br><span class="line">                        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                        slow = dq.<span class="built_in">front</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min_size != INT_MAX)</span><br><span class="line">                ret = s.<span class="built_in">substr</span>(start, min_size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组 "></a><a href="#context.5">数组</a><a name="section.5"> </a></h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment">子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">输出：6</span></span><br><span class="line"><span class="comment">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [5,4,-1,7,8]</span></span><br><span class="line"><span class="comment">输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 动规（无后效性）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">                pre = <span class="built_in">max</span>(pre + num, num);</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/first-missing-positive/description/">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [1,2,0]</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [3,4,-1,1]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [7,8,9,11,12]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 5 * 105</span></span><br><span class="line"><span class="comment">-231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 在元素组上哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    nums[i] = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= nums.<span class="built_in">size</span>()) <span class="comment">///&lt; num [1, N]</span></span><br><span class="line">                    nums[num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵 "></a><a href="#context.6">矩阵</a><a name="section.6"> </a></h2><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked">54. 螺旋矩阵 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></span><br><span class="line"><span class="comment">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 10</span></span><br><span class="line"><span class="comment">-100 &lt;= matrix[i][j] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) ret.<span class="built_in">emplace_back</span>(matrix[u][i]);</span><br><span class="line">                <span class="keyword">if</span> (++u &gt; d)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;= d; ++i) ret.<span class="built_in">emplace_back</span>(matrix[i][r]);</span><br><span class="line">                <span class="keyword">if</span> (--r &lt; l)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; --i) ret.<span class="built_in">emplace_back</span>(matrix[d][i]);</span><br><span class="line">                <span class="keyword">if</span> (--d &lt; u)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = d; i &gt;= u; --i) ret.<span class="built_in">emplace_back</span>(matrix[i][l]);</span><br><span class="line">                <span class="keyword">if</span> (++l &gt; r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment">你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">输出：[[7,4,1],[8,5,2],[9,6,3]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span></span><br><span class="line"><span class="comment">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == matrix.length == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">-1000 &lt;= matrix[i][j] &lt;= 1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="number">0</span>, d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = u; i &lt; r; ++i, ++j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][r]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = r; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[d][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = l, j = d; i &lt; r; ++i, --j)</span><br><span class="line">                    <span class="built_in">swap</span>(matrix[u][i], matrix[j][l]);</span><br><span class="line"></span><br><span class="line">                ++u;</span><br><span class="line">                --d;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</span></span><br><span class="line"><span class="comment">每行的元素从左到右升序排列。</span></span><br><span class="line"><span class="comment">每列的元素从上到下升序排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= n, m &lt;= 300</span></span><br><span class="line"><span class="comment">-109 &lt;= matrix[i][j] &lt;= 109</span></span><br><span class="line"><span class="comment">每行的所有元素从左到右升序排列</span></span><br><span class="line"><span class="comment">每列的所有元素从上到下升序排列</span></span><br><span class="line"><span class="comment">-109 &lt;= target &lt;= 109</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 矩阵向左旋转45度，转换为BST树(二叉搜索树)，左树小，右树大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!matrix.<span class="built_in">empty</span>() &amp;&amp; matrix[<span class="number">0</span>][<span class="number">0</span>] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">///&lt; 列</span></span><br><span class="line">            <span class="type">int</span> row = <span class="number">0</span>;  <span class="comment">///&lt; 行</span></span><br><span class="line">            <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt; matrix.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">                    ++row;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target)</span><br><span class="line">                    --col;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表 "></a><a href="#context.7">链表</a><a name="section.7"> </a></h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listA 中节点数目为 m</span></span><br><span class="line"><span class="comment">listB 中节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">1 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= skipA &lt;= m</span></span><br><span class="line"><span class="comment">0 &lt;= skipB &lt;= n</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 没有交点，intersectVal 为 0</span></span><br><span class="line"><span class="comment">如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 双指针，两条路各走一遍</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA &amp;&amp; headB)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pa = headA, *pb = headB;</span><br><span class="line">            <span class="keyword">while</span> (pa != pb)</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa == <span class="literal">nullptr</span> ? headB : pa-&gt;next;</span><br><span class="line">                pb = pb == <span class="literal">nullptr</span> ? headA : pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = pa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">206. 反转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：head = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">输出：[5,4,3,2,1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 三指针赋值 pre cur next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span>  (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中节点数目在范围[1, 105] 内</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 存vector转用双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head != <span class="literal">nullptr</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] == arr[r])</span><br><span class="line">            &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ret = l &gt;= r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针 + 反转链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Reverse</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已知非空，故不做判断</span></span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>, *next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = ret;</span><br><span class="line">            ret = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode *temp = fast-&gt;next ? fast-&gt;next : fast;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == temp-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == temp-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ret = temp == <span class="literal">nullptr</span>;</span><br><span class="line">                slow-&gt;next = <span class="built_in">Reverse</span>(slow-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你能用 O(1)（即，常量）内存解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *fast = head-&gt;next;</span><br><span class="line">            ListNode *slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow &amp;&amp; fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = fast != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment">不允许修改 链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你是否可以使用 O(1) 空间解决此题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!us.<span class="built_in">count</span>(head))</span><br><span class="line">                &#123;</span><br><span class="line">                    us.<span class="built_in">emplace</span>(head);</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret = head;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (head != fast)</span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两个链表的节点数目范围是 [0, 50]</span></span><br><span class="line"><span class="comment">-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">l1 和 l2 均按 非递减顺序 排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力(略)</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 循环迭代 + 智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_ptr&lt;ListNode&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> ListNode())</span></span>;</span><br><span class="line">        ListNode *pre = ptr.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">while</span> (list1 &amp;&amp; list2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = list1 ? list1 : list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked">2. 两数相加 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked">25. K 个一组翻转链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span></span><br><span class="line"><span class="comment">k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"><span class="comment">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中的节点数目为 n</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 直接模拟，注意细节就好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">ReverseNode</span><span class="params">(ListNode *begin, ListNode *end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre = end, *next;</span><br><span class="line">        <span class="keyword">do</span>  <span class="comment">///&lt; begin 已在外部判断非空</span></span><br><span class="line">        &#123;</span><br><span class="line">            next = begin-&gt;next;</span><br><span class="line">            begin-&gt;next = pre;</span><br><span class="line">            pre = begin;</span><br><span class="line">            begin = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (begin != end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *ret = head;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">            ListNode *begin = head, *end = begin;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; k &amp;&amp; end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = end-&gt;next;</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n == k)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = begin;</span><br><span class="line">                ret = <span class="built_in">ReverseNode</span>(begin, end);</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    n = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (n &lt; k &amp;&amp; end)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end = end-&gt;next;</span><br><span class="line">                        ++n;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (n == k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin = begin-&gt;next;</span><br><span class="line">                        pre-&gt;next = <span class="built_in">ReverseNode</span>(begin, end);</span><br><span class="line">                        pre = begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked">138. 复制带随机指针的链表 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked">148. 排序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表中节点的数目在范围 [0, 5 * 104] 内</span></span><br><span class="line"><span class="comment">-105 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 自底向上的 归并排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">MergeNode</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">ph</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* temp = &amp;ph, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 &amp;&amp; temp2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp1)</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp2)</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ph.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">ph</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (head &amp;&amp; head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125; <span class="keyword">while</span> (head);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode *pre = &amp;ph, *cur = ph.next;</span><br><span class="line">                <span class="keyword">while</span> (cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    ListNode *head1 = cur;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; cur-&gt;next; ++j)</span><br><span class="line">                        cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">                    ListNode *head2 = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">///&lt; head1 尾部与 head2 头部断开连接</span></span><br><span class="line">                    cur = head2;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; cur &amp;&amp; cur-&gt;next; ++j)</span><br><span class="line">                        cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">                    ListNode *next = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">if</span> (cur)</span><br><span class="line">                    &#123;</span><br><span class="line">                        next = cur-&gt;next;</span><br><span class="line">                        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pre-&gt;next = <span class="built_in">MergeNode</span>(head1, head2);</span><br><span class="line">                    <span class="keyword">while</span> (pre-&gt;next)</span><br><span class="line">                        pre = pre-&gt;next;</span><br><span class="line"></span><br><span class="line">                    cur = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ph.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个链表数组，每个链表都已经按升序排列。</span></span><br><span class="line"><span class="comment">请你将所有链表合并到一个升序链表中，返回合并后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span></span><br><span class="line"><span class="comment">输出：[1,1,2,3,4,4,5,6]</span></span><br><span class="line"><span class="comment">解释：链表数组如下：</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  1-&gt;4-&gt;5,</span></span><br><span class="line"><span class="comment">  1-&gt;3-&gt;4,</span></span><br><span class="line"><span class="comment">  2-&gt;6</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">将它们合并到一个有序链表中得到。</span></span><br><span class="line"><span class="comment">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k == lists.length</span></span><br><span class="line"><span class="comment">0 &lt;= k &lt;= 10^4</span></span><br><span class="line"><span class="comment">0 &lt;= lists[i].length &lt;= 500</span></span><br><span class="line"><span class="comment">-10^4 &lt;= lists[i][j] &lt;= 10^4</span></span><br><span class="line"><span class="comment">lists[i] 按 升序 排列</span></span><br><span class="line"><span class="comment">lists[i].length 的总和不超过 10^4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力遍历（略）</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 类似归并排序法（递归分治）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">Merge2Lists</span><span class="params">(ListNode *h1, ListNode *h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode ret;</span><br><span class="line">        ListNode *head = &amp;ret;</span><br><span class="line">        <span class="keyword">while</span> (h1 &amp;&amp; h2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h1-&gt;val &lt; h2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;next = h1;</span><br><span class="line">                h1 = h1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;next = h2;</span><br><span class="line">                h2 = h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head-&gt;next =  h1 ? h1 : h2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">RecurMerge</span><span class="params">(vector&lt;ListNode*&gt; &amp;lists, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            ret = lists[l];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">            ret = <span class="built_in">Merge2Lists</span>(<span class="built_in">RecurMerge</span>(lists, l, m), <span class="built_in">RecurMerge</span>(lists, m + <span class="number">1</span>, r));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RecurMerge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Meyhod 3: 优先队列（重载为小根堆）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *n1, ListNode *n2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n1-&gt;val &gt; n2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode ret, *node;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, Cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: lists)</span><br><span class="line">            <span class="keyword">if</span> (n)</span><br><span class="line">                pq.<span class="built_in">emplace</span>(n);</span><br><span class="line"></span><br><span class="line">        node = &amp;ret;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next = pq.<span class="built_in">top</span>();</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">                pq.<span class="built_in">emplace</span>(node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">146. LRU 缓存 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</span></span><br><span class="line"><span class="comment">实现 LRUCache 类：</span></span><br><span class="line"><span class="comment">LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</span></span><br><span class="line"><span class="comment">int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment">void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</span></span><br><span class="line"><span class="comment">函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= capacity &lt;= 3000</span></span><br><span class="line"><span class="comment">0 &lt;= key &lt;= 10000</span></span><br><span class="line"><span class="comment">0 &lt;= value &lt;= 105</span></span><br><span class="line"><span class="comment">最多调用 2 * 105 次 get 和 put</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 哈希map + 双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TLru</span></span><br><span class="line">    &#123;</span><br><span class="line">        TLru *pre_ = <span class="literal">nullptr</span>;</span><br><span class="line">        TLru *next_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> key_ = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val_ = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">TLru</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">TLru</span>(<span class="type">int</span> key, <span class="type">int</span> val): <span class="built_in">key_</span>(key), <span class="built_in">val_</span>(val) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TLru *head_ = <span class="literal">nullptr</span>;</span><br><span class="line">    TLru *tail_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> size_ = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total_size_ = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TLru *&gt; um_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveToHead</span><span class="params">(TLru *s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head_ != s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail_ == s)</span><br><span class="line">                tail_ = tail_-&gt;pre_;</span><br><span class="line"></span><br><span class="line">            s-&gt;pre_-&gt;next_ = s-&gt;next_;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;next_)</span><br><span class="line">                s-&gt;next_-&gt;pre_ = s-&gt;pre_;</span><br><span class="line"></span><br><span class="line">            s-&gt;pre_ = <span class="literal">nullptr</span>;</span><br><span class="line">            s-&gt;next_ = head_;</span><br><span class="line">            head_-&gt;pre_ = s;</span><br><span class="line">            head_ = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity): <span class="built_in">total_size_</span>(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">        TLru *temp;</span><br><span class="line">        <span class="keyword">while</span> (head_)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = head_;</span><br><span class="line">            head_ = head_-&gt;next_;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (um_.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = um_[key]-&gt;val_;</span><br><span class="line">            <span class="built_in">MoveToHead</span>(um_[key]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (um_.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            um_[key]-&gt;val_ = value;</span><br><span class="line">            <span class="built_in">MoveToHead</span>(um_[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size_ &lt; total_size_)</span><br><span class="line">        &#123;</span><br><span class="line">            ++size_;</span><br><span class="line">            TLru *obj = <span class="keyword">new</span> <span class="built_in">TLru</span>(key, value);</span><br><span class="line">            um_[key] = obj;</span><br><span class="line">            <span class="keyword">if</span> (head_)</span><br><span class="line">            &#123;</span><br><span class="line">                obj-&gt;next_ = head_;</span><br><span class="line">                head_-&gt;pre_ = obj;</span><br><span class="line">                head_ = obj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                head_ = tail_ = obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> old_key = tail_-&gt;key_;</span><br><span class="line">            um_.<span class="built_in">erase</span>(um_.<span class="built_in">find</span>(old_key));</span><br><span class="line">            um_[key] = tail_;</span><br><span class="line">            tail_-&gt;key_ = key;</span><br><span class="line">            tail_-&gt;val_ = value;</span><br><span class="line">            <span class="keyword">if</span> (tail_-&gt;pre_)</span><br><span class="line">                <span class="built_in">MoveToHead</span>(tail_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树 "></a><a href="#context.8">二叉树</a><a name="section.8"> </a></h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-100-liked">226. 翻转二叉树 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-100-liked">101. 对称二叉树 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">543. 二叉树的直径 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一棵二叉树的根节点，返回该树的 直径 。</span></span><br><span class="line"><span class="comment">二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</span></span><br><span class="line"><span class="comment">两节点之间路径的 长度 由它们之间边数表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">树中节点数目在范围 [1, 104] 内</span></span><br><span class="line"><span class="comment">-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 递归， 最大直径为 max(左右子树最大深度和, ret_max)  其中 ret_max = max(ret_max, left + right)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ret_max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Recur</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">Recur</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">Recur</span>(root-&gt;right);</span><br><span class="line">            ret_max = <span class="built_in">max</span>(ret_max, left + right);</span><br><span class="line">            ret = <span class="number">1</span> + <span class="built_in">max</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ret_max, <span class="built_in">Recur</span>(root) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment">高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">nums 按 严格递增 顺序排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 二分迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ret = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">            ret-&gt;left = <span class="built_in">Recur</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">            ret-&gt;right = <span class="built_in">Recur</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment">有效 二叉搜索树定义如下：</span></span><br><span class="line"><span class="comment">节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line"><span class="comment">节点的右子树只包含 大于 当前节点的数。</span></span><br><span class="line"><span class="comment">所有左子树和右子树自身必须也是二叉搜索树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">树中节点数目范围在[1, 104] 内</span></span><br><span class="line"><span class="comment">-231 &lt;= Node.val &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 递归判断即可（注意题目给的数字范围）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recur</span><span class="params">(TreeNode *node, <span class="type">long</span> min_val, <span class="type">long</span> max_val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;val &lt;= min_val || node-&gt;val &gt;= max_val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(node-&gt;left, min_val, node-&gt;val) &amp;&amp; <span class="built_in">Recur</span>(node-&gt;right, node-&gt;val, max_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(root, LONG_MIN, LONG_MAX);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">树中的节点数为 n 。</span></span><br><span class="line"><span class="comment">1 &lt;= k &lt;= n &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= Node.val &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 中序搜索</span></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked">199. 二叉树的右视图 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">114. 二叉树展开为链表 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span></span><br><span class="line"><span class="comment">输出: [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= preorder.length &lt;= 3000</span></span><br><span class="line"><span class="comment">inorder.length == preorder.length</span></span><br><span class="line"><span class="comment">-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</span></span><br><span class="line"><span class="comment">preorder 和 inorder 均 无重复 元素</span></span><br><span class="line"><span class="comment">inorder 均出现在 preorder</span></span><br><span class="line"><span class="comment">preorder 保证 为二叉树的前序遍历序列</span></span><br><span class="line"><span class="comment">inorder 保证 为二叉树的中序遍历序列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 迭代 + 栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!preorder.<span class="built_in">empty</span>() &amp;&amp; !inorder.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">            stack&lt;TreeNode *&gt; st;</span><br><span class="line">            st.<span class="built_in">emplace</span>(ret);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; p &lt; preorder.<span class="built_in">size</span>(); ++p) &#123;</span><br><span class="line">                TreeNode *pre = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre-&gt;val != inorder[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    pre-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[p]);</span><br><span class="line">                    st.<span class="built_in">emplace</span>(pre-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        pre = st.<span class="built_in">top</span>();</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                        ++i;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>()-&gt;val == inorder[i]);</span><br><span class="line"></span><br><span class="line">                    pre-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[p]);</span><br><span class="line">                    st.<span class="built_in">emplace</span>(pre-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 模拟递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span>&amp; p, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">        TreeNode *ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= e &amp;&amp; p &lt; preorder.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[p]);</span><br><span class="line">            <span class="type">int</span> mid = um[preorder[p++]];</span><br><span class="line">            ret-&gt;left = <span class="built_in">Recur</span>(preorder, p, inorder, i, mid - <span class="number">1</span>);</span><br><span class="line">            ret-&gt;right = <span class="built_in">Recur</span>(preorder, p, inorder, mid + <span class="number">1</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!preorder.<span class="built_in">empty</span>() &amp;&amp; !inorder.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                um[inorder[i]] = i;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            ret = <span class="built_in">Recur</span>(preorder, p, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</span></span><br><span class="line"><span class="comment">路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉树的节点个数的范围是 [0,1000]</span></span><br><span class="line"><span class="comment">-109 &lt;= Node.val &lt;= 109 </span></span><br><span class="line"><span class="comment">-1000 &lt;= targetSum &lt;= 1000 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 暴力（略）</span></span><br><span class="line"><span class="comment">///&lt; Method 2: 前缀表 + 回溯, 参考子串专节 力扣 560</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">RecurSum</span><span class="params">(TreeNode *node, <span class="type">int</span> tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (um.<span class="built_in">count</span>(sum - tar))</span><br><span class="line">                ret += um[sum - tar];</span><br><span class="line"></span><br><span class="line">            ++um[sum];</span><br><span class="line">            ret += <span class="built_in">RecurSum</span>(node-&gt;left, tar);</span><br><span class="line">            ret += <span class="built_in">RecurSum</span>(node-&gt;right, tar);</span><br><span class="line">            --um[sum];</span><br><span class="line">            sum -= node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        um[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">RecurSum</span>(root, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：相同题为 <a href="https://leetcode.cn/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">树中节点数目在范围 [2, 105] 内。</span></span><br><span class="line"><span class="comment">-109 &lt;= Node.val &lt;= 109</span></span><br><span class="line"><span class="comment">所有 Node.val 互不相同 。</span></span><br><span class="line"><span class="comment">p != q</span></span><br><span class="line"><span class="comment">p 和 q 均存在于给定的二叉树中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 递归 + 回溯（返回找到的节点本身）</span></span><br><span class="line"><span class="comment">///&lt; 若为公共节点需满足：1.左右非空 2.左空右有 3.左有右空</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode *ret = root;</span><br><span class="line">        <span class="keyword">if</span> (root &amp;&amp; root != p &amp;&amp; root != q)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">            TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (!left)</span><br><span class="line">                ret = right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!right)</span><br><span class="line">                ret = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-100-liked">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</span></span><br><span class="line"><span class="comment">路径和 是路径中各节点值的总和。</span></span><br><span class="line"><span class="comment">给你一个二叉树的根节点 root ，返回其 最大路径和 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">树中节点数目范围是 [1, 3 * 104]</span></span><br><span class="line"><span class="comment">-1000 &lt;= Node.val &lt;= 1000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 直接递归即可, 类似 力扣 543 二叉树的直径</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> max_sum = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">RecurSum</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">RecurSum</span>(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">RecurSum</span>(node-&gt;right), <span class="number">0</span>);</span><br><span class="line">            ret = node-&gt;val;</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, ret + l + r);</span><br><span class="line">            ret += <span class="built_in">max</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_sum, <span class="built_in">RecurSum</span>(root));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯 "></a><a href="#context.9">回溯</a><a name="section.9"> </a></h2><p><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked">46. 全排列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 函数递归（空间复杂度太大 - 标记版）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                v.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">Recur</span>(nums, used);</span><br><span class="line">                v.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="built_in">Recur</span>(nums, used);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 函数递归（优化版 - 交换位置）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>)  <span class="comment">///&lt; 减一是因为交换位置, 最后一位不用管</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[x], nums[i]);  <span class="comment">///&lt; i 位固定在 x</span></span><br><span class="line">            <span class="built_in">Recur</span>(nums, x + <span class="number">1</span>);  <span class="comment">///&lt; 递归</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[x], nums[i]);  <span class="comment">///&lt; 还原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">Recur</span>(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked">78. 子集 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment">解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 10</span></span><br><span class="line"><span class="comment">-10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line"><span class="comment">nums 中的所有元素 互不相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">Recur</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">Recur</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked">39. 组合总和 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked">22. 括号生成 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：n = 3</span></span><br><span class="line"><span class="comment">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == n &amp;&amp; r == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="built_in">Recur</span>(n, l + <span class="number">1</span>, r);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="built_in">Recur</span>(n, l, r + <span class="number">1</span>);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Recur</span>(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-100-liked">79. Word Search - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == board.length</span></span><br><span class="line"><span class="comment">n = board[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 6</span></span><br><span class="line"><span class="comment">1 &lt;= word.length &lt;= 15</span></span><br><span class="line"><span class="comment">board 和 word 仅由大小写英文字母组成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recur</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; vv, <span class="type">const</span> string &amp;word, <span class="type">int</span> pos, <span class="type">int</span> row, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">unsigned</span>)row &gt;= board.<span class="built_in">size</span>() || (<span class="type">unsigned</span>)col &gt;= board[row].<span class="built_in">size</span>()</span><br><span class="line">                 || vv[row][col] || board[row][col] != word[pos])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        vv[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Recur</span>(board, vv, word, pos + <span class="number">1</span>, row + <span class="number">1</span>, col)</span><br><span class="line">            || <span class="built_in">Recur</span>(board, vv, word, pos + <span class="number">1</span>, row  <span class="number">-1</span>, col)</span><br><span class="line">            || <span class="built_in">Recur</span>(board, vv, word, pos + <span class="number">1</span>, row, col - <span class="number">1</span>)</span><br><span class="line">            || <span class="built_in">Recur</span>(board, vv, word, pos + <span class="number">1</span>, row, col + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        vv[row][col] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vv</span>(board.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; board.<span class="built_in">size</span>(); ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; board[row].<span class="built_in">size</span>(); ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Recur</span>(board, vv, word, <span class="number">0</span>, row, col))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked">131. 分割回文串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</span></span><br><span class="line"><span class="comment">回文串 是正着读和反着读都一样的字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：s = &quot;aab&quot;</span></span><br><span class="line"><span class="comment">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：s = &quot;a&quot;</span></span><br><span class="line"><span class="comment">输出：[[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length &lt;= 16</span></span><br><span class="line"><span class="comment">s 仅由小写英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; vv;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(string &amp;s, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vv[x][i])</span><br><span class="line">            &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(x, i - x + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">                <span class="built_in">Recur</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vv.<span class="built_in">assign</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); ++j)</span><br><span class="line">                vv[i][j] = s[i] == s[j] &amp;&amp; vv[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Recur</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked">51. N 皇后 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</span></span><br><span class="line"><span class="comment">n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment">给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</span></span><br><span class="line"><span class="comment">每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：n = 4</span></span><br><span class="line"><span class="comment">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span></span><br><span class="line"><span class="comment">解释：如上图所示，4 皇后问题存在两个不同的解法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：n = 1</span></span><br><span class="line"><span class="comment">输出：[[&quot;Q&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; row; ++r)  <span class="comment">///&lt; 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (path[r][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = row - <span class="number">1</span>, c = col  <span class="number">-1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>; --r, --c)</span><br><span class="line">            <span class="keyword">if</span> (path[r][c] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = row - <span class="number">1</span>, c = col + <span class="number">1</span>; r &gt;= <span class="number">0</span> &amp;&amp; c &lt; n; --r, ++c)</span><br><span class="line">            <span class="keyword">if</span> (path[r][c] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsValid</span>(row, col, n))</span><br><span class="line">            &#123;</span><br><span class="line">                path[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">Recur</span>(n, row + <span class="number">1</span>);</span><br><span class="line">                path[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        path.<span class="built_in">assign</span>(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">Recur</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二分"><a href="#二分" class="headerlink" title="二分 "></a><a href="#context.10">二分</a><a name="section.10"> </a></h2><p><a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked">35. 搜索插入位置 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked">74. Search a 2D Matrix - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个满足下述两条属性的 m x n 整数矩阵：</span></span><br><span class="line"><span class="comment">每行中的整数从左到右按非递减顺序排列。</span></span><br><span class="line"><span class="comment">每行的第一个整数大于前一行的最后一个整数。</span></span><br><span class="line"><span class="comment">给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">m == matrix.length</span></span><br><span class="line"><span class="comment">n == matrix[i].length</span></span><br><span class="line"><span class="comment">1 &lt;= m, n &lt;= 100</span></span><br><span class="line"><span class="comment">-104 &lt;= matrix[i][j], target &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : matrix) &#123;</span><br><span class="line">            <span class="type">int</span> end = v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (end == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (end &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> right = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> mid;</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">                &#123;</span><br><span class="line">                    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    cout &lt;&lt; v[mid] &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (v[mid] &gt; target)</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (v[mid] &lt; target)</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 模拟二叉搜索树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; matrix.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[right][left] &gt; target)</span><br><span class="line">                --left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[right][left] &lt; target)</span><br><span class="line">                ++right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment">如果数组中不存在目标值 target，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment">你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= tar)</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">///&lt; 返回 r 因为是假如找到了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">BinarySearch</span>(nums, target);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">BinarySearch</span>(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">                ret = &#123;left, right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">整数数组 nums 按升序排列，数组中的值 互不相同 。</span></span><br><span class="line"><span class="comment">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span></span><br><span class="line"><span class="comment">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span></span><br><span class="line"><span class="comment">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 5000</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">nums 中的每个值都 独一无二</span></span><br><span class="line"><span class="comment">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span></span><br><span class="line"><span class="comment">-104 &lt;= target &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">            &#123;</span><br><span class="line">                m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[m] == target)</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[m])</span><br><span class="line">                    nums[l] &lt;= target &amp;&amp; target &lt; nums[m] ? r = m - <span class="number">1</span> : l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nums[m] &lt; target &amp;&amp; target &lt;= nums[r] ? l = m + <span class="number">1</span> : r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</span></span><br><span class="line"><span class="comment">若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</span></span><br><span class="line"><span class="comment">若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</span></span><br><span class="line"><span class="comment">注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span></span><br><span class="line"><span class="comment">给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 </span></span><br><span class="line"><span class="comment">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == nums.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">-5000 &lt;= nums[i] &lt;= 5000</span></span><br><span class="line"><span class="comment">nums 中的所有整数 互不相同</span></span><br><span class="line"><span class="comment">nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 函数递归二分，这复杂度真的满足要求吗？？？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[m])</span><br><span class="line">                ret = <span class="built_in">min</span>(nums[l], <span class="built_in">Recur</span>(nums, m + <span class="number">1</span>, r));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = <span class="built_in">min</span>(nums[m + <span class="number">1</span>], <span class="built_in">Recur</span>(nums, l, m));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Recur</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 严格二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; nums[r])</span><br><span class="line">                r = m;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">///&lt; 由题可知，实际上 nums[m] != nums[r], 因为 m 是偏左值, 又由 l &lt; r 限定不会等</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈 "></a><a href="#context.11">栈</a><a name="section.11"> </a></h2><p><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked">20. 有效的括号 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="comment">有效字符串需满足：</span></span><br><span class="line"><span class="comment">左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment">左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment">每个右括号都有一个对应的相同类型的左括号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">emplace</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">emplace</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">emplace</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-100-liked">155. 最小栈 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span></span><br><span class="line"><span class="comment">实现 MinStack 类:</span></span><br><span class="line"><span class="comment">MinStack() 初始化堆栈对象。</span></span><br><span class="line"><span class="comment">void push(int val) 将元素val推入堆栈。</span></span><br><span class="line"><span class="comment">void pop() 删除堆栈顶部的元素。</span></span><br><span class="line"><span class="comment">int top() 获取堆栈顶部的元素。</span></span><br><span class="line"><span class="comment">int getMin() 获取堆栈中的最小元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-231 &lt;= val &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">pop、top 和 getMin 操作总是在 非空栈 上调用</span></span><br><span class="line"><span class="comment">push, pop, top, and getMin最多被调用 3 * 104 次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：使用一个栈实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 双栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st_min;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        st_min.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">emplace</span>(val);</span><br><span class="line">        st_min.<span class="built_in">emplace</span>(<span class="built_in">min</span>(st_min.<span class="built_in">top</span>(), val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        st_min.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st_min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt; Method 2: 栈 + pair</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        st.<span class="built_in">emplace</span>(<span class="number">0</span>, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">emplace</span>(val, <span class="built_in">min</span>(st.<span class="built_in">top</span>().second, val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked">394. 字符串解码 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个经过编码的字符串，返回它解码后的字符串。</span></span><br><span class="line"><span class="comment">编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</span></span><br><span class="line"><span class="comment">你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</span></span><br><span class="line"><span class="comment">此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length &lt;= 30</span></span><br><span class="line"><span class="comment">s 由小写英文字母、数字和方括号 &#x27;[]&#x27; 组成</span></span><br><span class="line"><span class="comment">s 保证是一个 有效 的输入。</span></span><br><span class="line"><span class="comment">s 中所有整数的取值范围为 [1, 300] </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">string <span class="title">IsNum</span><span class="params">(string &amp;s, <span class="type">int</span> &amp;pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            x = s[pos++] - <span class="string">&#x27;0&#x27;</span> + x * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; s.<span class="built_in">size</span>() &amp;&amp; (<span class="type">unsigned</span>)(s[pos] - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">9</span>);</span><br><span class="line">        ++pos;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">        string str = <span class="built_in">IsLetter</span>(s, pos);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</span><br><span class="line">            ret += str;</span><br><span class="line"></span><br><span class="line">        ret += <span class="built_in">IsLetter</span>(s, pos);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">IsLetter</span><span class="params">(string &amp;s, <span class="type">int</span> &amp;pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="type">int</span> b = pos;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; s.<span class="built_in">size</span>() &amp;&amp; (<span class="type">unsigned</span>)((s[pos] | <span class="number">0x20</span>) - <span class="string">&#x27;a&#x27;</span>) &lt; <span class="number">26</span>) ++pos;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; pos)</span><br><span class="line">            ret = s.<span class="built_in">substr</span>(b, pos - b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 字母后面只可能是 &#x27;]&#x27; 或者 数字</span></span><br><span class="line">            <span class="type">char</span> ch = s[pos];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span>)(ch - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">9</span>)</span><br><span class="line">                ret += <span class="built_in">IsNum</span>(s, pos);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                ++pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret += <span class="built_in">IsLetter</span>(s, pos);</span><br><span class="line">            &#125; <span class="keyword">while</span> (pos &lt; s.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: temperatures = [73,74,75,71,69,72,76,73]</span></span><br><span class="line"><span class="comment">输出: [1,1,4,2,1,1,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2:</span></span><br><span class="line"><span class="comment">输入: temperatures = [30,40,50,60]</span></span><br><span class="line"><span class="comment">输出: [1,1,1,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 3:</span></span><br><span class="line"><span class="comment">输入: temperatures = [30,60,90]</span></span><br><span class="line"><span class="comment">输出: [1,1,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1 &lt;= temperatures.length &lt;= 105</span></span><br><span class="line"><span class="comment">30 &lt;= temperatures[i] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 单调栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!temperatures.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt; temperatures[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ret[st.<span class="built_in">top</span>().second] = i - st.<span class="built_in">top</span>().second;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">emplace</span>(temperatures[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="堆"><a href="#堆" class="headerlink" title="堆 "></a><a href="#context.12">堆</a><a name="section.12"> </a></h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-100-liked">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span></span><br><span class="line"><span class="comment">请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"><span class="comment">你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: [3,2,1,5,6,4], k = 2</span></span><br><span class="line"><span class="comment">输出: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 快排</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecurQS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            left = begin;</span><br><span class="line">            right = end;</span><br><span class="line">            mid = nums[left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (nums[left] &gt; mid) ++left;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt; nums[right]) --right;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[left++], nums[right--]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (begin &lt; right)</span><br><span class="line">                <span class="built_in">RecurQS</span>(nums, begin, right);</span><br><span class="line">            </span><br><span class="line">            begin = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RecurQS</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            ret = nums[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: nums = [1,1,1,2,2,3], k = 2</span></span><br><span class="line"><span class="comment">输出: [1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">k 的取值范围是 [1, 数组中不相同的元素的个数]</span></span><br><span class="line"><span class="comment">题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 优先队列（堆）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">                ++um[n];</span><br><span class="line">            </span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it: um)</span><br><span class="line">                pq.<span class="built_in">emplace</span>(it.second, it.first);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                ret.<span class="built_in">emplace_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked">295. 数据流的中位数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</span></span><br><span class="line"><span class="comment">例如 arr = [2,3,4] 的中位数是 3 。</span></span><br><span class="line"><span class="comment">例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现 MedianFinder 类:</span></span><br><span class="line"><span class="comment">MedianFinder() 初始化 MedianFinder 对象。</span></span><br><span class="line"><span class="comment">void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</span></span><br><span class="line"><span class="comment">double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-105 &lt;= num &lt;= 105</span></span><br><span class="line"><span class="comment">在调用 findMedian 之前，数据结构中至少有一个元素</span></span><br><span class="line"><span class="comment">最多 5 * 104 次调用 addNum 和 findMedian</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; 优先队列，大小堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq_min;  <span class="comment">///&lt; 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, Cmp&gt; pq_max;  <span class="comment">///&lt; 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">        pq_min.<span class="built_in">emplace</span>(INT_MIN);</span><br><span class="line">        pq_max.<span class="built_in">emplace</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; pq_min.<span class="built_in">top</span>())  <span class="comment">///&lt; 插入到 max</span></span><br><span class="line">        &#123;</span><br><span class="line">            pq_max.<span class="built_in">emplace</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (pq_max.<span class="built_in">size</span>() &gt; pq_min.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                pq_min.<span class="built_in">emplace</span>(pq_max.<span class="built_in">top</span>());</span><br><span class="line">                pq_max.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pq_min.<span class="built_in">emplace</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (pq_min.<span class="built_in">size</span>() &gt; pq_max.<span class="built_in">size</span>() + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pq_max.<span class="built_in">emplace</span>(pq_min.<span class="built_in">top</span>());</span><br><span class="line">                pq_min.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (pq_min.<span class="built_in">size</span>() != pq_max.<span class="built_in">size</span>())</span><br><span class="line">            ret = pq_min.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = (pq_max.<span class="built_in">top</span>() + pq_min.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心 "></a><a href="#context.13">贪心</a><a name="section.13"> </a></h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment">你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment">返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">输出：5</span></span><br><span class="line"><span class="comment">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line"><span class="comment">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">1 &lt;= prices.length &lt;= 105</span></span><br><span class="line"><span class="comment">0 &lt;= prices[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = INT_MIN;</span><br><span class="line">        <span class="type">int</span> min_p = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p: prices)</span><br><span class="line">        &#123;</span><br><span class="line">            min_p = <span class="built_in">min</span>(min_p, p);</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, p - min_p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked">55. 跳跃游戏 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment">判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：nums = [3,2,1,0,4]</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= nums[i] &lt;= 105</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_dis &lt; i)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            max_dis = <span class="built_in">max</span>(max_dis, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-100-liked">45. 跳跃游戏 II - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</span></span><br><span class="line"><span class="comment">每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</span></span><br><span class="line"><span class="comment">0 &lt;= j &lt;= nums[i] </span></span><br><span class="line"><span class="comment">i + j &lt; n</span></span><br><span class="line"><span class="comment">返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: nums = [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">输出: 2</span></span><br><span class="line"><span class="comment">解释: 跳到最后一个位置的最小跳跃数是 2。</span></span><br><span class="line"><span class="comment">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2:</span></span><br><span class="line"><span class="comment">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="comment">输出: 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">0 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">题目保证可以到达 nums[n-1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max_dis = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, e = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">            max_dis = <span class="built_in">max</span>(max_dis, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = max_dis;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked">763. 划分字母区间 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</span></span><br><span class="line"><span class="comment">注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</span></span><br><span class="line"><span class="comment">返回一个表示每个字符串片段的长度的列表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line"><span class="comment">输出：[9,7,8]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span></span><br><span class="line"><span class="comment">每个字母最多出现在一个片段中。</span></span><br><span class="line"><span class="comment">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：s = &quot;eccbbbbdec&quot;</span></span><br><span class="line"><span class="comment">输出：[10]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= s.length &lt;= 500</span></span><br><span class="line"><span class="comment">s 仅由小写英文字母组成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> hash[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, b = <span class="number">0</span>, e = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                e = <span class="built_in">max</span>(e, hash[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i == e)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>(e - b + <span class="number">1</span>);</span><br><span class="line">                    b = e + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="动规"><a href="#动规" class="headerlink" title="动规 "></a><a href="#context.14">动规</a><a name="section.14"> </a></h2><p><a href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked">70. 爬楼梯 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：n = 2</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment">解释：有两种方法可以爬到楼顶。</span></span><br><span class="line"><span class="comment">1. 1 阶 + 1 阶</span></span><br><span class="line"><span class="comment">2. 2 阶</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：n = 3</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment">解释：有三种方法可以爬到楼顶。</span></span><br><span class="line"><span class="comment">1. 1 阶 + 1 阶 + 1 阶</span></span><br><span class="line"><span class="comment">2. 1 阶 + 2 阶</span></span><br><span class="line"><span class="comment">3. 2 阶 + 1 阶</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 45</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = ret;</span><br><span class="line">            ret = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked">118. 杨辉三角 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</span></span><br><span class="line"><span class="comment">在「杨辉三角」中，每个数是它左上方和右上方的数的和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: numRows = 5</span></span><br><span class="line"><span class="comment">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= numRows &lt;= 30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ret</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ret[i].<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                ret[i][j] = ret[i - <span class="number">1</span>][j  <span class="number">-1</span>] + ret[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked">198. 打家劫舍 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span></span><br><span class="line"><span class="comment">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：[1,2,3,1]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span></span><br><span class="line"><span class="comment">     偷窃到的最高金额 = 1 + 3 = 4 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：[2,7,9,3,1]</span></span><br><span class="line"><span class="comment">输出：12</span></span><br><span class="line"><span class="comment">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span></span><br><span class="line"><span class="comment">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 100</span></span><br><span class="line"><span class="comment">0 &lt;= nums[i] &lt;= 400</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>, pre = ret;</span><br><span class="line">        <span class="type">int</span> best;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">        &#123;</span><br><span class="line">            best = <span class="built_in">max</span>(ret, pre + n);</span><br><span class="line">            pre = ret;</span><br><span class="line">            ret = best;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked">279. 完全平方数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</span></span><br><span class="line"><span class="comment">完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：n = 12</span></span><br><span class="line"><span class="comment">输出：3 </span></span><br><span class="line"><span class="comment">解释：12 = 4 + 4 + 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：n = 13</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment">解释：13 = 4 + 9</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = minn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked">152. 乘积最大子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</span></span><br><span class="line"><span class="comment">测试用例的答案是一个 32-位 整数。</span></span><br><span class="line"><span class="comment">子数组 是数组的连续子序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1:</span></span><br><span class="line"><span class="comment">输入: nums = [2,3,-2,4]</span></span><br><span class="line"><span class="comment">输出: 6</span></span><br><span class="line"><span class="comment">解释: 子数组 [2,3] 有最大乘积 6。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2:</span></span><br><span class="line"><span class="comment">输入: nums = [-2,0,-1]</span></span><br><span class="line"><span class="comment">输出: 0</span></span><br><span class="line"><span class="comment">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">-10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line"><span class="comment">nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>())</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            ret = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r_max = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r_min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t_max = r_max;</span><br><span class="line">                <span class="type">int</span> t_min = r_min;</span><br><span class="line">                r_max = <span class="built_in">max</span>(n, <span class="built_in">max</span>(t_min * n, t_max * n));</span><br><span class="line">                r_min = <span class="built_in">min</span>(n, <span class="built_in">min</span>(t_min * n, t_max * n));</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, r_max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked">300. 最长递增子序列 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span></span><br><span class="line"><span class="comment">子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [10,9,2,5,3,7,101,18]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：nums = [0,1,0,3,2,3]</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 3：</span></span><br><span class="line"><span class="comment">输入：nums = [7,7,7,7,7,7,7]</span></span><br><span class="line"><span class="comment">输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 2500</span></span><br><span class="line"><span class="comment">-104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/// &lt; Method 1: 动规 + 二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v&#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; v.<span class="built_in">back</span>())</span><br><span class="line">                    v.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (v[m] &lt; nums[i])</span><br><span class="line">                            l = m + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            r = m;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    v[l] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = v.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked">416. 分割等和子集 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [1,5,11,5]</span></span><br><span class="line"><span class="comment">输出：true</span></span><br><span class="line"><span class="comment">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3,5]</span></span><br><span class="line"><span class="comment">输出：false</span></span><br><span class="line"><span class="comment">解释：数组不能分割成两个元素和相等的子集。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= nums.length &lt;= 200</span></span><br><span class="line"><span class="comment">1 &lt;= nums[i] &lt;= 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; 0 - 1 背包问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            sum += n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || sum % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum, <span class="number">0</span>)</span></span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = sum; i &gt;= n; --i)</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[i - n] + n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[sum] == sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧 "></a><a href="#context.15">技巧</a><a name="section.15"> </a></h2><p><a href="https://leetcode.cn/problems/single-number/?envType=study-plan-v2&envId=top-100-liked">136. 只出现一次的数字 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment">你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 异或</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            ret ^= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked">169. 多数元素 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [2,2,1,1,1,2,2]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == nums.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">-109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 投票算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n: nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!times)</span><br><span class="line">                    ret = n;</span><br><span class="line">                </span><br><span class="line">                times += ret == n ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/sort-colors/?envType=study-plan-v2&envId=top-100-liked">75. 颜色分类 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</span></span><br><span class="line"><span class="comment">我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</span></span><br><span class="line"><span class="comment">必须在不使用库内置的 sort 函数的情况下解决这个问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n == nums.length</span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 300</span></span><br><span class="line"><span class="comment">nums[i] 为 0、1 或 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 三指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, pos = left;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; pos &lt;= right; ++pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[pos] == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[left++], nums[pos]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[pos] == <span class="number">2</span>)</span><br><span class="line">                    <span class="built_in">swap</span>(nums[right--], nums[pos--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked">287. 寻找重复数 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</span></span><br><span class="line"><span class="comment">假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span></span><br><span class="line"><span class="comment">你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入：nums = [1,3,4,2,2]</span></span><br><span class="line"><span class="comment">输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入：nums = [3,1,3,4,2]</span></span><br><span class="line"><span class="comment">输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">nums.length == n + 1</span></span><br><span class="line"><span class="comment">1 &lt;= nums[i] &lt;= n</span></span><br><span class="line"><span class="comment">nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何证明 nums 中至少存在一个重复的数字?</span></span><br><span class="line"><span class="comment">你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///&lt; Method 1: 抽象成环形链表 找环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret = nums[nums[ret]];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125; <span class="keyword">while</span> (slow != ret);</span><br><span class="line"></span><br><span class="line">            slow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">                ret = nums[ret];</span><br><span class="line">            &#125; <span class="keyword">while</span> (slow != ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整 "></a><a href="#context.16">向上取整</a><a name="section.16"> </a></h3><p><code>double ceil()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; a/b -&gt; (a + b - 1) / b</span></span><br><span class="line"><span class="comment">///&lt; double ceil();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> r = <span class="built_in">ceil</span>(d);  <span class="comment">///&lt; r = 4</span></span><br></pre></td></tr></table></figure>



<h3 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整 "></a><a href="#context.17">向下取整</a><a name="section.17"> </a></h3><p><code>double floor()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; double ceil();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> r = <span class="built_in">ceil</span>(d);  <span class="comment">///&lt; r = 4</span></span><br></pre></td></tr></table></figure>



<h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入 "></a><a href="#context.18">四舍五入</a><a name="section.18"> </a></h3><p><code>a / b -&gt; (a + b / 2) / b</code></p>
<h3 id="保留小数"><a href="#保留小数" class="headerlink" title="保留小数 "></a><a href="#context.19">保留小数</a><a name="section.19"> </a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> n = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, n);</span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(n * <span class="number">10</span>) / <span class="number">10</span> &lt;&lt; endl;  <span class="comment">///&lt; 利用round, 此处保留小数点后一位</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; n &lt;&lt; endl;  <span class="comment">///&lt; 需要引入头  &lt;iomanip&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 &amp; 技巧</title>
    <url>/2023/09/04/algorithm/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="算法-技巧"><a href="#算法-技巧" class="headerlink" title="算法 &amp; 技巧"></a>算法 &amp; 技巧</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">字符串</a><a name="context.1"> </a><ul>
<li><a href="#section.2">KMP算法</a><a name="context.2"> </a></li>
<li><a href="#section.3">Manacher算法（马拉车）</a><a name="context.3"> </a></li>
<li><a href="#section.4">不重复最长子串</a><a name="context.4"> </a></li>
</ul>
</li>
<li><a href="#section.5">排序算法</a><a name="context.5"> </a><ul>
<li><a href="#section.6">归并</a><a name="context.6"> </a></li>
<li><a href="#section.7">快排</a><a name="context.7"> </a></li>
</ul>
</li>
<li><a href="#section.8">回溯</a><a name="context.8"> </a></li>
<li><a href="#section.9">递归法</a><a name="context.9"> </a></li>
<li><a href="#section.10">贪心</a><a name="context.10"> </a></li>
<li><a href="#section.11">动规</a><a name="context.11"> </a></li>
<li><a href="#section.12">正则表达式</a><a name="context.12"> </a></li>
<li><a href="#section.13">向上取整</a><a name="context.13"> </a></li>
<li><a href="#section.14">向下取整</a><a name="context.14"> </a></li>
<li><a href="#section.15">四舍五入</a><a name="context.15"> </a></li>
<li><a href="#section.16">保留小数</a><a name="context.16"> </a></li>
</ul>
<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串 "></a><a href="#context.1">字符串</a><a name="section.1"> </a></h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法 "></a><a href="#context.2">KMP算法</a><a name="section.2"> </a></h3><p>用于字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。</p>
<p><strong>求前缀表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 求前缀表（最长公共子串） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>相关例题：</p>
<p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">KMP 459. 重复的子字符串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 */</span></span><br><span class="line"><span class="comment">/** 字符串 459 重复的子字符串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string &amp;s, <span class="type">int</span> *next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;  <span class="comment">///&lt; j 为前缀末尾, i 为后缀末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="built_in">GetNext</span>(s, next);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">            ret = next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; (len % (len - (next[len - <span class="number">1</span>]))) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n: arr)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!haystack.<span class="built_in">empty</span>() &amp;&amp; !needle.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; needle.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (needle[i] == needle[j])</span><br><span class="line">                    ++j;</span><br><span class="line"></span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">                    j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (haystack[i] == needle[j] &amp;&amp; ++j == needle.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = i - j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manacher算法（马拉车）"><a href="#Manacher算法（马拉车）" class="headerlink" title="Manacher算法（马拉车） "></a><a href="#context.3">Manacher算法（马拉车）</a><a name="section.3"> </a></h3><p>一个高效匹配回文子串长度的算法，他可以在o(n)的时间复杂度中计算出一个字符串的回文子串的长度</p>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">5. 最长回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 5 最长回文子串 马拉车算法 Manacher */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            t += c;</span><br><span class="line">            t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;  <span class="comment">///&lt; p 用来记录各点的回文半径</span></span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;           <span class="comment">///&lt; 某个回文串延伸到的最右边下标</span></span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;         <span class="comment">///&lt; r 所属回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_mid = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文串中心下标</span></span><br><span class="line">        <span class="type">int</span> max_rad = <span class="number">0</span>;     <span class="comment">///&lt; 遍历过的最大回文半径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, end = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 如果 i 还在区间内, 则此处半径为 i 关于 mid 对称点 j 处的半径(不超过左边界)</span></span><br><span class="line">            p[i] = i &lt; r ? <span class="built_in">min</span>(p[<span class="number">2</span> * mid - i], r - i) : <span class="number">1</span>;  <span class="comment">///&lt; 重要!!! 需理解!!!</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 暴力计算回文串长度</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - p[i]] == t[i + p[i]])</span><br><span class="line">                ++p[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 当 i 处的回文字符串长度超过右边界 r 时  更新 mid 和 r</span></span><br><span class="line">            <span class="keyword">if</span> (i + p[i] &gt; r) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                r = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max_rad 记录最大的半径 max_mid 记录最大半径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (p[i] &gt; max_rad) &#123;</span><br><span class="line">                max_rad = p[i];</span><br><span class="line">                max_mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>((max_mid - max_rad) &gt;&gt; <span class="number">1</span>, max_rad - <span class="number">1</span>);  <span class="comment">///&lt; 注意起始点需 / 2, 长度需 - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 字符串 647 回文子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            string t = <span class="string">&quot;*#&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">            &#123;</span><br><span class="line">                t += c;</span><br><span class="line">                t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size())</span></span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, e = t.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">                p[i] = i &lt; r ? <span class="built_in">min</span>(r - i, p[<span class="number">2</span> * mid - i]) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i + p[i] &gt; r)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = i + p[i];</span><br><span class="line">                    mid = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret += (p[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>总结马拉车</strong></p>
<p>步骤如下</p>
<ol>
<li><code>p[i] = i &lt; r ? min(p[2 * mid - i], r - i) : 1;</code></li>
<li>暴力外扩</li>
<li>外扩后判断<strong>半径</strong>是否超右边界，如果是，则更新右边界和中心点</li>
<li>更新最大半径和最大半径的中心点</li>
</ol>
<h3 id="不重复最长子串"><a href="#不重复最长子串" class="headerlink" title="不重复最长子串 "></a><a href="#context.4">不重复最长子串</a><a name="section.4"> </a></h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 */</span></span><br><span class="line"><span class="comment">/** 字符串 3 无重复字符的最长子串 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">                slow = <span class="built_in">max</span>(slow, arr[s[fast]]);</span><br><span class="line">                arr[s[fast]] = fast + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, fast - slow + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法 "></a><a href="#context.5">排序算法</a><a name="section.5"> </a></h2><table>
<thead>
<tr>
<th>名称</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔</td>
<td>O(n log n)</td>
<td>O(n log² n)</td>
<td>O(n log² n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="#%E5%BD%92%E5%B9%B6">归并</a></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="#%E5%BF%AB%E6%8E%92">快速</a></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n²)</td>
<td>O(n + k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n + k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="归并"><a href="#归并" class="headerlink" title="归并 "></a><a href="#context.6">归并</a><a name="section.6"> </a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;v, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Recur</span>(nums, v, left, mid);</span><br><span class="line">            <span class="built_in">Recur</span>(nums, v, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, p = left;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Cmp</span>(nums[i], nums[j]))</span><br><span class="line">                    v[p++] = nums[i++];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    v[p++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">                v[p++] = nums[i++];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">                v[p++] = nums[j++];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">copy</span>(v.<span class="built_in">begin</span>() + left, v.<span class="built_in">begin</span>() + right + <span class="number">1</span>, nums.<span class="built_in">begin</span>() + left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">            <span class="built_in">Recur</span>(nums, v, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="快排"><a href="#快排" class="headerlink" title="快排 "></a><a href="#context.7">快排</a><a name="section.7"> </a></h3><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecurQS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, temp;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            left = start;</span><br><span class="line">            right = end;</span><br><span class="line"></span><br><span class="line">            mid = nums[<span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start];  <span class="comment">// 随机效率比中位数高将近10倍</span></span><br><span class="line"><span class="comment">//            mid = nums[start + ((end - start) &gt;&gt; 1)];</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(nums[left], mid))  <span class="comment">///&lt; 注意这里是拿数 mid 去比！！！</span></span><br><span class="line">                    ++left;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">Compare</span>(mid, nums[right]))</span><br><span class="line">                    --right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = nums[left];</span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    nums[right] = temp;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left == right)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    --right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; right)</span><br><span class="line">                <span class="built_in">RecurQS</span>(nums, start, right);</span><br><span class="line"></span><br><span class="line">            start = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RecurQS</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯 "></a><a href="#context.8">回溯</a><a name="section.8"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码模板 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法 "></a><a href="#context.9">递归法</a><a name="section.9"> </a></h2><p>三部曲：</p>
<ol>
<li><p><strong>确定递归函数的参数和返回值</strong></p>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>确定终止条件</strong><br>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。<br>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
</li>
<li></li>
<li><p><strong>确定单层递归的逻辑</strong></p>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心 "></a><a href="#context.10">贪心</a><a name="section.10"> </a></h2><p>如果找到局部最优，然后推出整体最优，那么就是贪心</p>
<p>局部最优 → 总体最优</p>
<p><a href="https://www.programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 贪心 53 最大子数组和 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">///&lt; 1. 贪心</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret = INT32_MIN;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 2. 优化空间后的动态规划</span></span><br><span class="line"><span class="comment">//            ret = nums[0];</span></span><br><span class="line"><span class="comment">//            int pre = 0;</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                pre = max(pre + nums[i], nums[i]);</span></span><br><span class="line"><span class="comment">//                ret = max(ret, pre);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///&lt; 3. 未优化空间的动态规划</span></span><br><span class="line"><span class="comment">//            vector&lt;int&gt; dp(nums.size(), 0);</span></span><br><span class="line"><span class="comment">//            dp[0] = nums[0];</span></span><br><span class="line"><span class="comment">//            ret = dp[0];</span></span><br><span class="line"><span class="comment">//            for (int i = 1; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">//                if (dp[i - 1] &gt; 0)</span></span><br><span class="line"><span class="comment">//                    dp[i] = dp[i - 1] + nums[i];</span></span><br><span class="line"><span class="comment">//                else</span></span><br><span class="line"><span class="comment">//                    dp[i] = nums[i];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                ret = max(ret, dp[i]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="动规"><a href="#动规" class="headerlink" title="动规 "></a><a href="#context.11">动规</a><a name="section.11"> </a></h2><p><strong>0 - 1 背包问题</strong> 以及 <strong>完全背包问题</strong> 的  <b><font color='blue' size=3 face="">遍历顺序</font></b> </p>
<ul>
<li><p>0 - 1 背包是只能取一次</p>
</li>
<li><p>完全背包则是无限次取</p>
</li>
</ul>
<ol>
<li><p><strong>先遍历物品总数，为 <b><font color='blue' size=3 face="">组合类型</font></b> 问题</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="comment">// for(int j = weight[i]; j &lt;= bagWeight; j--) &#123; // 遍历背包容量, 可重复，从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量, 不可重复，从大到小</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);  <span class="comment">///&lt; 形式 1: 解决总数问题</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>先遍历容量，为 <b><font color='blue' size=3 face="">排列类型</font></b> 问题</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];  <span class="comment">///&lt; 形式 2: 解决次数问题，组合类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式 "></a><a href="#context.12">正则表达式</a><a name="section.12"> </a></h2><p>任意⼀个字符表示匹配任意对应的字符，如a匹配a， 7匹配7， -匹配-  </p>
<p><code>[ ]</code> 代表匹配中括号中其中任⼀字符，如 <code>[abc]</code> 匹配 a 或 b 或 c  </p>
<p><strong><code>-</code> 在中括号里面和外面不同：</strong></p>
<ol>
<li>在外，就匹配 <code>-</code></li>
<li>在内，如 <code>[a-b]</code> 表示匹配26个小写字母中的任一个</li>
</ol>
<p><code>[a-zA-Z]</code> 表匹配大小写共52个字母中任一个  </p>
<p><code>[0-9]</code> 表匹配十个数字中任一个  </p>
<p><strong><code>^</code> 在中括号里面和外面含义不同：</strong></p>
<ol>
<li>在外时，就表示开头，如 <code>^7[0-9]</code> 表示匹配开头是7的，且第二位是任一数字的字符串</li>
<li>在中括号里面，表示除了这个字符以外的任意字符（包括数字，特殊字符），如 <code>[^abc]</code> 表示匹配除去 <code>abc</code> 之外的其他任一字符</li>
</ol>
<p><strong>常用匹配字符</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>表示字符</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>\d</td>
<td>数字</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
</tr>
<tr>
<td>\s</td>
<td>由空字符组成， [ \t\n\r\x\f]</td>
</tr>
<tr>
<td>\S</td>
<td>由非空字符组成， [ ^ \s]</td>
</tr>
<tr>
<td>\w</td>
<td>字母、数字、下划线， [ a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>不是由字母、数字、下划线组成</td>
</tr>
<tr>
<td>?</td>
<td>出现0次或1次</td>
</tr>
<tr>
<td>+</td>
<td>出现 &gt;&#x3D; 1 次</td>
</tr>
<tr>
<td>*</td>
<td>出现任意次</td>
</tr>
<tr>
<td>{n}</td>
<td>出现 n 次</td>
</tr>
<tr>
<td>{n, m}</td>
<td>表示出现 n~m 次</td>
</tr>
<tr>
<td>{n, }</td>
<td>出现 &gt;&#x3D; n 次</td>
</tr>
<tr>
<td>XY</td>
<td>表示 X 后面跟着Y</td>
</tr>
<tr>
<td>X|Y</td>
<td>表示 X 或 Y</td>
</tr>
<tr>
<td>(X) 子表达式</td>
<td>将 X 看做是⼀个整体</td>
</tr>
</tbody></table>
<h2 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整 "></a><a href="#context.13">向上取整</a><a name="section.13"> </a></h2><p><code>double ceil()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; a/b -&gt; (a + b - 1) / b</span></span><br><span class="line"><span class="comment">///&lt; double ceil();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> r = <span class="built_in">ceil</span>(d);  <span class="comment">///&lt; r = 4</span></span><br></pre></td></tr></table></figure>



<h2 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整 "></a><a href="#context.14">向下取整</a><a name="section.14"> </a></h2><p><code>double floor()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; double ceil();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> r = <span class="built_in">ceil</span>(d);  <span class="comment">///&lt; r = 4</span></span><br></pre></td></tr></table></figure>



<h2 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入 "></a><a href="#context.15">四舍五入</a><a name="section.15"> </a></h2><p><code>double round()</code></p>
<p><code>a / b -&gt; (a + b / 2) / b</code></p>
<h2 id="保留小数"><a href="#保留小数" class="headerlink" title="保留小数 "></a><a href="#context.16">保留小数</a><a name="section.16"> </a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> n = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, n); <span class="comment">///&lt; 此方法也会四舍五入</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(n * <span class="number">10</span>) / <span class="number">10</span> &lt;&lt; endl;  <span class="comment">///&lt; 利用round, 此处保留小数点后一位，注意会四舍五入</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; n &lt;&lt; endl;  <span class="comment">///&lt; 需要引入头  &lt;iomanip&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2023/08/18/python/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">os库</a><a name="context.1"> </a><ul>
<li><a href="#section.2">总览</a><a name="context.2"> </a></li>
<li><a href="#section.3">os.chdir(path)</a><a name="context.3"> </a></li>
<li><a href="#section.4">os.getcwd()</a><a name="context.4"> </a></li>
<li><a href="#section.5">os.listdir(path)</a><a name="context.5"> </a></li>
<li><a href="#section.6">os.path.exists(path)</a><a name="context.6"> </a></li>
<li><a href="#section.7">os.mkdir(path)</a><a name="context.7"> </a></li>
<li><a href="#section.8">os.path.join(path1, path2)</a><a name="context.8"> </a></li>
<li><a href="#section.9">os.path.split(path)</a><a name="context.9"> </a></li>
<li><a href="#section.10">os.path.dirname(path)</a><a name="context.10"> </a></li>
<li><a href="#section.11">os.path.basename(path)</a><a name="context.11"> </a></li>
<li><a href="#section.12">os.path.isdir(path)</a><a name="context.12"> </a></li>
<li><a href="#section.13">os.path.isfile(path)</a><a name="context.13"> </a></li>
<li><a href="#section.14">os.path.sep</a><a name="context.14"> </a></li>
<li><a href="#section.15">os.path.getsize(path)</a><a name="context.15"> </a></li>
<li><a href="#section.16">os.remove(path)</a><a name="context.16"> </a></li>
<li><a href="#section.17">os.rmdir(path)</a><a name="context.17"> </a></li>
<li><a href="#section.18">os.removedirs()</a><a name="context.18"> </a></li>
<li><a href="#section.19">os.rename(old,new)</a><a name="context.19"> </a></li>
<li><a href="#section.20">os.curdir</a><a name="context.20"> </a></li>
<li><a href="#section.21">os.pardir</a><a name="context.21"> </a></li>
<li><a href="#section.22">os.path.abspath(path)</a><a name="context.22"> </a></li>
<li><a href="#section.23">os.chmod(file, mode)</a><a name="context.23"> </a></li>
<li><a href="#section.24">os.system()</a><a name="context.24"> </a></li>
<li><a href="#section.25">os.stat(path)</a><a name="context.25"> </a></li>
</ul>
</li>
<li><a href="#section.26">判断当前系统</a><a name="context.26"> </a></li>
<li><a href="#section.27">Json文件处理</a><a name="context.27"> </a></li>
<li><a href="#section.28">镜像源</a><a name="context.28"> </a><ul>
<li><a href="#section.29">一、直接使用镜像源下载</a><a name="context.29"> </a></li>
</ul>
</li>
<li><a href="#section.30">Jinja2</a><a name="context.30"> </a></li>
</ul>
<hr>
<h2 id="os库"><a href="#os库" class="headerlink" title="os库 "></a><a href="#context.1">os库</a><a name="section.1"> </a></h2><p>需 <code>import os</code></p>
<h3 id="总览"><a href="#总览" class="headerlink" title="总览 "></a><a href="#context.2">总览</a><a name="section.2"> </a></h3><table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#os.chdir(path)">os.chdir(path)</a></td>
<td>改变工作目录</td>
</tr>
<tr>
<td><a href="#os.getcwd()">os.getcwd()</a></td>
<td>获取当前的工作路径</td>
</tr>
<tr>
<td><a href="#os.listdir(path)">os.listdir(path)</a></td>
<td>传入任意一个path路径，返回的是该路径下所有<strong>文件</strong>和<strong>目录</strong>组成的列表</td>
</tr>
<tr>
<td><a href="#os.path.exists(path)">os.path.exists(path)</a></td>
<td>传入一个path路径，判断指定路径下的目录是否存在</td>
</tr>
<tr>
<td><a href="#os.mkdir(path)">os.mkdir(path)</a></td>
<td>传入一个path路径，创建单层(单个)文件夹</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="os-chdir-path"><a href="#os-chdir-path" class="headerlink" title="os.chdir(path) "></a><a href="#context.3">os.chdir(path)</a><a name="section.3"> </a></h3><p>改变工作目录</p>
<h3 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd() "></a><a href="#context.4">os.getcwd()</a><a name="section.4"> </a></h3><p>获取当前的工作路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">temp = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path) "></a><a href="#context.5">os.listdir(path)</a><a name="section.5"> </a></h3><p>传入任意一个path路径，返回的是该路径下所有<strong>文件</strong>和<strong>目录</strong>组成的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.listdir(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; [<span class="string">&#x27;test.sh&#x27;</span>, <span class="string">&#x27;demo.py&#x27;</span>, <span class="string">&#x27;main.py&#x27;</span>]</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path) "></a><a href="#context.6">os.path.exists(path)</a><a name="section.6"> </a></h3><p>传入一个path路径，判断指定路径下的目录是否存在。存在返回True，否则返回False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.exists(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-mkdir-path"><a href="#os-mkdir-path" class="headerlink" title="os.mkdir(path) "></a><a href="#context.7">os.mkdir(path)</a><a name="section.7"> </a></h3><p>传入一个path路径，创建单层(单个)文件夹</p>
<p>注：如果文件夹已经存在，就会报错。因此创建文件夹之前，需要使用 <code>os.path.exists(path)</code> 函数判断文件夹是否存在</p>
<h3 id="os-path-join-path1-path2"><a href="#os-path-join-path1-path2" class="headerlink" title="os.path.join(path1, path2) "></a><a href="#context.8">os.path.join(path1, path2)</a><a name="section.8"> </a></h3><p>传入两个path路径，将该路径拼接起来，形成一个新的完整路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path1 = <span class="string">&quot;/home/hq&quot;</span></span><br><span class="line">path2 = <span class="string">&quot;wyh&quot;</span></span><br><span class="line">temp = os.path.join(path1,path2)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; /home/hq/wyh</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path) "></a><a href="#context.9">os.path.split(path)</a><a name="section.9"> </a></h3><p>传入一个完整的path路径，将其拆分为绝对路径和文件名2部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.split(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(temp[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(temp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; (<span class="string">&#x27;/home/hq&#x27;</span>, <span class="string">&#x27;wyh&#x27;</span>)</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&gt;&gt; /home/hq</span><br><span class="line">&gt;&gt; wyh</span><br></pre></td></tr></table></figure>



<h3 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path) "></a><a href="#context.10">os.path.dirname(path)</a><a name="section.10"> </a></h3><p>传入一个完整的文件路径，只获取其绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.dirname(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; /home/hq</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path) "></a><a href="#context.11">os.path.basename(path)</a><a name="section.11"> </a></h3><p>传入一个完整的文件路径，只获取其文件名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = <span class="string">&quot;/home/hq/wyh&quot;</span></span><br><span class="line">temp = os.path.basename(path)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; wyh</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path) "></a><a href="#context.12">os.path.isdir(path)</a><a name="section.12"> </a></h3><p>传入一个完整的文件路径，判断它是否是文件夹</p>
<h3 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path) "></a><a href="#context.13">os.path.isfile(path)</a><a name="section.13"> </a></h3><p>传入一个完整的文件路径，判断它是否是文件</p>
<h3 id="os-path-sep"><a href="#os-path-sep" class="headerlink" title="os.path.sep "></a><a href="#context.14">os.path.sep</a><a name="section.14"> </a></h3><p>返回当前操作系统的路径分隔符</p>
<h3 id="os-path-getsize-path"><a href="#os-path-getsize-path" class="headerlink" title="os.path.getsize(path) "></a><a href="#context.15">os.path.getsize(path)</a><a name="section.15"> </a></h3><p>传入一个完整的文件路径，返回该文件的大小</p>
<h3 id="os-remove-path"><a href="#os-remove-path" class="headerlink" title="os.remove(path) "></a><a href="#context.16">os.remove(path)</a><a name="section.16"> </a></h3><p>删除文件</p>
<h3 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path) "></a><a href="#context.17">os.rmdir(path)</a><a name="section.17"> </a></h3><p>删除单层目录，非空抛出异常</p>
<h3 id="os-removedirs"><a href="#os-removedirs" class="headerlink" title="os.removedirs() "></a><a href="#context.18">os.removedirs()</a><a name="section.18"> </a></h3><p>递归删除目录，删除到非空文件为止</p>
<h3 id="os-rename-old-new"><a href="#os-rename-old-new" class="headerlink" title="os.rename(old,new) "></a><a href="#context.19">os.rename(old,new)</a><a name="section.19"> </a></h3><p>文件重命名</p>
<h3 id="os-curdir"><a href="#os-curdir" class="headerlink" title="os.curdir "></a><a href="#context.20">os.curdir</a><a name="section.20"> </a></h3><p>当前目录，相当于 <code>.</code></p>
<h3 id="os-pardir"><a href="#os-pardir" class="headerlink" title="os.pardir "></a><a href="#context.21">os.pardir</a><a name="section.21"> </a></h3><p>上级目录，相当于 <code>..</code></p>
<p>一般配合 [os.path.join(path1, path2)](#os.path.join(path1, path2)) 使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">path = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(path)</span><br><span class="line">temp = os.path.join(path, os.pardir)</span><br><span class="line">temp = os.path.abspath(temp)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj</span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path) "></a><a href="#context.22">os.path.abspath(path)</a><a name="section.22"> </a></h3><p>返回绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(os.curdir)) <span class="comment">#当前目录的绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(os.pardir)) <span class="comment">#上级目录的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj\wiki_demo</span><br><span class="line">&gt;&gt; D:\wyh\PyCharmPrj</span><br></pre></td></tr></table></figure>



<h3 id="os-chmod-file-mode"><a href="#os-chmod-file-mode" class="headerlink" title="os.chmod(file, mode) "></a><a href="#context.23">os.chmod(file, mode)</a><a name="section.23"> </a></h3><p>需 <code>import os, sys, stat</code></p>
<p>mode: ( 同linux )</p>
<ul>
<li><strong>stat.S_IXOTH:</strong> 其他用户有执行权0o001</li>
<li><strong>stat.S_IWOTH:</strong> 其他用户有写权限0o002</li>
<li><strong>stat.S_IROTH:</strong> 其他用户有读权限0o004</li>
<li><strong>stat.S_IRWXO:</strong> 其他用户有全部权限(权限掩码)0o007</li>
<li><strong>stat.S_IXGRP:</strong> 组用户有执行权限0o010</li>
<li><strong>stat.S_IWGRP:</strong> 组用户有写权限0o020</li>
<li><strong>stat.S_IRGRP:</strong> 组用户有读权限0o040</li>
<li><strong>stat.S_IRWXG:</strong> 组用户有全部权限(权限掩码)0o070</li>
<li><strong>stat.S_IXUSR:</strong> 拥有者具有执行权限0o100</li>
<li><strong>stat.S_IWUSR:</strong> 拥有者具有写权限0o200</li>
<li><strong>stat.S_IRUSR:</strong> 拥有者具有读权限0o400</li>
<li><strong>stat.S_IRWXU:</strong> 拥有者有全部权限(权限掩码)0o700</li>
<li><strong>stat.S_ISVTX:</strong> 目录里文件目录只有拥有者才可删除更改0o1000</li>
<li><strong>stat.S_ISGID:</strong> 执行此文件其进程有效组为文件所在组0o2000</li>
<li><strong>stat.S_ISUID:</strong> 执行此文件其进程有效用户为文件所有者0o4000</li>
<li><strong>stat.S_IREAD:</strong> windows下设为只读</li>
<li><strong>stat.S_IWRITE:</strong> windows下取消只读</li>
</ul>
<h3 id="os-system"><a href="#os-system" class="headerlink" title="os.system() "></a><a href="#context.24">os.system()</a><a name="section.24"> </a></h3><p>system函数可以将字符串转化成命令在服务器上运行；其原理是每一条system函数执行时，其会创建一个子进程在系统上执行命令行，子进程的执行结果无法影响主进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行多条指令</span></span><br><span class="line">os.system(<span class="string">&#x27;cd /usr/local &amp;&amp; mkdir aaa.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">os.system(<span class="string">&#x27;cd /usr/local ; mkdir aaa.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除文件夹以及内部文件</span></span><br><span class="line"><span class="keyword">if</span> os.sep == <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">    os.system(<span class="string">&quot;rd/s/q test&quot;</span>)	<span class="comment"># 删除test文件夹</span></span><br></pre></td></tr></table></figure>



<h3 id="os-stat-path"><a href="#os-stat-path" class="headerlink" title="os.stat(path) "></a><a href="#context.25">os.stat(path)</a><a name="section.25"> </a></h3><p>os.stat() 方法用于在给定的路径上执行一个系统 stat 的调用</p>
<p>参数</p>
<ul>
<li><strong>path</strong> – 指定路径</li>
</ul>
<p>返回值</p>
<p>stat 结构:</p>
<ul>
<li>st_mode: inode 保护模式</li>
<li>st_ino: inode 节点号。</li>
<li>st_dev: inode 驻留的设备。</li>
<li>st_nlink: inode 的链接数。</li>
<li>st_uid: 所有者的用户ID。</li>
<li>st_gid:** 所有者的组ID。</li>
<li>st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</li>
<li>st_atime: 上次访问的时间。</li>
<li>st_mtime:** 最后一次修改的时间。</li>
<li>st_ctime: 由操作系统报告的”ctime”。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line">g_path_json = <span class="string">r&quot;D:\wyh\Work\Prj\book1\config.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文件创建时间&quot;</span>, os.stat(g_path_json).st_ctime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最后一次修改时间&quot;</span>, os.stat(g_path_json).st_mtime)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(os.stat(g_path_json)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">&gt;&gt; 文件创建时间 <span class="number">1666941712.8650272</span></span><br><span class="line">&gt;&gt; 最后一次修改时间 <span class="number">1666947179.2710688</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;os.stat_result&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>















<h2 id="判断当前系统"><a href="#判断当前系统" class="headerlink" title="判断当前系统 "></a><a href="#context.26">判断当前系统</a><a name="section.26"> </a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"></span><br><span class="line">plat = platform.system().lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> plat == <span class="string">&#x27;windows&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;windows系统&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> plat == <span class="string">&#x27;linux&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;linux系统&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 或者用 os.path.sep 判断文件分隔符</span></span><br><span class="line"><span class="comment"># linux 是 / (除号)</span></span><br><span class="line"><span class="comment"># windows 是 \</span></span><br></pre></td></tr></table></figure>



<h2 id="Json文件处理"><a href="#Json文件处理" class="headerlink" title="Json文件处理 "></a><a href="#context.27">Json文件处理</a><a name="section.27"> </a></h2><p>从 json 文件中读取数据（返回字典类型）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_data = json.load(<span class="built_in">open</span>(‘xxx.json’))</span><br></pre></td></tr></table></figure>



<p>python 类型数据写入 json 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dump(python_data, <span class="built_in">open</span>(‘xxx.json’, “w”))</span><br></pre></td></tr></table></figure>



<p><strong>注：建议用 with open() as xx</strong></p>
<h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源 "></a><a href="#context.28">镜像源</a><a name="section.28"> </a></h2><p>改为国内镜像源下载</p>
<p>常用国内源：</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<p>以清华大学镜像源下载为例：</p>
<h3 id="一、直接使用镜像源下载"><a href="#一、直接使用镜像源下载" class="headerlink" title="一、直接使用镜像源下载 "></a><a href="#context.29">一、直接使用镜像源下载</a><a name="section.29"> </a></h3><p>安装指令：pip install xxx(包名) -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> –trusted-host pypi.tuna.tsinghua.edu.cn</p>
<p>-i ：后为镜像源地址</p>
<p>–trusted-host ：后边指的是host,例清华大学镜像源地址为 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/%EF%BC%8Chost%E5%B0%B1%E6%98%AF%E6%8C%87http://%E5%92%8C/%E4%B9%8B%E9%97%B4%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%8C%E5%8D%B3pypi.tuna.tsinghua.edu.cn">https://pypi.tuna.tsinghua.edu.cn/simple/，host就是指http://和/之间的部分，即pypi.tuna.tsinghua.edu.cn</a></p>
<h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2 "></a><a href="#context.30">Jinja2</a><a name="section.30"> </a></h2><p>自定义过滤器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个示例 Python 脚本。</span></span><br><span class="line"><span class="comment"># 自定义ord过滤器，将字符变量转换为对应的ASCII码值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ord_filter</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ord</span>(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;创建要在模板文件中使用的对象&#x27;&#x27;&#x27;</span></span><br><span class="line">value1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter1</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成要引用的字典&#x27;&#x27;&#x27;</span></span><br><span class="line">var = &#123;<span class="string">&#x27;key1&#x27;</span>: value1, <span class="string">&#x27;iter1&#x27;</span>: iter1()&#125;</span><br><span class="line"></span><br><span class="line">string = <span class="built_in">open</span>(<span class="string">&#x27;test.template&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>).read()  <span class="comment"># 打开模板文件</span></span><br><span class="line">template = Template(string)</span><br><span class="line"></span><br><span class="line">ret = template.render(var, <span class="built_in">ord</span>=ord_filter)</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;test_case.robot&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>).write(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># test.template</span></span><br><span class="line"><span class="comment"># *** Test Cases ***</span></span><br><span class="line"><span class="comment"># &#123;%- for x in iter1 %&#125;</span></span><br><span class="line"><span class="comment"># &#123;% if x == &#x27;a&#x27; %&#125;</span></span><br><span class="line"><span class="comment"># 列表里有：&#123;&#123; x &#125;&#125;</span></span><br><span class="line"><span class="comment">#     [转换成int型的值为：]  &#123;&#123; ord(x) &#125;&#125;</span></span><br><span class="line"><span class="comment">#     [记录-符号的效果]   &#123;&#123; x -&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;% else %&#125;</span></span><br><span class="line"><span class="comment">#     &#123;&#123; x &#125;&#125;　　&#123;&#123; key1 &#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;%- endif %&#125;</span></span><br><span class="line"><span class="comment"># &#123;%- endfor %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test_case.robot</span></span><br><span class="line"><span class="comment"># *** Test Cases ***</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 列表里有：a</span></span><br><span class="line"><span class="comment">#     [转换成int型的值为：]  97</span></span><br><span class="line"><span class="comment">#     [记录-符号的效果]   a</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     b　　[1, 2, 3]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     c　　[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2023/08/18/shell/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#section.1">shell基本语句</a><a name="context.1"> </a></li>
<li><a href="#section.2">shell脚本实现ssh文件拷贝（自动输入密码）</a><a name="context.2"> </a></li>
<li><a href="#section.3">获取当前主机IPv4</a><a name="context.3"> </a></li>
<li><a href="#section.4">判断是否安装软件</a><a name="context.4"> </a></li>
<li><a href="#section.5">重定向输出</a><a name="context.5"> </a></li>
<li><a href="#section.6">一、shell介绍</a><a name="context.6"> </a></li>
<li><a href="#section.7">二、shell脚本规范</a><a name="context.7"> </a></li>
<li><a href="#section.8">三、shell脚本基本操作流程</a><a name="context.8"> </a></li>
<li><a href="#section.9">四、变量</a><a name="context.9"> </a><ul>
<li><a href="#section.10">格式</a><a name="context.10"> </a></li>
<li><a href="#section.11"><strong>变量命名规范</strong></a><a name="context.11"> </a></li>
<li><a href="#section.12">输出变量内容</a><a name="context.12"> </a></li>
<li><a href="#section.13">变量的释放</a><a name="context.13"> </a></li>
<li><a href="#section.14">设置变量为只读变量</a><a name="context.14"> </a></li>
<li><a href="#section.15">特殊的变量</a><a name="context.15"> </a></li>
</ul>
</li>
<li><a href="#section.16">五、read键盘获取单个变量&#x2F;多个变量值</a><a name="context.16"> </a><ul>
<li><a href="#section.17">获取单变量值</a><a name="context.17"> </a></li>
<li><a href="#section.18">获取多变量值</a><a name="context.18"> </a></li>
</ul>
</li>
<li><a href="#section.19">六 、参数传递</a><a name="context.19"> </a><ul>
<li><a href="#section.20">作用</a><a name="context.20"> </a></li>
<li><a href="#section.21">格式</a><a name="context.21"> </a></li>
<li><a href="#section.22">文件中接收参数的方式</a><a name="context.22"> </a></li>
</ul>
</li>
<li><a href="#section.23">七、if - 分支结构</a><a name="context.23"> </a><ul>
<li><a href="#section.24">格式1</a><a name="context.24"> </a></li>
<li><a href="#section.25">格式2</a><a name="context.25"> </a></li>
</ul>
</li>
<li><a href="#section.26">八、运算符</a><a name="context.26"> </a><ul>
<li><a href="#section.27">逻辑运算符</a><a name="context.27"> </a></li>
<li><a href="#section.28">比较运算符</a><a name="context.28"> </a></li>
<li><a href="#section.29">变量值递增操作</a><a name="context.29"> </a></li>
<li><a href="#section.30">变量递增赋值操作</a><a name="context.30"> </a></li>
</ul>
</li>
<li><a href="#section.31">九、case分支</a><a name="context.31"> </a></li>
<li><a href="#section.32">十、for循环结构</a><a name="context.32"> </a></li>
<li><a href="#section.33">十一、while循环结构</a><a name="context.33"> </a></li>
<li><a href="#section.34">十二、函数</a><a name="context.34"> </a><ul>
<li><a href="#section.35"><strong>查看返回值内容 $?</strong></a><a name="context.35"> </a></li>
</ul>
</li>
<li><a href="#section.36">十三、测试文件的状态方式1</a><a name="context.36"> </a></li>
<li><a href="#section.37">十四、文件状态判断2（去掉前面test）</a><a name="context.37"> </a></li>
<li><a href="#section.38">十五、字符串其他操作</a><a name="context.38"> </a><ul>
<li><a href="#section.39">获取字符串长度</a><a name="context.39"> </a></li>
<li><a href="#section.40">拼接字符串</a><a name="context.40"> </a></li>
<li><a href="#section.41">截取字符串</a><a name="context.41"> </a></li>
<li><a href="#section.42">查找字符串中的指定字符的索引</a><a name="context.42"> </a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="shell基本语句"><a href="#shell基本语句" class="headerlink" title="shell基本语句 "></a><a href="#context.1">shell基本语句</a><a name="section.1"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取某一个文件或目录的上一级目录</span><br><span class="line">dirname 文件或目录</span><br><span class="line"># exp</span><br><span class="line">SCRIPT_FN=`realpath $0`</span><br><span class="line">SCRIPT_DIR=`dirname $SCRIPT_FN`</span><br><span class="line">echo $SCRIPT_DIR</span><br><span class="line">&gt;&gt; /home/users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取指定目录或文件的绝对路径</span><br><span class="line">realpath 文件或目录</span><br><span class="line"># exp</span><br><span class="line">SCRIPT_FN=`realpath $0`</span><br><span class="line">echo $SCRIPT_FN</span><br><span class="line">&gt;&gt; /d/wyh/Work/Prj/wiki_doc_build/build/test.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断目录是否存在</span><br><span class="line">if [ ! -d &quot;hubs_doc&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 判断文件是否存在</span><br><span class="line">if [ ! -f &quot;test.txt&quot; ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;文件存在&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 判断返回值</span><br><span class="line">ret=`python3 demo.py`</span><br><span class="line">if [ &quot;$ret&quot; == 1 ]		# &quot;&quot;: 双引号表示保留一个参数</span><br><span class="line">then</span><br><span class="line">    echo &quot;Is 1!&quot;</span><br><span class="line">else</span><br><span class="line">    echo $ret</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup Command [ Arg … ] [　&amp; ]</span><br></pre></td></tr></table></figure>



<p><strong>nohup</strong> 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p>
<p><strong>nohup</strong> 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 <strong>$HOME&#x2F;nohup.out</strong> 文件中。</p>
<h2 id="shell脚本实现ssh文件拷贝（自动输入密码）"><a href="#shell脚本实现ssh文件拷贝（自动输入密码）" class="headerlink" title="shell脚本实现ssh文件拷贝（自动输入密码） "></a><a href="#context.2">shell脚本实现ssh文件拷贝（自动输入密码）</a><a name="section.2"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖 expect</span><br><span class="line">sudo apt-get install expect</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># xxx.sh 内容如下</span><br><span class="line"></span><br><span class="line">#!/usr/bin/expect -f 		# 指定使用此路径下的 expect</span><br><span class="line">set timeout 30				# 设置超时时间</span><br><span class="line">spawn scp TcrController james@192.168.1.119:/home/james/ws</span><br><span class="line">expect &quot;*password:&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect eof</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># scp 命令介绍</span><br><span class="line"># 复制文件到目标</span><br><span class="line"># scp 文件 目标地址</span><br><span class="line"></span><br><span class="line"># -r 表示复制当前路径下的xxx整个文件到远端的wyh目录下[重命名为123]</span><br><span class="line">scp [-r] xxx user@xxx.xxx.xxx.xxx:/home/wyh[/123]</span><br></pre></td></tr></table></figure>





<h2 id="获取当前主机IPv4"><a href="#获取当前主机IPv4" class="headerlink" title="获取当前主机IPv4 "></a><a href="#context.3">获取当前主机IPv4</a><a name="section.3"> </a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地 ipv4</span></span><br><span class="line">ipv4_loc=`ifconfig -a | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk &#x27;&#123;print $2&#125;&#x27; | tr -d &quot;addr:&quot;`</span><br></pre></td></tr></table></figure>





<h2 id="判断是否安装软件"><a href="#判断是否安装软件" class="headerlink" title="判断是否安装软件 "></a><a href="#context.4">判断是否安装软件</a><a name="section.4"> </a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if ! [ -x &quot;$(command -v git)&quot; ]; then</span><br><span class="line">  echo &#x27;Error: git is not installed.&#x27; &gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出 "></a><a href="#context.5">重定向输出</a><a name="section.5"> </a></h2><p><a href="https://blog.csdn.net/icandoit_2014/article/details/121178276">(24条消息) shell中 ＞&amp; 的含义解释_wufeng_asia的博客-CSDN博客_shell中&amp;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">末尾的 &amp; 表示后台执行，终端不打印信息</span></span><br><span class="line">teedoc build &gt; build_log.txt &amp;</span><br></pre></td></tr></table></figure>







<h2 id="一、shell介绍"><a href="#一、shell介绍" class="headerlink" title="一、shell介绍 "></a><a href="#context.6">一、shell介绍</a><a name="section.6"> </a></h2><ol>
<li>shell 是一段应用程序，是用户和操作系统交互的一个桥梁，shell 通常就是 .sh 脚本</li>
<li>shell 是弱类型语言，定义变量不需要指定变量的类型</li>
</ol>
<h2 id="二、shell脚本规范"><a href="#二、shell脚本规范" class="headerlink" title="二、shell脚本规范 "></a><a href="#context.7">二、shell脚本规范</a><a name="section.7"> </a></h2><p>shell 脚本是以 .sh 结尾的文件<br>sh 文件的第一行内容为 <code>#!/bin/bash</code>    表示使用shell进行编程(不写也不会报错)<br>shell 中的注释：#</p>
<h2 id="三、shell脚本基本操作流程"><a href="#三、shell脚本基本操作流程" class="headerlink" title="三、shell脚本基本操作流程 "></a><a href="#context.8">三、shell脚本基本操作流程</a><a name="section.8"> </a></h2><p>建立 shell 脚本（使用vim编辑器)<br>vim 脚本名.sh</p>
<p>编写 shell 脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p><strong>运行shell脚本</strong></p>
<p>方式一:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh 脚本名.sh</span><br></pre></td></tr></table></figure>



<p>方式二:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x 脚本名.sh</span><br><span class="line"></span><br><span class="line">./脚本名.sh</span><br></pre></td></tr></table></figure>



<h2 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量 "></a><a href="#context.9">四、变量</a><a name="section.9"> </a></h2><h4 id="格式"><a href="#格式" class="headerlink" title="格式 "></a><a href="#context.10">格式</a><a name="section.10"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 变量名=变量值    (等于号两边没有空格)</span><br><span class="line">name=chengliang</span><br></pre></td></tr></table></figure>



<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范 "></a><a href="#context.11"><strong>变量命名规范</strong></a><a name="section.11"> </a></h4><p>(1)命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>(2)中间不能有空格，可以使用下划线（_）。<br>(3)不能使用标点符号。<br>(4)不能使用bash里的关键字（可用help命令查看保留关键字）</p>
<h4 id="输出变量内容"><a href="#输出变量内容" class="headerlink" title="输出变量内容 "></a><a href="#context.12">输出变量内容</a><a name="section.12"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo $变量名</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>



<h4 id="变量的释放"><a href="#变量的释放" class="headerlink" title="变量的释放 "></a><a href="#context.13">变量的释放</a><a name="section.13"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># unset 变量名</span><br><span class="line">unset name </span><br></pre></td></tr></table></figure>



<h4 id="设置变量为只读变量"><a href="#设置变量为只读变量" class="headerlink" title="设置变量为只读变量 "></a><a href="#context.14">设置变量为只读变量</a><a name="section.14"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># readonly 变量名</span><br><span class="line"># 注:只读变量的值不能被改变，也不能使用unset删除</span><br><span class="line">readonly name</span><br></pre></td></tr></table></figure>



<h4 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量 "></a><a href="#context.15">特殊的变量</a><a name="section.15"> </a></h4><p>(1)双引号 “<br>如果双引号中存在 $变量名的话，那么输出结果将会是变量名对应的变量值<br>(2)单引号 ’<br>如果变量值中存在**$变量名**，那么将原样输出<br>(3)反单引号&#96;&#96;(Tab上面的键)<br>反单引号中可以存放的是linux命令，运行脚本时相当于运行linux命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1=world</span><br><span class="line">name2=”hello$name1”</span><br><span class="line">name3=’hello$name1’</span><br><span class="line">echo $name2      	# 输出---&gt;helloworld</span><br><span class="line">echo $name3      	# 输出---&gt;hello$name1</span><br></pre></td></tr></table></figure>



<h2 id="五、read键盘获取单个变量-多个变量值"><a href="#五、read键盘获取单个变量-多个变量值" class="headerlink" title="五、read键盘获取单个变量&#x2F;多个变量值 "></a><a href="#context.16">五、read键盘获取单个变量&#x2F;多个变量值</a><a name="section.16"> </a></h2><h4 id="获取单变量值"><a href="#获取单变量值" class="headerlink" title="获取单变量值 "></a><a href="#context.17">获取单变量值</a><a name="section.17"> </a></h4><ul>
<li>不带提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read 变量名</span><br></pre></td></tr></table></figure>

<ul>
<li>带有提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “提示文字” 变量名</span><br></pre></td></tr></table></figure>

<h4 id="获取多变量值"><a href="#获取多变量值" class="headerlink" title="获取多变量值 "></a><a href="#context.18">获取多变量值</a><a name="section.18"> </a></h4><ul>
<li>不带提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read 变量1名 变量2名</span><br></pre></td></tr></table></figure>



<ul>
<li>带有提示文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “提示文字” 变量1名 变量2名</span><br></pre></td></tr></table></figure>



<p>注:终端输入值时也要用空格隔开</p>
<p><img src="/shell.assets/image-20220921203404445.png" alt="image-20220921203404445"></p>
<h2 id="六-、参数传递"><a href="#六-、参数传递" class="headerlink" title="六 、参数传递 "></a><a href="#context.19">六 、参数传递</a><a name="section.19"> </a></h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用 "></a><a href="#context.20">作用</a><a name="section.20"> </a></h4><p>向shell脚本文件中传递数据，在运行脚本时一起传递</p>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式 "></a><a href="#context.21">格式</a><a name="section.21"> </a></h4><p>命令 文件名 参数（运行文件时的命令，脚本中使用$1表示参数值）</p>
<h4 id="文件中接收参数的方式"><a href="#文件中接收参数的方式" class="headerlink" title="文件中接收参数的方式 "></a><a href="#context.22">文件中接收参数的方式</a><a name="section.22"> </a></h4><p>$1—&gt;表示第一个参数<br>$2—&gt;表示第二个参数<br>$3—&gt;第三个参数<br>$n—&gt;表示第n个参数<br>$0—&gt;代表文件名<br>$@ : 显示全部参数<br>$#:  显示参数的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.sh</span><br><span class="line">    #!/bin/bash</span><br><span class="line">  1 echo this is $2</span><br><span class="line">  2 </span><br><span class="line">  3 echo this is $1</span><br><span class="line">  4 </span><br><span class="line">  5 echo this is $2</span><br></pre></td></tr></table></figure>


<p>运行结果</p>
<p><img src="/shell.assets/image-20220921203533180.png" alt="image-20220921203533180"></p>
<h2 id="七、if-分支结构"><a href="#七、if-分支结构" class="headerlink" title="七、if - 分支结构 "></a><a href="#context.23">七、if - 分支结构</a><a name="section.23"> </a></h2><h4 id="格式1"><a href="#格式1" class="headerlink" title="格式1 "></a><a href="#context.24">格式1</a><a name="section.24"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># exp 两个变量判断是否相等</span><br><span class="line">if [ &quot;$var1&quot; = &quot;$var2&quot; ]; then</span><br><span class="line">　　echo &#x27;$var1 eq $var2&#x27;</span><br><span class="line">else</span><br><span class="line">　　echo &#x27;$var1 not eq $var2&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># exp 判断普通文件$doiido是否存，若不存在，则新建一个</span><br><span class="line">if [ ! -f &quot;$doiido&quot; ]; then</span><br><span class="line">　　touch &quot;$doiido&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="格式2"><a href="#格式2" class="headerlink" title="格式2 "></a><a href="#context.25">格式2</a><a name="section.25"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">elif [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">else</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 判断学生的成绩，范围在90-100提示优秀，80-90之间提示良好,70-80之间则提示一般，60-70之间提示及格。其他则提示不及格</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入成绩:&quot; score</span><br><span class="line">if [ &quot;$score&quot; -ge 90 -a &quot;$score&quot; -le 100 ];then</span><br><span class="line">        echo &quot;优秀&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 80 -a &quot;$score&quot; -lt 90 ];then</span><br><span class="line">        echo &quot;良好&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 70 -a &quot;$score&quot; -lt 80 ];then</span><br><span class="line">        echo &quot;一般&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge 60 -a &quot;$score&quot; -lt 70 ];then</span><br><span class="line">        echo &quot;及格&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;不及格&quot;</span><br><span class="line">fi</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「小小的圈圈」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_36334897/article/details/105222836</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<ol>
<li>条件两边要有空格</li>
<li>多个条件间要有空格</li>
<li>if后面要有空格</li>
<li>条件中如果存在变量，那么变量的两边要有双引号</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断任意一个目录是否为空</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入需要判断的目录:&quot; dir</span><br><span class="line">m=`ls $dir`</span><br><span class="line">if [ &quot;$m&quot; == &quot;&quot; ];then</span><br><span class="line">        echo &quot;$dir目录为空&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;$dir目录不为空&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：echo语句不缩进也不会报错，缩进只是格式上看着清楚</p>
<h2 id="八、运算符"><a href="#八、运算符" class="headerlink" title="八、运算符 "></a><a href="#context.26">八、运算符</a><a name="section.26"> </a></h2><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符 "></a><a href="#context.27">逻辑运算符</a><a name="section.27"> </a></h4><p>且：-a<br>或: -o<br>非: !</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断用户输入的用户名和密码是否为admin 123456,如果是则提示登录成功，否则提示失败</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入用户名和密码:&quot; username passward</span><br><span class="line">if [ &quot;$username&quot; == &quot;admin&quot; -a  &quot;$passward&quot; == &quot;123456&quot; ];then</span><br><span class="line">        echo &quot;登录成功&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;登录失败&quot;</span><br></pre></td></tr></table></figure>



<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符 "></a><a href="#context.28">比较运算符</a><a name="section.28"> </a></h4><p>（1）数值间的比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-eq    # 判断是否相等(equal)</span><br><span class="line">-ne    # 判断是否不相等(not equal)</span><br><span class="line">-gt    # 判断是否大于(greater than)</span><br><span class="line">-ge    # 判断是否大于等于(greater equal)</span><br><span class="line">-lt    # 判断是否小于(less than)</span><br><span class="line">-le    # 判断是否小于等于(less than equal)</span><br></pre></td></tr></table></figure>



<p>（2）字符串之间的比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==    # 判断两个字符串是否相等</span><br><span class="line">!=    # 判断两个字符串是否不相等</span><br><span class="line">-z    # 检查字符串长度是否为0</span><br><span class="line">-n    # 检查字符串长度是否不为0</span><br><span class="line">-$    # 检查字符串是否不为空</span><br></pre></td></tr></table></figure>



<h4 id="变量值递增操作"><a href="#变量值递增操作" class="headerlink" title="变量值递增操作 "></a><a href="#context.29">变量值递增操作</a><a name="section.29"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((i++))</span><br><span class="line">((i+=1))</span><br><span class="line">i=[i+1]</span><br><span class="line">let i=i+1</span><br><span class="line">i=$(($i+1))</span><br></pre></td></tr></table></figure>



<h4 id="变量递增赋值操作"><a href="#变量递增赋值操作" class="headerlink" title="变量递增赋值操作 "></a><a href="#context.30">变量递增赋值操作</a><a name="section.30"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=$(($s+$i))</span><br><span class="line">s=$[$s+$i]</span><br><span class="line">((s=$s+$i))</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输入数字，判断是否大于0，如果大于0则将该数字-1并输出，否则+1输出</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入一个数值:&quot; num</span><br><span class="line">if [ &quot;$num&quot; -gt 0 ];then</span><br><span class="line">        ((num-=1))</span><br><span class="line">        echo &quot;$num&quot;</span><br><span class="line">else</span><br><span class="line">        ((num+=1))</span><br><span class="line">        echo &quot;$num&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="九、case分支"><a href="#九、case分支" class="headerlink" title="九、case分支 "></a><a href="#context.31">九、case分支</a><a name="section.31"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">“值”)</span><br><span class="line">语句;;</span><br><span class="line">…</span><br><span class="line">*) # 上面条件均不满足，默认语句</span><br><span class="line">语句;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<ol>
<li><p>case这一行最后必须为in</p>
</li>
<li><p>;;    结束语句</p>
</li>
<li><p>*为默认</p>
</li>
<li><p>esac—&gt;case语句的结束</p>
</li>
<li><p>值可以是字符串也可以是数字</p>
</li>
<li><p>“值”还可以是区间范围,范围[0-9]</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输入一个字母，判断该用户选择哪款产品，A：笔记本 B：电饭煲 C：小台灯</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入:&quot; data</span><br><span class="line">case $data in</span><br><span class="line">&quot;A&quot;)</span><br><span class="line">        echo &quot;笔记本&quot;;;</span><br><span class="line">&quot;B&quot;)</span><br><span class="line">        echo &quot;电饭煲&quot;;;</span><br><span class="line">&quot;C&quot;)</span><br><span class="line">        echo &quot;小台灯&quot;;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># 请输入对客服的满意度，【0-3】不满意，【4-6】满意，【7-9】非常满意</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入您的满意度:&quot; scr</span><br><span class="line">case $scr in</span><br><span class="line">[0-3])</span><br><span class="line">        echo &quot;不满意&quot;;;</span><br><span class="line">[4-6])</span><br><span class="line">        echo &quot;一般满意&quot;;;</span><br><span class="line">[7-9])</span><br><span class="line">        echo &quot;非常满意&quot;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h2 id="十、for循环结构"><a href="#十、for循环结构" class="headerlink" title="十、for循环结构 "></a><a href="#context.32">十、for循环结构</a><a name="section.32"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量名 in 列表</span><br><span class="line">do 语句</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 输出1-10之间的数</span><br><span class="line">#!/bin/bash</span><br><span class="line">for i in 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>seq 数列生成式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq start step max</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 使用seq生成1-10并序列输出1-10之间的数</span><br><span class="line">#!/bin/bash</span><br><span class="line">for i in `seq 1 1 10` (也可为1 10,省略步长）   </span><br><span class="line"># seq为命令，所以要加反单引号，</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h2 id="十一、while循环结构"><a href="#十一、while循环结构" class="headerlink" title="十一、while循环结构 "></a><a href="#context.33">十一、while循环结构</a><a name="section.33"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ 条件 ]</span><br><span class="line">do</span><br><span class="line">命令</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 求1-100之间的和</span><br><span class="line">#!/bin/bash</span><br><span class="line">i=1</span><br><span class="line">sum=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">  sum=$(($sum+$i))</span><br><span class="line">  ((i++))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数 "></a><a href="#context.34">十二、函数</a><a name="section.34"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名()</span><br><span class="line">&#123; 代码 &#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数中的参数</strong></p>
<p>使用$n来接收数据</p>
<p><strong>返回值</strong></p>
<p>函数中默认的存在返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确时返回0 # 函数执行没有错误</span><br><span class="line">错误时返回1 # 函数执行出错</span><br></pre></td></tr></table></figure>



<h4 id="查看返回值内容"><a href="#查看返回值内容" class="headerlink" title="查看返回值内容 $? "></a><a href="#context.35"><strong>查看返回值内容 $?</strong></a><a name="section.35"> </a></h4><p><strong>函数调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名</span><br></pre></td></tr></table></figure>

<p><strong>注</strong><br>必须先定义再调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exp 1</span><br><span class="line"># 定义一个打印hello world函数并调用</span><br><span class="line">#!/bin/bash</span><br><span class="line">hello()&#123;      # 定义函数</span><br><span class="line">  echo &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello  #调用函数 </span><br><span class="line"></span><br><span class="line"># exp 2</span><br><span class="line"># 输入任意两个整数进行求和运算，并打印结果</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入第一个数:&quot; num1</span><br><span class="line">read -p &quot;请输入第二个数:&quot; num2</span><br><span class="line">add()&#123;         # 定义函数</span><br><span class="line">        s=$(($1+$2))     # 数值运算</span><br><span class="line">        echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add $num1 $num2    # 调用函数及传参</span><br></pre></td></tr></table></figure>



<h2 id="十三、测试文件的状态方式1"><a href="#十三、测试文件的状态方式1" class="headerlink" title="十三、测试文件的状态方式1 "></a><a href="#context.36">十三、测试文件的状态方式1</a><a name="section.36"> </a></h2><p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test 参数 $目录名</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e表示文件是否存在</span><br><span class="line">-f 表示文件是否存在且为文件</span><br><span class="line">-d 表示文件名是否存在且为目录</span><br><span class="line">-r 可读</span><br><span class="line">-w 可写</span><br><span class="line">-x 可执行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exp</span><br><span class="line"># 判断用户输入的目录是否存在，如果存在则统计目录下的文件个数，否则提示用户该目录不存在</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入目录:&quot; dir</span><br><span class="line">if test -d $dir      # if后面的条件不加中括号</span><br><span class="line">then</span><br><span class="line">        num=`ls -l | wc -l`</span><br><span class="line">        echo &quot;该目录下的文件个数为:$num个&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;该目录不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="十四、文件状态判断2（去掉前面test）"><a href="#十四、文件状态判断2（去掉前面test）" class="headerlink" title="十四、文件状态判断2（去掉前面test） "></a><a href="#context.37">十四、文件状态判断2（去掉前面test）</a><a name="section.37"> </a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r　　　　文件是否存在且可读</span><br><span class="line">-w　　　　文件是否存在且可写</span><br><span class="line">-x 文件是否存在且可执行</span><br><span class="line">-f　　　　文件是否存在且是普通文件</span><br><span class="line">-d　　　　文件是否存在且是一个目录</span><br><span class="line">-e 文件是否存在</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 判断用户输入的内容是否为空，为空则提示，不为空则判断是否为目录，不为目录则判断是否为文件，否则提示错误信息</span><br><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;请输入信息&quot; data</span><br><span class="line">if [ $data == &quot;&quot; ];then</span><br><span class="line">        echo &quot;输入为空&quot;</span><br><span class="line">elif [ -d $data ](也可以用[ -d“$data”]);then</span><br><span class="line">        echo &quot;输入为一个目录&quot;</span><br><span class="line">elif [ -f $data ];then</span><br><span class="line">        echo &quot;输入为一个文件&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;输入错误&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h2 id="十五、字符串其他操作"><a href="#十五、字符串其他操作" class="headerlink" title="十五、字符串其他操作 "></a><a href="#context.38">十五、字符串其他操作</a><a name="section.38"> </a></h2><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度 "></a><a href="#context.39">获取字符串长度</a><a name="section.39"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#字符串名&#125;</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line">a=hello</span><br><span class="line">echo $&#123;#a&#125;   ---&gt;5</span><br></pre></td></tr></table></figure>



<h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串 "></a><a href="#context.40">拼接字符串</a><a name="section.40"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">echo hello,&#x27;$str&#x27;   # 单引号拼接  &gt; hello,$str</span><br><span class="line">echo hello,”$str”   # 双引号拼接  &gt; hello,world</span><br></pre></td></tr></table></figure>



<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串 "></a><a href="#context.41">截取字符串</a><a name="section.41"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;字符串名:start:end&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong><br>①索引从0开始<br>②截取的字符串包括start和end位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">echo $&#123;str:1:3&#125; ---&gt;ell</span><br></pre></td></tr></table></figure>



<h4 id="查找字符串中的指定字符的索引"><a href="#查找字符串中的指定字符的索引" class="headerlink" title="查找字符串中的指定字符的索引 "></a><a href="#context.42">查找字符串中的指定字符的索引</a><a name="section.42"> </a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr index “$字符串名” 字符</span><br><span class="line"></span><br><span class="line"># exp</span><br><span class="line"># 终端</span><br><span class="line">str=hello</span><br><span class="line">expr index &quot;$str&quot; e  &gt;&gt;&gt;&gt; 2</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>星海</category>
      </categories>
      <tags>
        <tag>星海</tag>
      </tags>
  </entry>
</search>
